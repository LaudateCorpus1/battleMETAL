entity self;
entity other;
entity world;
float time;
float frametime;
float force_retouch;
string mapname;
float deathmatch;
float coop;
float teamplay;
float serverflags;
float total_secrets;
float total_monsters;
float found_secrets;
float killed_monsters;
float parm1;
float parm2;
float parm3;
float parm4;
float parm5;
float parm6;
float parm7;
float parm8;
float parm9;
float parm10;
float parm11;
float parm12;
float parm13;
float parm14;
float parm15;
float parm16;
float v_forward_x;
float v_forward_y;
float v_forward_z;
vector v_forward;
float v_up_x;
float v_up_y;
float v_up_z;
vector v_up;
float v_right_x;
float v_right_y;
float v_right_z;
vector v_right;
float trace_allsolid;
float trace_startsolid;
float trace_fraction;
float trace_endpos_x;
float trace_endpos_y;
float trace_endpos_z;
vector trace_endpos;
float trace_plane_normal_x;
float trace_plane_normal_y;
float trace_plane_normal_z;
vector trace_plane_normal;
float trace_plane_dist;
entity trace_ent;
float trace_inopen;
float trace_inwater;
entity msg_entity;
void () main;
void () StartFrame;
void () PlayerPreThink;
void () PlayerPostThink;
void () ClientKill;
void () ClientConnect;
void () PutClientInServer;
void () ClientDisconnect;
void () SetNewParms;
void () SetChangeParms;
void end_sys_globals;
.float modelindex;
.float absmin_x;
.float absmin_y;
.float absmin_z;
.vector absmin;
.float absmax_x;
.float absmax_y;
.float absmax_z;
.vector absmax;
.float ltime;
.float movetype;
.float solid;
.float origin_x;
.float origin_y;
.float origin_z;
.vector origin;
.float oldorigin_x;
.float oldorigin_y;
.float oldorigin_z;
.vector oldorigin;
.float velocity_x;
.float velocity_y;
.float velocity_z;
.vector velocity;
.float angles_x;
.float angles_y;
.float angles_z;
.vector angles;
.float avelocity_x;
.float avelocity_y;
.float avelocity_z;
.vector avelocity;
.float punchangle_x;
.float punchangle_y;
.float punchangle_z;
.vector punchangle;
.string classname;
.string model;
.float frame;
.float skin;
.float effects;
.float mins_x;
.float mins_y;
.float mins_z;
.vector mins;
.float maxs_x;
.float maxs_y;
.float maxs_z;
.vector maxs;
.float size_x;
.float size_y;
.float size_z;
.vector size;
.void () touch;
.void () use;
.void () think;
.void () blocked;
.float nextthink;
.entity groundentity;
.float health;
.float frags;
.float weapon;
.string weaponmodel;
.float weaponframe;
.float currentammo;
.float ammo_shells;
.float ammo_nails;
.float ammo_rockets;
.float ammo_cells;
.float items;
.float takedamage;
.entity chain;
.float deadflag;
.float view_ofs_x;
.float view_ofs_y;
.float view_ofs_z;
.vector view_ofs;
.float button0;
.float button1;
.float button2;
.float impulse;
.float fixangle;
.float v_angle_x;
.float v_angle_y;
.float v_angle_z;
.vector v_angle;
.float idealpitch;
.string netname;
.entity enemy;
.float flags;
.float colormap;
.float team;
.float max_health;
.float teleport_time;
.float armortype;
.float armorvalue;
.float waterlevel;
.float watertype;
.float ideal_yaw;
.float yaw_speed;
.entity aiment;
.entity goalentity;
.float spawnflags;
.string target;
.string targetname;
.float dmg_take;
.float dmg_save;
.entity dmg_inflictor;
.entity owner;
.float movedir_x;
.float movedir_y;
.float movedir_z;
.vector movedir;
.string message;
.float sounds;
.string noise;
.string noise1;
.string noise2;
.string noise3;
void end_sys_fields;
float FALSE;
float TRUE;
float FL_FLY;
float FL_SWIM;
float FL_CLIENT;
float FL_INWATER;
float FL_MONSTER;
float FL_GODMODE;
float FL_NOTARGET;
float FL_ITEM;
float FL_ONGROUND;
float FL_PARTIALGROUND;
float FL_WATERJUMP;
float FL_JUMPRELEASED;
float FL_SKIPTHINK;
float FL_UNIT;
float FL_NOSHOOT;
float FL_TURRET;
float FL_NODE;
float MOVETYPE_NONE;
float MOVETYPE_WALK;
float MOVETYPE_STEP;
float MOVETYPE_FLY;
float MOVETYPE_TOSS;
float MOVETYPE_PUSH;
float MOVETYPE_NOCLIP;
float MOVETYPE_FLYMISSILE;
float MOVETYPE_BOUNCE;
float MOVETYPE_BOUNCEMISSILE;
float SOLID_NOT;
float SOLID_TRIGGER;
float SOLID_BBOX;
float SOLID_SLIDEBOX;
float SOLID_BSP;
float RANGE_MELEE;
float RANGE_NEAR;
float RANGE_MID;
float RANGE_FAR;
float DEAD_NO;
float DEAD_DYING;
float DEAD_DEAD;
float DEAD_RESPAWNABLE;
float DEAD_RESPAWNING;
float DAMAGE_NO;
float DAMAGE_YES;
float DAMAGE_AIM;
float IT_AXE;
float IT_SHOTGUN;
float IT_SUPER_SHOTGUN;
float IT_NAILGUN;
float IT_SUPER_NAILGUN;
float IT_GRENADE_LAUNCHER;
float IT_ROCKET_LAUNCHER;
float IT_LIGHTNING;
float IT_EXTRA_WEAPON;
float IT_SHELLS;
float IT_NAILS;
float IT_ROCKETS;
float IT_CELLS;
float IT_ARMOR1;
float IT_ARMOR2;
float IT_ARMOR3;
float IT_SUPERHEALTH;
float IT_KEY1;
float IT_KEY2;
float IT_INVISIBILITY;
float IT_INVULNERABILITY;
float IT_SUIT;
float IT_QUAD;
float CONTENT_EMPTY;
float CONTENT_SOLID;
float CONTENT_WATER;
float CONTENT_SLIME;
float CONTENT_LAVA;
float CONTENT_SKY;
float STATE_TOP;
float STATE_BOTTOM;
float STATE_UP;
float STATE_DOWN;
float VEC_ORIGIN_x;
float VEC_ORIGIN_y;
float VEC_ORIGIN_z;
vector VEC_ORIGIN;
float VEC_HULL_MIN_x;
float VEC_HULL_MIN_y;
float VEC_HULL_MIN_z;
vector VEC_HULL_MIN;
float VEC_HULL_MAX_x;
float VEC_HULL_MAX_y;
float VEC_HULL_MAX_z;
vector VEC_HULL_MAX;
float VEC_HULL2_MIN_x;
float VEC_HULL2_MIN_y;
float VEC_HULL2_MIN_z;
vector VEC_HULL2_MIN;
float VEC_HULL2_MAX_x;
float VEC_HULL2_MAX_y;
float VEC_HULL2_MAX_z;
vector VEC_HULL2_MAX;
float SVC_SETVIEWPORT;
float SVC_SETANGLES;
float SVC_TEMPENTITY;
float SVC_KILLEDMONSTER;
float SVC_FOUNDSECRET;
float SVC_INTERMISSION;
float SVC_FINALE;
float SVC_CDTRACK;
float SVC_SELLSCREEN;
float TE_SPIKE;
float TE_SUPERSPIKE;
float TE_GUNSHOT;
float TE_EXPLOSION;
float TE_TAREXPLOSION;
float TE_LIGHTNING1;
float TE_LIGHTNING2;
float TE_WIZSPIKE;
float TE_KNIGHTSPIKE;
float TE_LIGHTNING3;
float TE_LAVASPLASH;
float TE_TELEPORT;
float CHAN_AUTO;
float CHAN_WEAPON;
float CHAN_VOICE;
float CHAN_ITEM;
float CHAN_BODY;
float ATTN_NONE;
float ATTN_NORM;
float ATTN_IDLE;
float ATTN_STATIC;
float UPDATE_GENERAL;
float UPDATE_STATIC;
float UPDATE_BINARY;
float UPDATE_TEMP;
float EF_BRIGHTFIELD;
float EF_MUZZLEFLASH;
float EF_BRIGHTLIGHT;
float EF_DIMLIGHT;
float MSG_BROADCAST;
float MSG_ONE;
float MSG_ALL;
float MSG_INIT;
float movedist;
float gameover;
string string_null;
entity newmis;
entity activator;
entity damage_attacker;
float framecount;
float skill;
.string map;
.float worldtype;
.string killtarget;
.float light_lev;
.float style;
.void () th_stand;
.void () th_walk;
.void () th_run;
.float () th_missile;
.void () th_melee;
.void (entity, float, float, string) th_pain;
.void () th_die;
.entity oldenemy;
.float speed;
.float lefty;
.float search_time;
.float attack_state;
float AS_STRAIGHT;
float AS_SLIDING;
float AS_MELEE;
float AS_MISSILE;
.float walkframe;
.float attack_finished;
.float pain_finished;
.float fly_sound;
.float show_hostile;
.float jump_flag;
.float swim_flag;
.float air_finished;
.float bubble_count;
.string deathtype;
.string mdl;
.float mangle_x;
.float mangle_y;
.float mangle_z;
.vector mangle;
.float t_length;
.float t_width;
.float dest_x;
.float dest_y;
.float dest_z;
.vector dest;
.float dest1_x;
.float dest1_y;
.float dest1_z;
.vector dest1;
.float dest2_x;
.float dest2_y;
.float dest2_z;
.vector dest2;
.float wait;
.float delay;
.entity trigger_field;
.string noise4;
.float pausetime;
.entity movetarget;
.float aflag;
.float dmg;
.float cnt;
.void () think1;
.float count;
.float lip;
.float state;
.float pos1_x;
.float pos1_y;
.float pos1_z;
.vector pos1;
.float pos2_x;
.float pos2_y;
.float pos2_z;
.vector pos2;
.float height;
.float waitmin;
.float waitmax;
.float fog_density;
.float fog_color_x;
.float fog_color_y;
.float fog_color_z;
.vector fog_color;
.float fog_alpha;
.float fog_dist_x;
.float fog_dist_y;
.float fog_dist_z;
.vector fog_dist;
.float fade;
void (vector) makevectors;
void (entity, vector) setorigin;
void (entity, string) setmodel;
void (entity, vector, vector) setsize;
void () break;
float () random;
void (entity, float, string, float, float) sound;
vector (vector) normalize;
void (string) error;
void (string) objerror;
float (vector) vlen;
float (vector) vectoyaw;
entity () spawn;
void (entity) remove;
void (vector, vector, float, entity) traceline;
entity () checkclient;
entity (entity, FIELD TYPE, string) find;
string (string) precache_sound;
string (string) precache_model;
void (entity, string) stuffcmd;
entity (vector, float) findradius;
void (string) bprint;
void (entity, string) sprint;
void (string) dprint;
string (float) ftos;
string (vector) vtos;
void () coredump;
void () traceon;
void () traceoff;
void (entity) eprint;
float (float, float) walkmove;
float () droptofloor;
void (float, string) lightstyle;
float (float) rint;
float (float) floor;
float (float) ceil;
float (entity) checkbottom;
float (vector) pointcontents;
float (float) fabs;
vector (entity, float) aim;
float (string) cvar;
void (string) localcmd;
entity (entity) nextent;
void (vector, vector, float, float) particle;
void () ChangeYaw;
vector (vector) vectoangles;
void (float, float) WriteByte;
void (float, float) WriteChar;
void (float, float) WriteShort;
void (float, float) WriteLong;
void (float, float) WriteCoord;
void (float, float) WriteAngle;
void (float, string) WriteString;
void (float, entity) WriteEntity;
void (float) movetogoal;
string (string) precache_file;
void (entity) makestatic;
void (string) changelevel;
void (string, string) cvar_set;
void (entity, string) centerprint;
void (vector, string, float, float) ambientsound;
string (string) precache_model2;
string (string) precache_sound2;
string (string) precache_file2;
void (entity) setspawnparms;
void (vector, float, function) SUB_CalcMove;
void (entity, vector, float, function) SUB_CalcMoveEnt;
void (vector, float, function) SUB_CalcAngleMove;
void () SUB_CalcMoveDone;
void () SUB_CalcAngleMoveDone;
void () SUB_Null;
void () SUB_UseTargets;
void () SUB_Remove;
void (entity, entity, entity, float) T_Damage;
float (entity, float, float) T_Heal;
float (entity, entity) CanDamage;
float () crandom;
float() crandom = asm
{
local float temp_0;
	CALL0		random;
	SUB_F		return_x,	0.500000,	temp_0;
	MUL_F		FL_SWIM,	temp_0,	temp_0;
	RETURN	temp_0;
	DONE;
}

vector (vector, vector) randompos;
vector(vector m1, vector m2) randompos = asm
{
local vector v;
local vector temp_0;
local float temp_1;
	SUB_V		m2,	m1,	m2;
	CALL0		random;
	MUL_F		m2_x,	return_x,	temp_1;
	ADD_F		temp_1,	m1_x,	v_x;
	CALL0		random;
	MUL_F		m2_y,	return_x,	temp_1;
	ADD_F		temp_1,	m1_y,	v_y;
	CALL0		random;
	MUL_F		m2_z,	return_x,	temp_1;
	ADD_F		temp_1,	m1_z,	v_z;
	RETURN	v_x;
	DONE;
}

vector () randomvec2;
vector() randomvec2 = asm
{
local vector v;
local float temp_1;
	CALL0		random;
	SUB_F		return_x,	0.500000,	v_x;
	CALL0		random;
	SUB_F		return_x,	0.500000,	v_y;
	CALL0		random;
	SUB_F		return_x,	0.500000,	v_z;
	STORE_V	v,	parm0;
	CALL1		normalize;
	STORE_V	return,	v;
	RETURN	v_x;
	DONE;
}

vector () randomdirvec;
vector() randomdirvec = asm
{
local vector v;
local float temp_1;
	CALL0		random;
	SUB_F		return_x,	0.500000,	v_x;
	CALL0		random;
	SUB_F		return_x,	0.500000,	v_y;
	CALL0		random;
	SUB_F		return_x,	0.500000,	v_z;
	STORE_V	v,	parm0;
	CALL1		vlen;
	GT		return_x,	0.250000,	temp_1;
	IF		temp_1,	-9;
	STORE_V	v,	parm0;
	CALL1		vlen;
	LT		return_x,	0.100000,	temp_1;
	IF		temp_1,	-13;
	STORE_V	v,	parm0;
	CALL1		normalize;
	RETURN	return_x;
	DONE;
}

vector (vector) findbetterlocation;
vector(vector org) findbetterlocation = asm
{
local float c;
local vector v;
local float temp_1;
	STORE_V	org,	parm0;
	CALL1		pointcontents;
	NE_F		return_x,	CONTENT_SOLID,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	org_x;
	STORE_F	FALSE,	c;
	LT		c,	20.000000,	temp_1;
	IFNOT		temp_1,	20;
	ADD_F		c,	TRUE,	c;
	CALL0		random;
	MUL_F		return_x,	4.100000,	temp_1;
	ADD_F		org_x,	temp_1,	temp_1;
	SUB_F		temp_1,	FL_SWIM,	v_x;
	CALL0		random;
	MUL_F		return_x,	4.100000,	temp_1;
	ADD_F		org_y,	temp_1,	temp_1;
	SUB_F		temp_1,	FL_SWIM,	v_y;
	CALL0		random;
	MUL_F		return_x,	4.100000,	temp_1;
	ADD_F		org_z,	temp_1,	temp_1;
	SUB_F		temp_1,	FL_SWIM,	v_z;
	STORE_V	v,	parm0;
	CALL1		pointcontents;
	NE_F		return_x,	CONTENT_SOLID,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	v_x;
	GOTO		-20;
	RETURN	org_x;
	DONE;
}

void (entity) findbetterlocation2;
void(entity e) findbetterlocation2 = asm
{
local float c;
local vector org;
local vector v;
local vector temp_0;
local float temp_1;
	INDIRECT_V	e,	origin_x,	parm0;
	CALL1		pointcontents;
	NE_F		return_x,	CONTENT_SOLID,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_V	e,	origin_x,	org;
	STORE_F	FALSE,	c;
	LT		c,	20.000000,	temp_1;
	IFNOT		temp_1,	23;
	ADD_F		c,	TRUE,	c;
	CALL0		random;
	MUL_F		return_x,	4.100000,	temp_1;
	ADD_F		org_x,	temp_1,	temp_1;
	SUB_F		temp_1,	FL_SWIM,	v_x;
	CALL0		random;
	MUL_F		return_x,	4.100000,	temp_1;
	ADD_F		org_y,	temp_1,	temp_1;
	SUB_F		temp_1,	FL_SWIM,	v_y;
	CALL0		random;
	MUL_F		return_x,	4.100000,	temp_1;
	ADD_F		org_z,	temp_1,	temp_1;
	SUB_F		temp_1,	FL_SWIM,	v_z;
	STORE_V	v,	parm0;
	CALL1		pointcontents;
	NE_F		return_x,	CONTENT_SOLID,	temp_1;
	IFNOT		temp_1,	5;
	STORE_F	e,	parm0_x;
	STORE_V	v,	parm1;
	CALL2		setorigin;
	RETURN	offset_0;
	GOTO		-23;
	RETURN	offset_0;
	DONE;
}

vector (vector) findbetterlocation3;
vector(vector org) findbetterlocation3 = asm
{
local vector v2;
local vector temp_0;
local float temp_1;
	SUB_V		org,	'12.000000 0.000000 0.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'12.000000 0.000000 0.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'12.000000 0.000000 0.000000',	org;
	SUB_V		org,	'-12.000000 0.000000 0.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'-12.000000 0.000000 0.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'-12.000000 0.000000 0.000000',	org;
	SUB_V		org,	'0.000000 12.000000 0.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'0.000000 12.000000 0.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'0.000000 12.000000 0.000000',	org;
	SUB_V		org,	'0.000000 -12.000000 0.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'0.000000 -12.000000 0.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'0.000000 -12.000000 0.000000',	org;
	SUB_V		org,	'0.000000 0.000000 12.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'0.000000 0.000000 12.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'0.000000 0.000000 12.000000',	org;
	SUB_V		org,	'0.000000 0.000000 -12.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'0.000000 0.000000 -12.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'0.000000 0.000000 -12.000000',	org;
	RETURN	org_x;
	DONE;
}

vector (vector) findbetterlocation4;
vector(vector org) findbetterlocation4 = asm
{
local vector v2;
local vector temp_0;
local float temp_1;
	SUB_V		org,	'5.000000 0.000000 0.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'5.000000 0.000000 0.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'5.000000 0.000000 0.000000',	org;
	SUB_V		org,	'-5.000000 0.000000 0.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'-5.000000 0.000000 0.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'-5.000000 0.000000 0.000000',	org;
	SUB_V		org,	'0.000000 5.000000 0.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'0.000000 5.000000 0.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'0.000000 5.000000 0.000000',	org;
	SUB_V		org,	'0.000000 -5.000000 0.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'0.000000 -5.000000 0.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'0.000000 -5.000000 0.000000',	org;
	SUB_V		org,	'0.000000 0.000000 5.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'0.000000 0.000000 5.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'0.000000 0.000000 5.000000',	org;
	SUB_V		org,	'0.000000 0.000000 -5.000000',	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	LT		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_V	trace_endpos,	v2;
	ADD_V		v2,	'0.000000 0.000000 -5.000000',	temp_0;
	STORE_V	v2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	world,	parm3_x;
	CALL4		traceline;
	GE		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	ADD_V		v2,	'0.000000 0.000000 -5.000000',	org;
	RETURN	org_x;
	DONE;
}

.float cantrigger;
void (float) bprintfloat;
void(float n) bprintfloat = asm
{
local string s;
	STORE_F	n,	parm0_x;
	CALL1		ftos;
	STORE_S	return_x,	s;
	STORE_F	s,	parm0_x;
	CALL1		bprint;
	DONE;
}

void (vector) bprintvector;
void(vector n) bprintvector = asm
{
local string s;
	STORE_V	n,	parm0;
	CALL1		vtos;
	STORE_S	return_x,	s;
	STORE_F	s,	parm0_x;
	CALL1		bprint;
	DONE;
}

void (float) dprintfloat;
void(float n) dprintfloat = asm
{
local string s;
	STORE_F	n,	parm0_x;
	CALL1		ftos;
	STORE_S	return_x,	s;
	STORE_F	s,	parm0_x;
	CALL1		dprint;
	DONE;
}

void (vector) dprintvector;
void(vector n) dprintvector = asm
{
local string s;
	STORE_V	n,	parm0;
	CALL1		vtos;
	STORE_S	return_x,	s;
	STORE_F	s,	parm0_x;
	CALL1		dprint;
	DONE;
}

string deathstring1;
string deathstring2;
string deathstring3;
string deathstring4;
float DTYPE_OTHER;
float DTYPE_PLAYER;
float DTYPE_WORLD;
float DTYPE_TEAMKILL;
float DTYPE_SUICIDE;
void (entity, entity, string, float) Obituary_Generic;
void(entity targ, entity attacker, string dmsg, float dtype) Obituary_Generic = asm
{
	DONE;
}

void (entity, entity, string, float) Obituary_Fallback;
void(entity targ, entity attacker, string dmsg, float dtype) Obituary_Fallback = asm
{
local float temp_1;
	EQ_F		dtype,	FALSE,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_S	targ,	netname,	deathstring1;
	STORE_S	dmsg,	deathstring2;
	STORE_S	"",	deathstring3;
	STORE_S	"",	deathstring4;
	GOTO		28;
	EQ_F		dtype,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_S	targ,	netname,	deathstring1;
	STORE_S	" became bored with life",	deathstring2;
	STORE_S	"",	deathstring3;
	STORE_S	"",	deathstring4;
	GOTO		21;
	EQ_F		dtype,	TRUE,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_S	targ,	netname,	deathstring1;
	STORE_S	" was killed by ",	deathstring2;
	INDIRECT_S	attacker,	netname,	deathstring3;
	STORE_S	"",	deathstring4;
	GOTO		14;
	EQ_F		dtype,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_S	targ,	netname,	deathstring1;
	STORE_S	" was mowed down by his teammate ",	deathstring2;
	INDIRECT_S	attacker,	netname,	deathstring3;
	STORE_S	"",	deathstring4;
	GOTO		7;
	EQ_F		dtype,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	5;
	INDIRECT_S	targ,	netname,	deathstring1;
	STORE_S	" died of unknown causes",	deathstring2;
	STORE_S	"",	deathstring3;
	STORE_S	"",	deathstring4;
	DONE;
}

float GAME_QUAKE;
float GAME_NEXUIZ;
float game;
float darkmode;
float IT_WEAPON1;
float IT_WEAPON2;
float IT_WEAPON3;
float IT_WEAPON4;
float IT_WEAPON5;
float IT_WEAPON6;
float IT_WEAPON7;
float IT_WEAPON8;
float IT_WEAPON9;
float IT_WEAPON10;
float CHAN_SPEECH;
float CHAN_FOOT;
float CHAN_WEAPON2;
.float gravity;
.float dest3_x;
.float dest3_y;
.float dest3_z;
.vector dest3;
.float dest4_x;
.float dest4_y;
.float dest4_z;
.vector dest4;
.entity flame;
.float doobits;
.float rotate_x;
.float rotate_y;
.float rotate_z;
.vector rotate;
.string group;
.float keys_silver;
.float keys_gold;
.float (entity, entity) pickupevalfunc;
.void (vector, float, float, vector, float) bleedfunc;
.float count1;
.float count2;
.float count3;
.float count4;
.float count5;
.float count6;
.float cnt1;
.float cnt2;
.void (entity, entity, string, float) obitfunc1;
.entity realowner;
float maxclients;
float numdecors;
float maxdecors;
.float createdtime;
void (vector, float, float, vector, float) genericbleedfunc;
.string deathmsg;
.float regenthink;
.float isdecor;
.float radiusdamage_amount;
.float radiusdamage_force_x;
.float radiusdamage_force_y;
.float radiusdamage_force_z;
.vector radiusdamage_force;
.float radiusdamage_hit;
.float radiusdamage_lasthit_x;
.float radiusdamage_lasthit_y;
.float radiusdamage_lasthit_z;
.vector radiusdamage_lasthit;
.float radiusdamage_ownerdamagescale;
float raddamage_lasthit_x;
float raddamage_lasthit_y;
float raddamage_lasthit_z;
vector raddamage_lasthit;
.float (entity, float, float, float, string) damagemodifier;
.void () th_gib;
.float bodyhealth;
void (entity, entity, string, float, function) ClientObituary;
void () monster_death_use;
.float disableclientprediction;
float MOVE_NORMAL;
float MOVE_NOMONSTERS;
float MOVE_MISSILE;
float (string) checkextension;
.float buttonchat;
.float buttonuse;
float EF_ADDITIVE;
float EF_BLUE;
float EF_DOUBLESIDED;
float EF_FLAME;
float EF_FULLBRIGHT;
float EF_NODEPTHTEST;
float EF_NODRAW;
float EF_NOGUNBOB;
float EF_NOSHADOW;
float EF_RED;
float EF_RESTARTANIM_BIT;
float EF_STARDUST;
float EF_TELEPORT_BIT;
.float alpha;
.float colormod_x;
.float colormod_y;
.float colormod_z;
.vector colormod;
.entity exteriormodeltoclient;
.float glow_color;
.float glow_size;
.float glow_trail;
.float glowmod_x;
.float glowmod_y;
.float glowmod_z;
.vector glowmod;
float EF_LOWPRECISION;
.float scale;
.entity viewmodelforclient;
float GECKO_BUTTON_DOWN;
float GECKO_BUTTON_UP;
float GECKO_BUTTON_PRESS;
float GECKO_BUTTON_DOUBLECLICK;
.entity tag_entity;
.float tag_index;
void (entity, entity, string) setattachment;
.float button3;
.float button4;
.float button5;
.float button6;
.float button7;
.float button8;
.float button9;
.float button10;
.float button11;
.float button12;
.float button13;
.float button14;
.float button15;
.float button16;
float MOVETYPE_FOLLOW;
float DEG2RAD;
float RAD2DEG;
float PI;
float (float) asin;
float (float) acos;
float (float) atan;
float (float, float) atan2;
float (float) tan;
.float pitch_speed;
void (entity) changepitch;
void (entity, entity) copyentity;
string (string) cvar_defstring;
string (string) cvar_description;
string (string) cvar_string;
float (string) cvar_type;
float CVAR_TYPEFLAG_EXISTS;
float CVAR_TYPEFLAG_SAVED;
float CVAR_TYPEFLAG_PRIVATE;
float CVAR_TYPEFLAG_ENGINE;
float CVAR_TYPEFLAG_HASDESCRIPTION;
float CVAR_TYPEFLAG_READONLY;
entity (float) edict_num;
float (entity) wasfreed;
float () numentityfields;
string (float) entityfieldname;
float (float) entityfieldtype;
string (float, entity) getentityfieldstring;
float (float, entity, string) putentityfieldstring;
float FIELD_STRING;
float FIELD_FLOAT;
float FIELD_VECTOR;
float FIELD_ENTITY;
float FIELD_FUNCTION;
void (string) loadfromdata;
void (string) loadfromfile;
void (string) callfunction;
void (float, entity) writetofile;
float (string) isfunction;
void (entity, string) parseentitydata;
string (entity) etos;
string () getextresponse;
entity (FIELD TYPE, string) findchain;
entity (FIELD TYPE, float, FIELD TYPE) findradius_tofield;
entity (FIELD TYPE, string, FIELD TYPE) findchain_tofield;
entity (FIELD TYPE, float, FIELD TYPE) findchainflags_tofield;
entity (FIELD TYPE, float, FIELD TYPE) findchainfloat_tofield;
entity (FIELD TYPE, float) findchainflags;
entity (FIELD TYPE, entity) findchainentity;
entity (FIELD TYPE, float) findchainfloat;
entity (entity, FIELD TYPE, float) findflags;
entity (entity, FIELD TYPE, entity) findentity;
entity (entity, FIELD TYPE, float) findfloat;
float (string, float, float) search_begin;
void (float) search_end;
float (float) search_getsize;
string (float, float) search_getfilename;
vector (vector) getlight;
float (entity, float) getsurfacenumpoints;
vector (entity, float, float) getsurfacepoint;
vector (entity, float) getsurfacenormal;
string (entity, float) getsurfacetexture;
float (entity, vector) getsurfacenearpoint;
vector (entity, float, vector) getsurfaceclippedpoint;
float SPA_POSITION;
float SPA_S_AXIS;
float SPA_T_AXIS;
float SPA_R_AXIS;
float SPA_TEXCOORDS0;
float SPA_LIGHTMAP0_TEXCOORDS;
float SPA_LIGHTMAP0_COLOR;
vector (entity, float, float, float) getsurfacepointattribute;
float (entity, float) getsurfacenumtriangles;
vector (entity, float, float) getsurfacetriangle;
float (entity, string) gettagindex;
vector (entity, float) gettaginfo;
float gettaginfo_parent;
string gettaginfo_name;
float gettaginfo_offset_x;
float gettaginfo_offset_y;
float gettaginfo_offset_z;
vector gettaginfo_offset;
float gettaginfo_forward_x;
float gettaginfo_forward_y;
float gettaginfo_forward_z;
vector gettaginfo_forward;
float gettaginfo_right_x;
float gettaginfo_right_y;
float gettaginfo_right_z;
vector gettaginfo_right;
float gettaginfo_up_x;
float gettaginfo_up_y;
float gettaginfo_up_z;
vector gettaginfo_up;
float GETTIME_FRAMESTART;
float GETTIME_REALTIME;
float GETTIME_HIRES;
float GETTIME_UPTIME;
float (float) gettime;
float GETTIME_CDTRACK;
float (float) log;
float (float, float) min;
float (float, float, float) min3;
float (float, float, float, float) min4;
float (float, float, float, float, float) min5;
float (float, float, float, float, float, float) min6;
float (float, float, float, float, float, float, float) min7;
float (float, float, float, float, float, float, float, float) min8;
float (float, float) max;
float (float, float, float) max3;
float (float, float, float, float) max4;
float (float, float, float, float, float) max5;
float (float, float, float, float, float, float) max6;
float (float, float, float, float, float, float, float) max7;
float (float, float, float, float, float, float, float, float) max8;
float (float, float, float) bound;
float (entity) num_for_edict;
vector () randomvec;
float (float) sin;
float (float) cos;
float (float) sqrt;
float (float, float) pow;
string (string) sprintf;
string (float, string) strftime;
float (string) strlennocol;
string (string) strdecolorize;
string (string) strtolower;
string (string) strtoupper;
float (string, string) tokenizebyseparator;
float (string) tokenize_console;
float (float) argv_start_index;
float (float) argv_end_index;
void (vector, vector, vector, vector, float, entity) tracebox;
void (entity, entity) tracetoss;
float MOVE_HITMODEL;
float MOVE_WORLDONLY;
vector (vector, vector) vectoangles2;
void (vector) vectorvectors;
string (string) whichpack;
string (string) uri_escape;
string (string) uri_unescape;
float (string, float) uri_get;
float (string, float, string, string) uri_post;
float (string, float, string, string, float) uri_postbuf;
float (string, string) registercvar;
float (entity, float) getsoundtime;
float (string) soundlength;
float SOLID_CORPSE;
float CLIENTTYPE_DISCONNECTED;
float CLIENTTYPE_REAL;
float CLIENTTYPE_BOT;
float CLIENTTYPE_NOTACLIENT;
entity () spawnclient;
float (entity) clienttype;
.float bouncefactor;
.float bouncestop;
.entity clientcamera;
.float clientcolors;
.float () customizeentityforclient;
.float discardabledemo;
.entity drawonlytoclient;
void (entity) dropclient;
void (vector, string, float, float, float) effect;
.void (float, float) contentstransition;
.void (vector) movetypesteplandevent;
void (vector, string, float, float) pointsound;
.float modelflags;
float EF_NOMODELFLAGS;
float MF_ROCKET;
float MF_GRENADE;
float MF_GIB;
float MF_ROTATE;
float MF_TRACER;
float MF_ZOMGIB;
float MF_TRACER2;
float MF_TRACER3;
.string netaddress;
.entity nodrawtoclient;
.float ping;
.float ping_packetloss;
.float ping_movementloss;
float (string) particleeffectnum;
void (entity, float, vector, vector) trailparticles;
void (float, vector, vector, float) pointparticles;
.float punchvector_x;
.float punchvector_y;
.float punchvector_z;
.vector punchvector;
.float movement_x;
.float movement_y;
.float movement_z;
.vector movement;
void () SV_PlayerPhysics;
float MOVETYPE_PHYSICS;
float SOLID_PHYSICS_BOX;
float SOLID_PHYSICS_SPHERE;
float SOLID_PHYSICS_CAPSULE;
float JOINTTYPE_POINT;
float JOINTTYPE_HINGE;
float JOINTTYPE_SLIDER;
float JOINTTYPE_UNIVERSAL;
float JOINTTYPE_HINGE2;
float JOINTTYPE_FIXED;
.float mass;
.float jointtype;
void (entity, float) physics_enable;
void (entity, vector, vector) physics_addforce;
void (entity, vector) physics_addtorque;
void (string) print;
string worldstatus;
.string clientstatus;
void (entity, float) setcolor;
void (float, string, float) WritePicture;
void (float, string) WriteUnterminatedString;
void (vector, vector, float) te_blood;
float TE_BLOOD;
void (vector, vector, float, float) te_bloodshower;
float TE_BLOODSHOWER;
void (vector, float, float, vector) te_customflash;
float TE_CUSTOMFLASH;
void (vector, vector) te_explosionrgb;
float TE_EXPLOSIONRGB;
void (vector, vector, float) te_flamejet;
float TE_FLAMEJET;
void (vector, vector, vector, float, float, float, float) te_particlecube;
float TE_PARTICLECUBE;
void (vector, vector, vector, float, float) te_particlerain;
float TE_PARTICLERAIN;
void (vector, vector, vector, float, float) te_particlesnow;
float TE_PARTICLESNOW;
void (vector) te_plasmaburn;
float TE_PLASMABURN;
void (vector) te_gunshotquad;
void (vector) te_spikequad;
void (vector) te_superspikequad;
void (vector) te_explosionquad;
void (vector) te_smallflash;
float TE_SMALLFLASH;
void (vector, vector, float) te_spark;
float TE_SPARK;
void (vector) te_gunshot;
void (vector) te_spike;
void (vector) te_superspike;
void (vector) te_explosion;
void (vector) te_tarexplosion;
void (vector) te_wizspike;
void (vector) te_knightspike;
void (vector) te_lavasplash;
void (vector) te_teleport;
void (vector, float, float) te_explosion2;
void (entity, vector, vector) te_lightning1;
void (entity, vector, vector) te_lightning2;
void (entity, vector, vector) te_lightning3;
void (entity, vector, vector) te_beam;
.float dphitcontentsmask;
float trace_dpstartcontents;
float trace_dphitcontents;
float trace_dphitq3surfaceflags;
string trace_dphittexturename;
float DPCONTENTS_SOLID;
float DPCONTENTS_WATER;
float DPCONTENTS_SLIME;
float DPCONTENTS_LAVA;
float DPCONTENTS_SKY;
float DPCONTENTS_BODY;
float DPCONTENTS_CORPSE;
float DPCONTENTS_NODROP;
float DPCONTENTS_PLAYERCLIP;
float DPCONTENTS_MONSTERCLIP;
float DPCONTENTS_DONOTENTER;
float DPCONTENTS_LIQUIDSMASK;
float DPCONTENTS_BOTCLIP;
float DPCONTENTS_OPAQUE;
float Q3SURFACEFLAG_NODAMAGE;
float Q3SURFACEFLAG_SLICK;
float Q3SURFACEFLAG_SKY;
float Q3SURFACEFLAG_LADDER;
float Q3SURFACEFLAG_NOIMPACT;
float Q3SURFACEFLAG_NOMARKS;
float Q3SURFACEFLAG_FLESH;
float Q3SURFACEFLAG_NODRAW;
float Q3SURFACEFLAG_METALSTEPS;
float Q3SURFACEFLAG_NOSTEPS;
float Q3SURFACEFLAG_NONSOLID;
.float viewzoom;
float (float, float) bitshift;
float (string) stof;
float (string, float) fopen;
void (float) fclose;
string (float) fgets;
void (float, string) fputs;
float (string) strlen;
string (string, string) strcat;
string (string, float, float) substring;
vector (string) stov;
string (string) strzone;
void (string) strunzone;
float FILE_READ;
float FILE_APPEND;
float FILE_WRITE;
float (float) skel_create;
float (float, entity, float, float, float, float) skel_build;
float (float) skel_get_numbones;
string (float, float) skel_get_bonename;
float (float, float) skel_get_boneparent;
float (float, string) skel_find_bone;
vector (float, float) skel_get_bonerel;
vector (float, float) skel_get_boneabs;
void (float, float, vector) skel_set_bone;
void (float, float, vector) skel_mul_bone;
void (float, float, float, vector) skel_mul_bones;
void (float, float, float, float) skel_copybones;
void (float) skel_delete;
float (float, string) frameforname;
float (float, float) frameduration;
.float skeletonindex;
.float frame2;
.float frame3;
.float frame4;
.float lerpfrac;
.float lerpfrac3;
.float lerpfrac4;
.float frame1time;
.float frame2time;
.float frame3time;
.float frame4time;
float (float, float, string, string, string, string, string, string) example_skel_findbonegroup;
float(float skel, float bonenum, string g1, string g2, string g3, string g4, string g5, string g6) example_skel_findbonegroup = asm
{
local string bonename;
local float temp_1;
	GE		bonenum,	FALSE,	temp_1;
	IFNOT		temp_1,	28;
	STORE_F	skel,	parm0_x;
	STORE_F	bonenum,	parm1_x;
	CALL2		skel_get_bonename;
	STORE_S	return_x,	bonename;
	EQ_S		bonename,	g1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	EQ_S		bonename,	g2,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FL_SWIM;
	EQ_S		bonename,	g3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	MOVETYPE_WALK;
	EQ_S		bonename,	g4,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	MOVETYPE_STEP;
	EQ_S		bonename,	g5,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	MOVETYPE_FLY;
	EQ_S		bonename,	g6,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	MOVETYPE_TOSS;
	STORE_F	skel,	parm0_x;
	STORE_F	bonenum,	parm1_x;
	CALL2		skel_get_boneparent;
	STORE_F	return_x,	bonenum;
	GOTO		-28;
	RETURN	FALSE;
	DONE;
}

void () example_skel_player_setup;
void() example_skel_player_setup = asm
{
local float locked_416;
local float temp_0;
	ADDRESS	self,	skeletonindex,	locked_416;
	INDIRECT_F	self,	modelindex,	parm0_x;
	CALL1		skel_create;
	STOREP_F	return_x,	locked_416;
	DONE;
}

void (float, float, float) example_skel_player_update_begin;
void(float animmodelindex, float framegroup, float framegroupstarttime) example_skel_player_update_begin = asm
{
local float temp_0;
	ADDRESS	self,	frame,	temp_0;
	STOREP_F	framegroup,	temp_0;
	ADDRESS	self,	frame2,	temp_0;
	STOREP_F	FALSE,	temp_0;
	ADDRESS	self,	frame3,	temp_0;
	STOREP_F	FALSE,	temp_0;
	ADDRESS	self,	frame4,	temp_0;
	STOREP_F	FALSE,	temp_0;
	ADDRESS	self,	frame1time,	temp_0;
	STOREP_F	framegroupstarttime,	temp_0;
	ADDRESS	self,	frame2time,	temp_0;
	STOREP_F	FALSE,	temp_0;
	ADDRESS	self,	frame3time,	temp_0;
	STOREP_F	FALSE,	temp_0;
	ADDRESS	self,	frame4time,	temp_0;
	STOREP_F	FALSE,	temp_0;
	ADDRESS	self,	lerpfrac,	temp_0;
	STOREP_F	FALSE,	temp_0;
	ADDRESS	self,	lerpfrac3,	temp_0;
	STOREP_F	FALSE,	temp_0;
	ADDRESS	self,	lerpfrac4,	temp_0;
	STOREP_F	FALSE,	temp_0;
	INDIRECT_F	self,	skeletonindex,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	animmodelindex,	parm2_x;
	STORE_F	FALSE,	parm3_x;
	STORE_F	FALSE,	parm4_x;
	STORE_F	100000.000000,	parm5_x;
	CALL6		skel_build;
	DONE;
}

void (float, float, float, float, string, string, string) example_skel_player_update_applyoverride;
void(float animmodelindex, float framegroup, float framegroupstarttime, float blendalpha, string groupbonename, string excludegroupname1, string excludegroupname2) example_skel_player_update_applyoverride = asm
{
local float numbones;
local float bonenum;
local float temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	frame,	temp_1;
	STOREP_F	framegroup,	temp_1;
	ADDRESS	self,	frame2,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	frame3,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	frame4,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	frame1time,	temp_1;
	STOREP_F	framegroupstarttime,	temp_1;
	ADDRESS	self,	frame2time,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	frame3time,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	frame4time,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	lerpfrac,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	lerpfrac3,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	lerpfrac4,	temp_1;
	STOREP_F	FALSE,	temp_1;
	STORE_F	FALSE,	bonenum;
	INDIRECT_F	self,	skeletonindex,	parm0_x;
	CALL1		skel_get_numbones;
	STORE_F	return_x,	numbones;
	LT		bonenum,	numbones,	temp_1;
	IFNOT		temp_1,	24;
	INDIRECT_F	self,	skeletonindex,	parm0_x;
	STORE_F	bonenum,	parm1_x;
	STORE_F	groupbonename,	parm2_x;
	STORE_F	excludegroupname1,	parm3_x;
	STORE_F	excludegroupname2,	parm4_x;
	STORE_F	"",	parm5_x;
	STORE_F	"",	parm6_x;
	STORE_F	"",	parm7_x;
	CALL8		example_skel_findbonegroup;
	EQ_F		return_x,	TRUE,	temp_1;
	IFNOT		temp_1,	11;
	INDIRECT_F	self,	skeletonindex,	temp_1;
	SUB_F		TRUE,	blendalpha,	temp_3;
	ADD_F		bonenum,	TRUE,	temp_0;
	STORE_F	temp_1,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	animmodelindex,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	STORE_F	bonenum,	parm4_x;
	STORE_F	temp_0,	parm5_x;
	CALL6		skel_build;
	ADD_F		bonenum,	TRUE,	bonenum;
	GOTO		-24;
	DONE;
}

void (vector, string) example_skel_player_update_eyetarget;
void(vector eyetarget, string bonename) example_skel_player_update_eyetarget = asm
{
local float locked_916;
local vector modeleyetarget;
local vector v;
local vector u;
local vector parentorg;
local vector parentup;
local vector parentright;
local vector parentforward;
local vector boneorg;
local vector boneup;
local vector boneright;
local vector boneforward;
local vector relorg;
local vector relup;
local vector relright;
local vector relforward;
local vector oldup;
local vector oldright;
local vector oldforward;
local vector ang;
local float bonenum;
local float temp_1;
local vector temp_2;
	INDIRECT_F	self,	skeletonindex,	parm0_x;
	STORE_F	bonename,	parm1_x;
	CALL2		skel_find_bone;
	SUB_F		return_x,	TRUE,	bonenum;
	LT		bonenum,	FALSE,	locked_916;
	IFNOT		locked_916,	2;
	RETURN	offset_0;
	STORE_V	v_forward,	oldforward;
	STORE_V	v_right,	oldright;
	STORE_V	v_up,	oldup;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		eyetarget,	temp_2,	v;
	MUL_V		v,	v_forward,	modeleyetarget_x;
	MUL_V		v,	v_right,	locked_916;
	SUB_F		FALSE,	locked_916,	modeleyetarget_y;
	MUL_V		v,	v_up,	modeleyetarget_z;
	INDIRECT_F	self,	skeletonindex,	parm0_x;
	STORE_F	bonenum,	parm1_x;
	CALL2		skel_get_bonerel;
	STORE_V	return,	relorg;
	STORE_V	v_forward,	relforward;
	STORE_V	v_right,	relright;
	STORE_V	v_up,	relup;
	INDIRECT_F	self,	skeletonindex,	parm0_x;
	STORE_F	bonenum,	parm1_x;
	CALL2		skel_get_boneabs;
	STORE_V	return,	boneorg;
	STORE_V	v_forward,	boneforward;
	STORE_V	v_right,	boneright;
	STORE_V	v_up,	boneup;
	INDIRECT_F	self,	skeletonindex,	locked_916;
	INDIRECT_F	self,	skeletonindex,	parm0_x;
	STORE_F	bonenum,	parm1_x;
	CALL2		skel_get_boneparent;
	STORE_F	locked_916,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		skel_get_boneabs;
	STORE_V	return,	parentorg;
	STORE_V	v_forward,	parentforward;
	STORE_V	v_right,	parentright;
	STORE_V	v_up,	parentup;
	SUB_V		modeleyetarget,	boneorg,	u;
	MUL_V		u,	parentforward,	v_x;
	MUL_V		u,	parentright,	v_y;
	MUL_V		u,	parentup,	v_z;
	STORE_V	v,	parm0;
	STORE_V	relup,	parm1;
	CALL2		vectoangles2;
	STORE_V	return,	ang;
	SUB_F		FALSE,	ang_x,	ang_x;
	STORE_V	ang,	parm0;
	CALL1		makevectors;
	INDIRECT_F	self,	skeletonindex,	parm0_x;
	STORE_F	bonenum,	parm1_x;
	STORE_V	relorg,	parm2;
	CALL3		skel_set_bone;
	STORE_V	oldforward,	v_forward;
	STORE_V	oldright,	v_right;
	STORE_V	oldup,	v_up;
	DONE;
}

void () example_skel_player_delete;
void() example_skel_player_delete = asm
{
local float temp_0;
	INDIRECT_F	self,	skeletonindex,	parm0_x;
	CALL1		skel_delete;
	ADDRESS	self,	skeletonindex,	temp_0;
	STOREP_F	FALSE,	temp_0;
	DONE;
}

void (entity, string) clientcommand;
float (string) tokenize;
string (float) argv;
.string playermodel;
.string playerskin;
float EF_SELECTABLE;
.float cursor_active;
.float cursor_screen_x;
.float cursor_screen_y;
.float cursor_screen_z;
.vector cursor_screen;
.float cursor_trace_start_x;
.float cursor_trace_start_y;
.float cursor_trace_start_z;
.vector cursor_trace_start;
.float cursor_trace_endpos_x;
.float cursor_trace_endpos_y;
.float cursor_trace_endpos_z;
.vector cursor_trace_endpos;
.entity cursor_trace_ent;
.float color_x;
.float color_y;
.float color_z;
.vector color;
.float pflags;
float PFLAGS_NOSHADOW;
float PFLAGS_CORONA;
float PFLAGS_FULLDYNAMIC;
float (vector, entity) checkpvs;
float (string, string, float) strstrofs;
float (string, float) str2chr;
string (float) chr2str;
string (float, float, float, string) strconv;
string (float, string) strpad;
string (string, string, string) infoadd;
string (string, string) infoget;
float (string, string, float) strncmp;
float (string, string) strcasecmp;
float (string, string, float) strncasecmp;
float () buf_create;
void (float) buf_del;
float (float) buf_getsize;
void (float, float) buf_copy;
void (float, float, float) buf_sort;
string (float, string) buf_implode;
string (float, float) bufstr_get;
void (float, float, string) bufstr_set;
float (float, string, float) bufstr_add;
void (float, float) bufstr_free;
void (float, string, string) buf_cvarlist;
string (string, string, string) strreplace;
string (string, string, string) strireplace;
float (float, string) crc16;
void (float, float) addstat;
void (float) setpause;
.string crypto_keyfp;
.string crypto_mykeyfp;
.string crypto_idfp;
.string crypto_encryptmethod;
.string crypto_signmethod;
float (string, float, string, string, float, float) crypto_uri_postbuf;
void () SetMovedir;
void () InitTrigger;
void () InitSolidBSPTrigger;
void (entity, vector, float, function) SUB_CalcAngleMoveEnt;
void () DelayThink;
void (float) SUB_AttackFinished;
float (entity) visible;
void (function) SUB_CheckRefire;
vector (vector) SUB_NormalizeAngles;
entity stemp;
entity otemp;
entity s;
entity old;
float SPAWNFLAG_NOMESSAGE;
float SPAWNFLAG_NOTOUCH;
float PLAYER_ONLY;
float SILENT;
float PUSH_ONCE;
.string trigOnSpawn;
.string trigOnDeath;
.string trigOnAttack;
.string trigOnDamage;
.string trigOnPanic;
.string trigOnTarget;
void (entity, FIELD TYPE) trigger_event;
void () multi_wait;
void () multi_trigger;
void () multi_killed;
void () multi_use;
void () multi_touch;
void () counter_use;
void () play_teleport;
void (vector) spawn_tfog;
void () tdeath_touch;
void (vector, entity) spawn_tdeath;
void () teleport_touch;
void () teleport_use;
void () info_teleport_destination;
void () trigger_onlyregistered_touch;
void () hurt_on;
void () hurt_touch;
void () trigger_monsterjump_touch;
void () highlight_hud_touch;
void () trigger_reactivate;
void () trigger_multiple;
void () trigger_once;
void () trigger_relay;
void () trigger_secret;
void () trigger_counter;
void () trigger_teleport;
void () trigger_skill_touch;
void () trigger_setskill;
void () trigger_onlyregistered;
void () trigger_hurt;
void () trigger_push_touch;
void () trigger_push;
void () trigger_monsterjump;
void () trigger_highlighthud;
void () trigger_activate_node;
float SKILL_NOV;
float SKILL_REG;
float SKILL_VET;
float SKILL_ELT;
float READY;
float RELOADING;
float WAITING;
float RECOIL;
.string inv_items;
.string inv_m_light;
.string inv_m_medim;
.string inv_m_heavy;
.entity lst_p;
entity lastspawn;
void () InitBodyQue;
void (entity) CopyToBodyQue;
string nextmap;
float intermission_running;
float intermission_exittime;
float lastclientthink;
float sv_accelerate;
float sv_maxairspeed;
float sv_friction;
float sv_maxspeed;
float sv_stopspeed;
float sv_gravity;
.float ladder_time;
.entity ladder_entity;
string MECH_PIECE;
float M_TOR_CENTER;
float M_TOR_RIGHT;
float M_TOR_LEFT;
float M_LEGS;
float M_LEG_L;
float M_LEG_R;
float M_ARM_LEFT;
float M_ARM_RIGHT;
float DIR_N;
float DIR_NE;
float DIR_E;
float DIR_SE;
float DIR_S;
float DIR_SW;
float DIR_W;
float DIR_NW;
.float data_type;
.float max_armor;
float ARM_LIT;
float ARM_MED;
float ARM_HVY;
float ARM_CER;
float ARM_RAD;
float FIRE_SINGLE;
float FIRE_GROUP;
float FIRE_CHAIN;
.float was_hit;
.float hitdir_buffer;
.float dmgtime;
.float currentWeaponGroup;
.float nextVecChoice;
.float data_idx;
.float w_group1;
.float w_group2;
.float w_group3;
.float w_group4;
.float w_group5;
.float i_faction;
.float i_techlvl;
.float i_reserve;
.float i_size;
.entity w_slot;
.float power_timer;
.float power_timer_segment;
.float lock_timer;
.float chain_timer;
.float repair_request;
.float laser_sight_timer;
.float laser_sight_org_x;
.float laser_sight_org_y;
.float laser_sight_org_z;
.vector laser_sight_org;
.float next_wepn1;
.float next_wepn2;
.float next_wepn3;
.float next_wepn4;
.float next_wepn5;
.float next_wepn6;
.float next_wepn7;
.float next_wepn8;
.float next_wepn9;
.float en_max;
.float en_cur;
.float en_rate;
.float sh_max;
.float sh_cur;
.float sh_rate;
.float sh_hit;
.float rl_max;
.float rl_cur;
.float rl_rate;
.float vec_size;
.string vec_name;
.float spreadDefault_x;
.float spreadDefault_y;
.float spreadDefault_z;
.vector spreadDefault;
.float accuracyMod;
.float accuracyAdj;
.float accuracy;
.float m_rot_speed;
.string m_pitch_min;
.string m_pitch_max;
.entity e_legs;
.entity e_cam;
.entity e_tor_c;
.entity e_tor_l;
.entity e_arm_l;
.entity e_tor_r;
.entity e_arm_r;
.float m_fspeed;
.float m_sspeed;
.float m_bspeed;
.float m_maccel;
.string m_bob;
.string m_bcycle;
.string m_bup;
.string m_rollangle;
.string m_bmodel;
.string m_bside;
.string m_bobspd;
.float mskin;
.string c_model;
.float c_parent;
.float comp_id;
.float c_ofs_x;
.float c_ofs_y;
.float c_ofs_z;
.vector c_ofs;
.float c_alt_ofs_x;
.float c_alt_ofs_y;
.float c_alt_ofs_z;
.vector c_alt_ofs;
.entity c_part;
.string fire_sound;
.float state_1;
.float state_2;
.void () w_attack;
.void () w_think;
.float w_fire_ofs_x;
.float w_fire_ofs_y;
.float w_fire_ofs_z;
.vector w_fire_ofs;
.float w_adj_ang_x;
.float w_adj_ang_y;
.float w_adj_ang_z;
.vector w_adj_ang;
.string w_name;
.float w_proj;
.float w_firerate;
.float w_firemod;
.float w_firemoddur;
.float w_firetime;
.float w_currentammo;
.float w_clipsize;
.float w_isready;
.float w_group;
.float fx_origin_x;
.float fx_origin_y;
.float fx_origin_z;
.vector fx_origin;
.float w_range;
.float w_isburst;
.float w_state;
.float p_lifetime;
.float p_velocity;
.float p_damage;
.float p_dmgtype;
float AS_STRING;
float AS_INT;
float AS_FLOAT_TRUNCATED;
float AS_FLOAT;
.float stat_plr_camx;
.float stat_plr_camy;
.float stat_plr_camz;
.float stat_legs_hp;
.float stat_legs_am;
.float stat_ctor_hp;
.float stat_ctor_am;
.float stat_ltor_hp;
.float stat_ltor_am;
.float stat_rtor_hp;
.float stat_rtor_am;
.float stat_larm_hp;
.float stat_larm_am;
.float stat_rarm_hp;
.float stat_rarm_am;
.float stat_cofs_x;
.float stat_cofs_y;
.float stat_cofs_z;
.float stat_w1_id;
.float stat_w2_id;
.float stat_w3_id;
.float stat_w4_id;
.float stat_w5_id;
.float stat_w6_id;
.float stat_w7_id;
.float stat_w8_id;
.float stat_w9_id;
.float stat_w1_rel;
.float stat_w2_rel;
.float stat_w3_rel;
.float stat_w4_rel;
.float stat_w5_rel;
.float stat_w6_rel;
.float stat_w7_rel;
.float stat_w8_rel;
.float stat_w9_rel;
.float stat_trg_dataidx;
.float stat_trg_sh;
.float stat_trg_dat;
.float stat_hit_dirs;
.float stat_rdr_mode;
.float stat_rdr_rng;
.float stat_wep_state;
.float stat_trg_dist;
.float stat_trg_face;
.float stat_wep_rel;
.float stat_spr_x;
.float stat_spr_y;
.float stat_plr_stt;
.float stat_plr_fir;
.float stat_lck_stt;
.float stat_trg_ddflg;
.float stat_ret_dist;
float STAT_HIT_CL;
float STAT_HIT_LF;
float STAT_HIT_RT;
float STAT_HIT_BK;
float STAT_HIT_TRG;
float COMP_OK;
float COMP_DMG;
float COMP_DYN;
float COMP_REL;
float COMP_RDY;
float WEAPON1_OK;
float WEAPON1_DD;
float WEAPON2_OK;
float WEAPON2_DD;
float WEAPON3_OK;
float WEAPON3_DD;
float WEAPON4_OK;
float WEAPON4_DD;
float WEAPON5_OK;
float WEAPON5_DD;
float WEAPON6_OK;
float WEAPON6_DD;
float WEAPON7_OK;
float WEAPON7_DD;
float WEAPON8_OK;
float WEAPON8_DD;
float WEAPON9_OK;
float WEAPON9_DD;
float WEAPON1_REL;
float WEAPON2_REL;
float WEAPON3_REL;
float WEAPON4_REL;
float WEAPON5_REL;
float WEAPON6_REL;
float WEAPON7_REL;
float WEAPON8_REL;
float WEAPON9_REL;
.void () unit_ini;
.void () unit_legs;
.void () unit_ctor;
.void () unit_ltor;
.void () unit_rtor;
.void () unit_larm;
.void () unit_rarm;
.void () unit_cam;
.void () unit_wep1;
.void () unit_wep2;
.void () unit_wep3;
.void () unit_wep4;
.void () unit_wep5;
.void () unit_wep6;
.void () unit_wep7;
.void () unit_wep8;
.void () unit_wep9;
void () data_otl_ini;
void () data_mtk_ini;
void () data_mnt_ini;
void () data_emp_ini;
void () data_esr_ini;
void () data_las_ini;
void () data_latc_ini;
void () data_marh_ini;
void () data_mis_ini;
void () data_mlgd_ini;
void () data_pac_ini;
void () data_qrfl_ini;
void () data_rplas_ini;
void () data_sfga_ini;
void () data_flak_ini;
void () data_swrm_ini;
void () data_eqp_atgm_ini;
void () data_eqp_enbat_ini;
void () data_eqp_recap_ini;
void () data_eqp_lsar_ini;
void () data_eqp_hsem_ini;
void () data_eqp_scap_ini;
void () data_prj_emp_ini;
void () data_prj_sfga_ini;
void () data_prj_marh_ini;
void () data_prj_mis_ini;
void () data_prj_mlgd_ini;
void () data_prj_qrfl_ini;
void () data_prj_rplas_ini;
void () data_prj_flak_ini;
void () data_prj_swrm_ini;
float IMP_WGROUP1;
float IMP_WGROUP2;
float IMP_WGROUP3;
float IMP_NEXWGRP;
float IMP_PRVWGRP;
float IMP_SUICIDE;
float IMP_TARGET;
float IMP_RADAR;
float IMP_GETNAV;
float IMP_FGROUP;
float IMP_FCHAIN;
float IMP_SHIELD;
float IMP_SWEAPON1;
float IMP_SWEAPON2;
float IMP_SWEAPON3;
float IMP_SWEAPON4;
float IMP_SWEAPON5;
float IMP_SWEAPON6;
float IMP_SWEAPON7;
float IMP_SWEAPON8;
float IMP_SWEAPON9;
float IMP_FSINGLE;
float IMP_WGROUP4;
float IMP_WGROUP5;
float IMP_SHOWOBJ;
float IMP_REPAIR;
float IMP_ZOOM;
void () mpls_singleFire;
void (float) mpls_groupFire;
float SHIELD_RECHARGE_COOLDOWN;
float SHVBAL_EFFPRC_PERCENTAGE;
float SHVBAL_EFFRAM_PERCENTAGE;
float SHVBAL_EFFNON_PERCENTAGE;
float SHVBAL_EFFNON_REDUCE;
float SHVENE_EFFPRC_PERCENTAGE;
float SHVENE_EFFRAM_PERCENTAGE;
float SHVEXP_EFFPRC_PERCENTAGE;
float SHVEXP_EFFSTX_PERCENTAGE;
float SHVEXP_EFFRAM_PERCENTAGE;
float SHVEXP_EFFNON_PERCENTAGE;
float SHVEXP_EFFNON_REDUCE;
float ARM_LT_MOD;
float ARM_MD_MOD;
float ARM_HV_MOD;
float ARM_RAD_MOD;
float ARM_CER_MOD;
float ARM_ANG_MOD;
void () FRIK_FILE_precaches;
void() FRIK_FILE_precaches = asm
{
local string ln;
local float f;
local float temp_0;
	STORE_F	"precache.txt",	parm0_x;
	STORE_F	FALSE,	parm1_x;
	CALL2		fopen;
	STORE_F	return_x,	f;
	NE_F		f,	CONTENT_EMPTY,	temp_0;
	IFNOT		temp_0,	45;
	STORE_F	f,	parm0_x;
	CALL1		fgets;
	STORE_S	return_x,	ln;
	NE_S		ln,	"",	temp_0;
	IFNOT		temp_0,	40;
	STORE_F	ln,	parm0_x;
	STORE_F	".wav",	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		strstrofs;
	NE_F		return_x,	CONTENT_EMPTY,	temp_0;
	IFNOT		temp_0,	4;
	STORE_F	ln,	parm0_x;
	CALL1		precache_sound;
	GOTO		27;
	STORE_F	ln,	parm0_x;
	STORE_F	".ogg",	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		strstrofs;
	NE_F		return_x,	CONTENT_EMPTY,	temp_0;
	IFNOT		temp_0,	4;
	STORE_F	ln,	parm0_x;
	CALL1		precache_sound;
	GOTO		18;
	STORE_F	ln,	parm0_x;
	STORE_F	".md3",	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		strstrofs;
	NE_F		return_x,	CONTENT_EMPTY,	temp_0;
	IFNOT		temp_0,	4;
	STORE_F	ln,	parm0_x;
	CALL1		precache_model;
	GOTO		9;
	STORE_F	ln,	parm0_x;
	STORE_F	".obj",	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		strstrofs;
	NE_F		return_x,	CONTENT_EMPTY,	temp_0;
	IFNOT		temp_0,	3;
	STORE_F	ln,	parm0_x;
	CALL1		precache_model;
	STORE_F	f,	parm0_x;
	CALL1		fgets;
	STORE_S	return_x,	ln;
	GOTO		-40;
	STORE_F	f,	parm0_x;
	CALL1		fclose;
	DONE;
}

string MAP_NAME;
string PATH_DATA_MAP;
string PATH_DATA_ANIM;
string PATH_DATA_SAVE;
string PATH_DATA_UI;
string NEWLINE;
float GAMEMODE_CAMPAIGN;
float GAMEMODE_COOP;
float GAMEMODE_DM;
float GAMEMODE_TEAMDM;
float WORLD_DESERT;
float WORLD_BADLND;
float WORLD_URBAN;
float WORLD_TUNDRA;
float WORLD_ICE;
float WORLD_CAVE;
float PLAYER_DEAD;
float PLAYER_CONNECT;
float PLAYER_SPAWN;
float PLAYER_IN_MENU;
float PLAYER_POWERUP_BEGIN;
float PLAYER_POWERUP_END;
float PLAYER_ACTIVE;
float PLAYER_ANIM_STOP;
float PLAYER_SPRINT_ON;
float PLAYER_SPRINT_OFF;
float GAME_TOTAL_MECHS;
float GAME_TOTAL_ITEMS;
float MECHLIST_TOTAL;
string DATA;
float DATA_POBS;
float DATA_MECH;
float DATA_VEHC;
float DATA_WEPN;
float DATA_PROJ;
float DATA_HUD;
float DATA_BLD;
float DATA_NAVP;
float DATA_OBJT;
float DATA_NODE;
float DATA_DEPL;
float DATA_PLR;
float DATA_WEAPON;
float DATA_INFO_START;
float DATA_INFO_COOP;
float WEAPON1;
float WEAPON2;
float WEAPON3;
float WEAPON4;
float WEAPON5;
float WEAPON6;
float WEAPON7;
float WEAPON8;
float WEAPON9;
float SHIELD_DELAY;
float SHIELD_SOAK;
float DMG_BAL;
float DMG_ENE;
float DMG_EXP;
float EFF_PRC;
float EFF_RAM;
float EFF_STX;
float EFF_ENG;
float DMG_MSC;
float EFF_ENE;
float EFF_ARC;
float RADAR_SWEEP;
.float radar_time;
.float radar_range;
.float hardpoint_cnt;
.float stat_trg_ent_id;
.float stat_trg_faction;
.float stat_plr_ang_x;
.float stat_plr_ang_y;
.float stat_plr_ang_z;
.float stat_plr_rep;
float STAT_ACCURACY;
float STAT_TARG_EID;
float STAT_VID;
float STAT_CAM_ORG_X;
float STAT_CAM_ORG_Y;
float STAT_CAM_ORG_Z;
float STAT_PLR_ORG_X;
float STAT_PLR_ORG_Y;
float STAT_PLR_ORG_Z;
float STAT_PLR_STT;
float STAT_PLR_DTYPE;
float STAT_PLR_DIDX;
float STAT_PLR_RADMOD;
float STAT_PLR_HITDIR;
float STAT_PLR_RETDIST;
float STAT_TRG_ENT_ID;
float STAT_TRG_DATATYPE;
float STAT_TRG_DATAIDX;
float STAT_TRG_DIST;
float STAT_TRG_FACE;
float STAT_TRG_FACTION;
float STAT_TRG_LG_HP;
float STAT_TRG_CT_HP;
float STAT_TRG_LT_HP;
float STAT_TRG_RT_HP;
float STAT_TRG_LA_HP;
float STAT_TRG_RA_HP;
float TRG_VEC_SIZ;
float TRG_P_CLASS;
float STAT_WEP1_ID;
float STAT_WEP2_ID;
float STAT_WEP3_ID;
float STAT_WEP4_ID;
float STAT_WEP5_ID;
float STAT_WEP6_ID;
float STAT_WEP7_ID;
float STAT_WEP8_ID;
float STAT_WEP9_ID;
float STAT_WEP_STT;
float STAT_WEP_GRP;
float STAT_WEP_REL;
float STAT_NAV_DIR;
float STAT_PLR_FIR;
float STAT_LCK_STT;
float STAT_PLR_PTC;
float STAT_PLR_ANG;
float STAT_TRG_DDFLG;
float STAT_TRG_ORGX;
float STAT_TRG_ORGY;
float STAT_TRG_ORGZ;
float STAT_RAD_SWEEP;
float STAT_PLR_ANG_X;
float STAT_PLR_ANG_Y;
float STAT_PLR_ANG_Z;
float STAT_PLR_REP;
float STAT_PLR_NAME;
float LOCK_NONE;
float LOCK_TARG_START;
float LOCK_TARG_HAS;
float LOCK_PLYR;
float POWERUP_DEFAULT;
float POWERUP_DEBUG;
float POWERUP_LIGHT;
float POWERUP_MEDIUM;
float POWERUP_HEAVY;
float ACCURACY_SKIRMISH_x;
float ACCURACY_SKIRMISH_y;
float ACCURACY_SKIRMISH_z;
vector ACCURACY_SKIRMISH;
float ACCURACY_SNIPER_x;
float ACCURACY_SNIPER_y;
float ACCURACY_SNIPER_z;
vector ACCURACY_SNIPER;
float ACCURACY_MARKSMAN_x;
float ACCURACY_MARKSMAN_y;
float ACCURACY_MARKSMAN_z;
vector ACCURACY_MARKSMAN;
float ACCURACY_LOWTECH_x;
float ACCURACY_LOWTECH_y;
float ACCURACY_LOWTECH_z;
vector ACCURACY_LOWTECH;
float ACCURACY_PRIMITVE_x;
float ACCURACY_PRIMITVE_y;
float ACCURACY_PRIMITVE_z;
vector ACCURACY_PRIMITVE;
float ID_PRJ_LATC;
float ID_PRJ_EMP;
float ID_PRJ_MIS;
float ID_PRJ_MLGD;
float ID_PRJ_MARH;
float ID_PRJ_RPLAS;
float ID_PRJ_QRFL;
float ID_PRJ_SFGA;
float ID_PRJ_ION;
float ID_PRJ_SWRM;
float ID_PRJ_ABT;
float ID_PRJ_ABT_CLST;
float DAT_PRJ_EMP_VELOCITY;
float DAT_PRJ_ION_VELOCITY;
float DAT_PRJ_MARH_VELOCITY;
float DAT_PRJ_MIS_VELOCITY;
float DAT_PRJ_MLGD_VELOCITY;
float DAT_PRJ_QRFL_VELOCITY;
float DAT_PRJ_RPLAS_VELOCITY;
float DAT_PRJ_SFGA_VELOCITY;
float DAT_PRJ_FLAK_VELOCITY;
float DAT_PRJ_SWRM_VELOCITY;
float DAT_PRJ_ABT_VELOCITY;
float DAT_PRJ_ABT_CLST_VELOCITY;
float DAT_PRJ_EMP_LIFETIME;
float DAT_PRJ_ION_LIFETIME;
float DAT_PRJ_MARH_LIFETIME;
float DAT_PRJ_MIS_LIFETIME;
float DAT_PRJ_MLGD_LIFETIME;
float DAT_PRJ_QRFL_LIFETIME;
float DAT_PRJ_RPLAS_LIFETIME;
float DAT_PRJ_SFGA_LIFETIME;
float DAT_PRJ_FLAK_LIFETIME;
float DAT_PRJ_SWRM_LIFETIME;
float DAT_PRJ_ABT_LIFETIME;
float DAT_PRJ_ABT_CLST_LIFETIME;
float DAT_PRJ_EMP_PROXYRAD;
float DAT_PRJ_EMP_EXPRAD;
float DAT_PRJ_ION_PROXYRAD;
float DAT_PRJ_ION_EXPRAD;
float DAT_PRJ_SFGA_RAD;
float DAT_PRJ_FLAK_PROXYRAD;
float DAT_PRJ_FLAK_EXPRAD;
string DAT_PRJ_EMP_MODEL;
string DAT_PRJ_ION_MODEL;
string DAT_PRJ_MARH_MODEL;
string DAT_PRJ_MIS_MODEL;
string DAT_PRJ_MLGD_MODEL;
string DAT_PRJ_QRFL_MODEL;
string DAT_PRJ_RPLAS_MODEL;
string DAT_PRJ_SFGA_MODEL;
string DAT_PRJ_FLAK_MODEL;
string DAT_PRJ_SWRM_MODEL;
string DAT_PRJ_ABT_MODEL;
string DAT_PRJ_ABT_CLST_MODEL;
float DAT_PRJ_EMP_EFFECTS;
float DAT_PRJ_EMP_MODELFLAGS;
float DAT_PRJ_EMP_ALPHA;
float DAT_PRJ_EMP_COLORMOD_x;
float DAT_PRJ_EMP_COLORMOD_y;
float DAT_PRJ_EMP_COLORMOD_z;
vector DAT_PRJ_EMP_COLORMOD;
float DAT_PRJ_EMP_GLOWCOLOR;
float DAT_PRJ_EMP_GLOWSIZE;
float DAT_PRJ_EMP_GLOWTRAIL;
float DAT_PRJ_ION_EFFECTS;
float DAT_PRJ_ION_MODELFLAGS;
float DAT_PRJ_ION_ALPHA;
float DAT_PRJ_ION_COLORMOD_x;
float DAT_PRJ_ION_COLORMOD_y;
float DAT_PRJ_ION_COLORMOD_z;
vector DAT_PRJ_ION_COLORMOD;
float DAT_PRJ_ION_GLOWCOLOR;
float DAT_PRJ_ION_GLOWSIZE;
float DAT_PRJ_ION_GLOWTRAIL;
float DAT_PRJ_MARH_EFFECTS;
float DAT_PRJ_MARH_MODELFLAGS;
float DAT_PRJ_MARH_ALPHA;
float DAT_PRJ_MARH_COLORMOD_x;
float DAT_PRJ_MARH_COLORMOD_y;
float DAT_PRJ_MARH_COLORMOD_z;
vector DAT_PRJ_MARH_COLORMOD;
float DAT_PRJ_MARH_GLOWCOLOR;
float DAT_PRJ_MARH_GLOWSIZE;
float DAT_PRJ_MARH_GLOWTRAIL;
float DAT_PRJ_MIS_EFFECTS;
float DAT_PRJ_MIS_MODELFLAGS;
float DAT_PRJ_MIS_ALPHA;
float DAT_PRJ_MIS_COLORMOD_x;
float DAT_PRJ_MIS_COLORMOD_y;
float DAT_PRJ_MIS_COLORMOD_z;
vector DAT_PRJ_MIS_COLORMOD;
float DAT_PRJ_MIS_GLOWCOLOR;
float DAT_PRJ_MIS_GLOWSIZE;
float DAT_PRJ_MIS_GLOWTRAIL;
float DAT_PRJ_MLGD_EFFECTS;
float DAT_PRJ_MLGD_MODELFLAGS;
float DAT_PRJ_MLGD_ALPHA;
float DAT_PRJ_MLGD_COLORMOD_x;
float DAT_PRJ_MLGD_COLORMOD_y;
float DAT_PRJ_MLGD_COLORMOD_z;
vector DAT_PRJ_MLGD_COLORMOD;
float DAT_PRJ_MLGD_GLOWCOLOR;
float DAT_PRJ_MLGD_GLOWSIZE;
float DAT_PRJ_MLGD_GLOWTRAIL;
float DAT_PRJ_QRFL_EFFECTS;
float DAT_PRJ_QRFL_MODELFLAGS;
float DAT_PRJ_QRFL_ALPHA;
float DAT_PRJ_QRFL_COLORMOD_x;
float DAT_PRJ_QRFL_COLORMOD_y;
float DAT_PRJ_QRFL_COLORMOD_z;
vector DAT_PRJ_QRFL_COLORMOD;
float DAT_PRJ_QRFL_GLOWCOLOR;
float DAT_PRJ_QRFL_GLOWSIZE;
float DAT_PRJ_QRFL_GLOWTRAIL;
float DAT_PRJ_RPLAS_EFFECTS;
float DAT_PRJ_RPLAS_MODELFLAGS;
float DAT_PRJ_RPLAS_ALPHA;
float DAT_PRJ_RPLAS_COLORMOD_x;
float DAT_PRJ_RPLAS_COLORMOD_y;
float DAT_PRJ_RPLAS_COLORMOD_z;
vector DAT_PRJ_RPLAS_COLORMOD;
float DAT_PRJ_RPLAS_GLOWCOLOR;
float DAT_PRJ_RPLAS_GLOWSIZE;
float DAT_PRJ_RPLAS_GLOWTRAIL;
float DAT_PRJ_SFGA_EFFECTS;
float DAT_PRJ_SFGA_MODELFLAGS;
float DAT_PRJ_SFGA_ALPHA;
float DAT_PRJ_SFGA_COLORMOD_x;
float DAT_PRJ_SFGA_COLORMOD_y;
float DAT_PRJ_SFGA_COLORMOD_z;
vector DAT_PRJ_SFGA_COLORMOD;
float DAT_PRJ_SFGA_GLOWCOLOR;
float DAT_PRJ_SFGA_GLOWSIZE;
float DAT_PRJ_SFGA_GLOWTRAIL;
float DAT_PRJ_FLAK_EFFECTS;
float DAT_PRJ_FLAK_MODELFLAGS;
float DAT_PRJ_FLAK_ALPHA;
float DAT_PRJ_FLAK_COLORMOD_x;
float DAT_PRJ_FLAK_COLORMOD_y;
float DAT_PRJ_FLAK_COLORMOD_z;
vector DAT_PRJ_FLAK_COLORMOD;
float DAT_PRJ_FLAK_GLOWCOLOR;
float DAT_PRJ_FLAK_GLOWSIZE;
float DAT_PRJ_FLAK_GLOWTRAIL;
float DAT_PRJ_SWRM_EFFECTS;
float DAT_PRJ_SWRM_MODELFLAGS;
float DAT_PRJ_SWRM_ALPHA;
float DAT_PRJ_SWRM_COLORMOD_x;
float DAT_PRJ_SWRM_COLORMOD_y;
float DAT_PRJ_SWRM_COLORMOD_z;
vector DAT_PRJ_SWRM_COLORMOD;
float DAT_PRJ_SWRM_GLOWCOLOR;
float DAT_PRJ_SWRM_GLOWSIZE;
float DAT_PRJ_SWRM_GLOWTRAIL;
float DAT_PRJ_ABT_EFFECTS;
float DAT_PRJ_ABT_MODELFLAGS;
float DAT_PRJ_ABT_ALPHA;
float DAT_PRJ_ABT_COLORMOD_x;
float DAT_PRJ_ABT_COLORMOD_y;
float DAT_PRJ_ABT_COLORMOD_z;
vector DAT_PRJ_ABT_COLORMOD;
float DAT_PRJ_ABT_GLOWCOLOR;
float DAT_PRJ_ABT_GLOWSIZE;
float DAT_PRJ_ABT_GLOWTRAIL;
float DAT_PRJ_ABT_CLST_EFFECTS;
float DAT_PRJ_ABT_CLST_MODELFLAGS;
float DAT_PRJ_ABT_CLST_ALPHA;
float DAT_PRJ_ABT_CLST_COLORMOD_x;
float DAT_PRJ_ABT_CLST_COLORMOD_y;
float DAT_PRJ_ABT_CLST_COLORMOD_z;
vector DAT_PRJ_ABT_CLST_COLORMOD;
float DAT_PRJ_ABT_CLST_GLOWCOLOR;
float DAT_PRJ_ABT_CLST_GLOWSIZE;
float DAT_PRJ_ABT_CLST_GLOWTRAIL;
float ID_WEP_LATC;
float ID_WEP_EMP;
float ID_WEP_LAS;
float ID_WEP_MIS;
float ID_WEP_QRF;
float ID_WEP_RPC;
float ID_WEP_PAC;
float ID_WEP_ESR;
float ID_WEP_MLGD;
float ID_WEP_MARH;
float ID_WEP_SFGA;
float ID_WEP_FLAK;
float ID_WEP_ION;
float ID_WEP_SWRM;
float ID_EQP_ATGM;
float ID_EQP_ENBAT;
float ID_EQP_HSEM;
float ID_EQP_LSAR;
float ID_EQP_SCAP;
float ID_EQP_RECAP;
string DAT_LATC_NAME;
string DAT_LAS_NAME;
string DAT_EMP_NAME;
string DAT_MIS_NAME;
string DAT_QRF_NAME;
string DAT_RPC_NAME;
string DAT_PAC_NAME;
string DAT_ESR_NAME;
string DAT_MLGD_NAME;
string DAT_MARH_NAME;
string DAT_SFGA_NAME;
string DAT_FLAK_NAME;
string DAT_ION_NAME;
string DAT_SWRM_NAME;
string DAT_EQP_ATGM_NAME;
string DAT_EQP_ENBAT_NAME;
string DAT_EQP_HSEM_NAME;
string DAT_EQP_LSAR_NAME;
string DAT_EQP_SCAP_NAME;
string DAT_EQP_RECAP_NAME;
float DAT_LATC_RANGE;
float DAT_RPLAS_RANGE;
float DAT_QRFL_RANGE;
float DAT_SFGA_RANGE;
float DAT_FLAK_RANGE;
float DAT_LAS_RANGE;
float DAT_ION_RANGE;
float DAT_EMP_RANGE;
float DAT_ESR_RANGE;
float DAT_PAC_RANGE;
float DAT_MIS_RANGE;
float DAT_MLGD_RANGE;
float DAT_MARH_RANGE;
float DAT_SWRM_RANGE;
float DAT_LATC_RL_RATE;
float DAT_LATC_RL_MAX;
float DAT_LATC_EN_RATE;
float DAT_RPLAS_RL_RATE;
float DAT_RPLAS_RL_MAX;
float DAT_RPLAS_EN_RATE;
float DAT_QRFL_RL_RATE;
float DAT_QRFL_RL_MAX;
float DAT_QRFL_EN_RATE;
float DAT_SFGA_RL_RATE;
float DAT_SFGA_RL_MAX;
float DAT_SFGA_EN_RATE;
float DAT_FLAK_RL_RATE;
float DAT_FLAK_RL_MAX;
float DAT_FLAK_EN_RATE;
float DAT_LAS_RL_RATE;
float DAT_LAS_RL_MAX;
float DAT_LAS_EN_RATE;
float DAT_ION_RL_RATE;
float DAT_ION_RL_MAX;
float DAT_ION_EN_RATE;
float DAT_EMP_RL_RATE;
float DAT_EMP_RL_MAX;
float DAT_EMP_EN_RATE;
float DAT_ESR_RL_RATE;
float DAT_ESR_RL_MAX;
float DAT_ESR_EN_RATE;
float DAT_PAC_RL_RATE;
float DAT_PAC_RL_MAX;
float DAT_PAC_EN_RATE;
float DAT_MIS_RL_RATE;
float DAT_MIS_RL_MAX;
float DAT_MIS_EN_RATE;
float DAT_MLGD_RL_RATE;
float DAT_MLGD_RL_MAX;
float DAT_MLGD_EN_RATE;
float DAT_MARH_RL_RATE;
float DAT_MARH_RL_MAX;
float DAT_MARH_EN_RATE;
float DAT_SWRM_RL_RATE;
float DAT_SWRM_RL_MAX;
float DAT_SWRM_EN_RATE;
float DAT_EQP_ENBAT_EN_RATE;
float DAT_EQP_RECAP_EN_RATE;
float DAT_EQP_LSAR_EN_RATE;
float DAT_EQP_HSEM_EN_RATE;
float DAT_EQP_SCAP_EN_RATE;
float DAT_LATC_DMG;
float DAT_RPLAS_DMG;
float DAT_RPLAS_DMG_BURN;
float DAT_QRFL_DMG;
float DAT_SFGA_DMG;
float DAT_FLAK_DMG;
float DAT_FLAK_SHRAP_TOTAL;
float DAT_LAS_DMG;
float DAT_ION_DMG;
float DAT_EMP_DMG;
float DAT_ESR_DMG;
float DAT_PAC_DMG;
float DAT_MIS_DMG;
float DAT_MLGD_DMG;
float DAT_MARH_DMG;
float DAT_SWRM_DMG;
float DAT_LATC_ACC_x;
float DAT_LATC_ACC_y;
float DAT_LATC_ACC_z;
vector DAT_LATC_ACC;
float DAT_RPC_ACC_x;
float DAT_RPC_ACC_y;
float DAT_RPC_ACC_z;
vector DAT_RPC_ACC;
float DAT_QRFL_ACC_x;
float DAT_QRFL_ACC_y;
float DAT_QRFL_ACC_z;
vector DAT_QRFL_ACC;
float DAT_SFGA_ACC_x;
float DAT_SFGA_ACC_y;
float DAT_SFGA_ACC_z;
vector DAT_SFGA_ACC;
float DAT_FLAK_ACC_x;
float DAT_FLAK_ACC_y;
float DAT_FLAK_ACC_z;
vector DAT_FLAK_ACC;
float DAT_LAS_ACC_x;
float DAT_LAS_ACC_y;
float DAT_LAS_ACC_z;
vector DAT_LAS_ACC;
float DAT_ION_ACC_x;
float DAT_ION_ACC_y;
float DAT_ION_ACC_z;
vector DAT_ION_ACC;
float DAT_EMP_ACC_x;
float DAT_EMP_ACC_y;
float DAT_EMP_ACC_z;
vector DAT_EMP_ACC;
float DAT_ESR_ACC_x;
float DAT_ESR_ACC_y;
float DAT_ESR_ACC_z;
vector DAT_ESR_ACC;
float DAT_PAC_ACC_x;
float DAT_PAC_ACC_y;
float DAT_PAC_ACC_z;
vector DAT_PAC_ACC;
float DAT_MIS_ACC_x;
float DAT_MIS_ACC_y;
float DAT_MIS_ACC_z;
vector DAT_MIS_ACC;
float DAT_LGM_ACC_x;
float DAT_LGM_ACC_y;
float DAT_LGM_ACC_z;
vector DAT_LGM_ACC;
float DAT_MARH_ACC_x;
float DAT_MARH_ACC_y;
float DAT_MARH_ACC_z;
vector DAT_MARH_ACC;
float DAT_SWRM_ACC_x;
float DAT_SWRM_ACC_y;
float DAT_SWRM_ACC_z;
vector DAT_SWRM_ACC;
float DAT_ATGM_ACC_x;
float DAT_ATGM_ACC_y;
float DAT_ATGM_ACC_z;
vector DAT_ATGM_ACC;
float DAT_LATC_CLIPSIZE;
float DAT_FLAK_CLIPSIZE;
float DAT_RPLAS_CLIPSIZE;
float DAT_QRFL_CLIPSIZE;
float DAT_SFGA_CLIPSIZE;
float DAT_LAS_CLIPSIZE;
float DAT_ION_CLIPSIZE;
float DAT_EMP_CLIPSIZE;
float DAT_ESR_CLIPSIZE;
float DAT_PAC_CLIPSIZE;
float DAT_MIS_CLIPSIZE;
float DAT_MLGD_CLIPSIZE;
float DAT_MARH_CLIPSIZE;
float DAT_SWRM_CLIPSIZE;
float DAT_LATC_TECH_LEVEL;
float DAT_RPLAS_TECH_LEVEL;
float DAT_QRFL_TECH_LEVEL;
float DAT_SFGA_TECH_LEVEL;
float DAT_FLAK_TECH_LEVEL;
float DAT_LAS_TECH_LEVEL;
float DAT_ION_TECH_LEVEL;
float DAT_EMP_TECH_LEVEL;
float DAT_ESR_TECH_LEVEL;
float DAT_PAC_TECH_LEVEL;
float DAT_MIS_TECH_LEVEL;
float DAT_MLGD_TECH_LEVEL;
float DAT_MARH_TECH_LEVEL;
float DAT_SWRM_TECH_LEVEL;
float DAT_EQP_ATGM_TECH_LEVEL;
float DAT_EQP_ENBAT_TECH_LEVEL;
float DAT_EQP_HSEM_TECH_LEVEL;
float DAT_EQP_LSAR_TECH_LEVEL;
float DAT_EQP_SCAP_TECH_LEVEL;
float DAT_EQP_RECAP_TECH_LEVEL;
float DAT_LATC_WSIZE;
float DAT_FLAK_WSIZE;
float DAT_RPLAS_WSIZE;
float DAT_QRFL_WSIZE;
float DAT_SFGA_WSIZE;
float DAT_LAS_WSIZE;
float DAT_ION_WSIZE;
float DAT_EMP_WSIZE;
float DAT_ESR_WSIZE;
float DAT_PAC_WSIZE;
float DAT_MIS_WSIZE;
float DAT_MLGD_WSIZE;
float DAT_MARH_WSIZE;
float DAT_SWRM_WSIZE;
float DAT_EQP_ATGM_WSIZE;
float DAT_EQP_ENBAT_WSIZE;
float DAT_EQP_HSEM_WSIZE;
float DAT_EQP_LSAR_WSIZE;
float DAT_EQP_SCAP_WSIZE;
float DAT_EQP_RECAP_WSIZE;
string DAT_LATC_FIRESOUND;
string DAT_FLAK_FIRESOUND;
string DAT_RPLAS_FIRESOUND;
string DAT_QRFL_FIRESOUND;
string DAT_SFGA_FIRESOUND;
string DAT_LAS_FIRESOUND;
string DAT_ION_FIRESOUND;
string DAT_EMP_FIRESOUND;
string DAT_ESR_FIRESOUND;
string DAT_PAC_FIRESOUND;
string DAT_MIS_FIRESOUND;
string DAT_MLGD_FIRESOUND;
string DAT_MARH_FIRESOUND;
string DAT_SWRM_FIRESOUND;
string DAT_LATC_MODEL;
string DAT_FLAK_MODEL;
string DAT_RPLAS_MODEL;
string DAT_QRFL_MODEL;
string DAT_SFGA_MODEL;
string DAT_LAS_MODEL;
string DAT_ION_MODEL;
string DAT_EMP_MODEL;
string DAT_ESR_MODEL;
string DAT_PAC_MODEL;
string DAT_MIS_MODEL;
string DAT_MLGD_MODEL;
string DAT_MARH_MODEL;
string DAT_SWRM_MODEL;
string DAT_EQP_ATGM_MODEL;
string DAT_EQP_ENBAT_MODEL;
string DAT_EQP_HSEM_MODEL;
string DAT_EQP_LSAR_MODEL;
string DAT_EQP_SCAP_MODEL;
string DAT_EQP_RECAP_MODEL;
string DAT_LATC_ICON;
string DAT_FLAK_ICON;
string DAT_RPLAS_ICON;
string DAT_QRFL_ICON;
string DAT_SFGA_ICON;
string DAT_LAS_ICON;
string DAT_ION_ICON;
string DAT_EMP_ICON;
string DAT_ESR_ICON;
string DAT_PAC_ICON;
string DAT_MIS_ICON;
string DAT_MLGD_ICON;
string DAT_MARH_ICON;
string DAT_SWRM_ICON;
string DAT_EQP_ATGM_ICON;
string DAT_EQP_ENBAT_ICON;
string DAT_EQP_HSEM_ICON;
string DAT_EQP_LSAR_ICON;
string DAT_EQP_SCAP_ICON;
string DAT_EQP_RECAP_ICON;
float DAT_LATC_FIRE_OFS_x;
float DAT_LATC_FIRE_OFS_y;
float DAT_LATC_FIRE_OFS_z;
vector DAT_LATC_FIRE_OFS;
float DAT_FLAK_FIRE_OFS_x;
float DAT_FLAK_FIRE_OFS_y;
float DAT_FLAK_FIRE_OFS_z;
vector DAT_FLAK_FIRE_OFS;
float DAT_RPLAS_FIRE_OFS_x;
float DAT_RPLAS_FIRE_OFS_y;
float DAT_RPLAS_FIRE_OFS_z;
vector DAT_RPLAS_FIRE_OFS;
float DAT_QRFL_FIRE_OFS_x;
float DAT_QRFL_FIRE_OFS_y;
float DAT_QRFL_FIRE_OFS_z;
vector DAT_QRFL_FIRE_OFS;
float DAT_SFGA_FIRE_OFS_x;
float DAT_SFGA_FIRE_OFS_y;
float DAT_SFGA_FIRE_OFS_z;
vector DAT_SFGA_FIRE_OFS;
float DAT_LAS_FIRE_OFS_x;
float DAT_LAS_FIRE_OFS_y;
float DAT_LAS_FIRE_OFS_z;
vector DAT_LAS_FIRE_OFS;
float DAT_ION_FIRE_OFS_x;
float DAT_ION_FIRE_OFS_y;
float DAT_ION_FIRE_OFS_z;
vector DAT_ION_FIRE_OFS;
float DAT_EMP_FIRE_OFS_x;
float DAT_EMP_FIRE_OFS_y;
float DAT_EMP_FIRE_OFS_z;
vector DAT_EMP_FIRE_OFS;
float DAT_ESR_FIRE_OFS_x;
float DAT_ESR_FIRE_OFS_y;
float DAT_ESR_FIRE_OFS_z;
vector DAT_ESR_FIRE_OFS;
float DAT_PAC_FIRE_OFS_x;
float DAT_PAC_FIRE_OFS_y;
float DAT_PAC_FIRE_OFS_z;
vector DAT_PAC_FIRE_OFS;
float DAT_MIS_FIRE_OFS_x;
float DAT_MIS_FIRE_OFS_y;
float DAT_MIS_FIRE_OFS_z;
vector DAT_MIS_FIRE_OFS;
float DAT_MLGD_FIRE_OFS_x;
float DAT_MLGD_FIRE_OFS_y;
float DAT_MLGD_FIRE_OFS_z;
vector DAT_MLGD_FIRE_OFS;
float DAT_MARH_FIRE_OFS_x;
float DAT_MARH_FIRE_OFS_y;
float DAT_MARH_FIRE_OFS_z;
vector DAT_MARH_FIRE_OFS;
float DAT_SWRM_FIRE_OFS_x;
float DAT_SWRM_FIRE_OFS_y;
float DAT_SWRM_FIRE_OFS_z;
vector DAT_SWRM_FIRE_OFS;
float DAT_RPLAS_PROJ_ID;
float DAT_QRFL_PROJ_ID;
float DAT_SFGA_PROJ_ID;
float DAT_ION_PROJ_ID;
float DAT_EMP_PROJ_ID;
float DAT_MIS_PROJ_ID;
float DAT_MLGD_PROJ_ID;
float DAT_MARH_PROJ_ID;
float DAT_SWRM_PROJ_ID;
string MCH_NAME_BLK;
string MCH_NAME_MTK;
string MCH_NAME_MNT;
float ID_MCH_BALAKET;
float SZ_MCH_BALAKET;
float ID_MCH_MATOK;
float SZ_MCH_MATOK;
float ID_MCH_MONITOR;
float SZ_MCH_MONITOR;
float DAT_OTL_LEG_HP;
float DAT_OTL_CTOR_HP;
float DAT_OTL_LTOR_HP;
float DAT_OTL_RTOR_HP;
float DAT_OTL_LARM_HP;
float DAT_OTL_RARM_HP;
float DAT_MTK_CTOR_HP;
float DAT_MTK_LEG_HP;
float DAT_MTK_LTOR_HP;
float DAT_MTK_RTOR_HP;
float DAT_MTK_LARM_HP;
float DAT_MTK_RARM_HP;
float DAT_MNT_CTOR_HP;
float DAT_MNT_LEG_HP;
float DAT_MNT_LTOR_HP;
float DAT_MNT_RTOR_HP;
float DAT_MNT_LARM_HP;
float DAT_MNT_RARM_HP;
float DAT_OTL_LEG_ARMMAX;
float DAT_OTL_CTOR_ARMMAX;
float DAT_OTL_LTOR_ARMMAX;
float DAT_OTL_RTOR_ARMMAX;
float DAT_OTL_LARM_ARMMAX;
float DAT_OTL_RARM_ARMMAX;
float DAT_MTK_CTOR_ARMMAX;
float DAT_MTK_RARM_ARMMAX;
float DAT_MTK_LARM_ARMMAX;
float DAT_MTK_RTOR_ARMMAX;
float DAT_MTK_LTOR_ARMMAX;
float DAT_MTK_LEG_ARMMAX;
float DAT_MNT_CTOR_ARMMAX;
float DAT_MNT_RARM_ARMMAX;
float DAT_MNT_LARM_ARMMAX;
float DAT_MNT_RTOR_ARMMAX;
float DAT_MNT_LTOR_ARMMAX;
float DAT_MNT_LEG_ARMMAX;
float DAT_OTL_SHIELD_MAX;
float DAT_OTL_SHIELD_RATE;
float DAT_MTK_SHIELD_MAX;
float DAT_MTK_SHIELD_RATE;
float DAT_MNT_SHIELD_MAX;
float DAT_MNT_SHIELD_RATE;
float DAT_OTL_ENERGY_MAX;
float DAT_OTL_ENERGY_RATE;
float DAT_MTK_ENERGY_MAX;
float DAT_MTK_ENERGY_RATE;
float DAT_MNT_ENERGY_MAX;
float DAT_MNT_ENERGY_RATE;
float DAT_OTL_M_FSPEED;
float DAT_OTL_M_SSPEED;
float DAT_OTL_M_BSPEED;
float DAT_OTL_M_ACCEL;
float DAT_OTL_M_YAW;
float DAT_MTK_M_FSPEED;
float DAT_MTK_M_SSPEED;
float DAT_MTK_M_BSPEED;
float DAT_MTK_M_ACCEL;
float DAT_MTK_M_YAW;
float DAT_MNT_M_FSPEED;
float DAT_MNT_M_SSPEED;
float DAT_MNT_M_BSPEED;
float DAT_MNT_M_ACCEL;
float DAT_MNT_M_YAW;
float DAT_OTL_RADAR_RANGE;
float DAT_OTL_LOCK;
float DAT_MTK_RADAR_RANGE;
float DAT_MTK_LOCK;
float DAT_MNT_RADAR_RANGE;
float DAT_MNT_LOCK;
float DAT_OTL_CTOR_BBX_N_x;
float DAT_OTL_CTOR_BBX_N_y;
float DAT_OTL_CTOR_BBX_N_z;
vector DAT_OTL_CTOR_BBX_N;
float DAT_OTL_CTOR_BBX_X_x;
float DAT_OTL_CTOR_BBX_X_y;
float DAT_OTL_CTOR_BBX_X_z;
vector DAT_OTL_CTOR_BBX_X;
float DAT_MTK_CTOR_BBX_N_x;
float DAT_MTK_CTOR_BBX_N_y;
float DAT_MTK_CTOR_BBX_N_z;
vector DAT_MTK_CTOR_BBX_N;
float DAT_MTK_CTOR_BBX_X_x;
float DAT_MTK_CTOR_BBX_X_y;
float DAT_MTK_CTOR_BBX_X_z;
vector DAT_MTK_CTOR_BBX_X;
float DAT_MNT_CTOR_BBX_N_x;
float DAT_MNT_CTOR_BBX_N_y;
float DAT_MNT_CTOR_BBX_N_z;
vector DAT_MNT_CTOR_BBX_N;
float DAT_MNT_CTOR_BBX_X_x;
float DAT_MNT_CTOR_BBX_X_y;
float DAT_MNT_CTOR_BBX_X_z;
vector DAT_MNT_CTOR_BBX_X;
string DAT_OTL_CPIT_MODEL;
string DAT_OTL_CTOR_MODEL;
string DAT_OTL_LEG_MODEL;
string DAT_OTL_LTOR_MODEL;
string DAT_OTL_RTOR_MODEL;
string DAT_OTL_LARM_MODEL;
string DAT_OTL_RARM_MODEL;
string DAT_OTL_CAM_MODEL;
string DAT_MTK_CPIT_MODEL;
string DAT_MTK_CTOR_MODEL;
string DAT_MTK_LEG_MODEL;
string DAT_MTK_LTOR_MODEL;
string DAT_MTK_RTOR_MODEL;
string DAT_MTK_LARM_MODEL;
string DAT_MTK_RARM_MODEL;
string DAT_MTK_CAM_MODEL;
string DAT_MNT_CPIT_MODEL;
string DAT_MNT_CTOR_MODEL;
string DAT_MNT_LEG_MODEL;
string DAT_MNT_LTOR_MODEL;
string DAT_MNT_RTOR_MODEL;
string DAT_MNT_LARM_MODEL;
string DAT_MNT_RARM_MODEL;
string DAT_MNT_CAM_MODEL;
float DAT_OTL_LEG_OFFSET_x;
float DAT_OTL_LEG_OFFSET_y;
float DAT_OTL_LEG_OFFSET_z;
vector DAT_OTL_LEG_OFFSET;
float DAT_OTL_LTOR_OFFSET_x;
float DAT_OTL_LTOR_OFFSET_y;
float DAT_OTL_LTOR_OFFSET_z;
vector DAT_OTL_LTOR_OFFSET;
float DAT_OTL_RTOR_OFFSET_x;
float DAT_OTL_RTOR_OFFSET_y;
float DAT_OTL_RTOR_OFFSET_z;
vector DAT_OTL_RTOR_OFFSET;
float DAT_OTL_LARM_OFFSET_x;
float DAT_OTL_LARM_OFFSET_y;
float DAT_OTL_LARM_OFFSET_z;
vector DAT_OTL_LARM_OFFSET;
float DAT_OTL_RARM_OFFSET_x;
float DAT_OTL_RARM_OFFSET_y;
float DAT_OTL_RARM_OFFSET_z;
vector DAT_OTL_RARM_OFFSET;
float DAT_OTL_CAM_OFFSET_x;
float DAT_OTL_CAM_OFFSET_y;
float DAT_OTL_CAM_OFFSET_z;
vector DAT_OTL_CAM_OFFSET;
float DAT_OTL_CAM_OFFSET_ALT_x;
float DAT_OTL_CAM_OFFSET_ALT_y;
float DAT_OTL_CAM_OFFSET_ALT_z;
vector DAT_OTL_CAM_OFFSET_ALT;
float DAT_OTL_WEP1_OFFSET_x;
float DAT_OTL_WEP1_OFFSET_y;
float DAT_OTL_WEP1_OFFSET_z;
vector DAT_OTL_WEP1_OFFSET;
float DAT_OTL_WEP2_OFFSET_x;
float DAT_OTL_WEP2_OFFSET_y;
float DAT_OTL_WEP2_OFFSET_z;
vector DAT_OTL_WEP2_OFFSET;
float DAT_OTL_WEP3_OFFSET_x;
float DAT_OTL_WEP3_OFFSET_y;
float DAT_OTL_WEP3_OFFSET_z;
vector DAT_OTL_WEP3_OFFSET;
float DAT_MTK_LEG_OFFSET_x;
float DAT_MTK_LEG_OFFSET_y;
float DAT_MTK_LEG_OFFSET_z;
vector DAT_MTK_LEG_OFFSET;
float DAT_MTK_LTOR_OFFSET_x;
float DAT_MTK_LTOR_OFFSET_y;
float DAT_MTK_LTOR_OFFSET_z;
vector DAT_MTK_LTOR_OFFSET;
float DAT_MTK_RTOR_OFFSET_x;
float DAT_MTK_RTOR_OFFSET_y;
float DAT_MTK_RTOR_OFFSET_z;
vector DAT_MTK_RTOR_OFFSET;
float DAT_MTK_LARM_OFFSET_x;
float DAT_MTK_LARM_OFFSET_y;
float DAT_MTK_LARM_OFFSET_z;
vector DAT_MTK_LARM_OFFSET;
float DAT_MTK_RARM_OFFSET_x;
float DAT_MTK_RARM_OFFSET_y;
float DAT_MTK_RARM_OFFSET_z;
vector DAT_MTK_RARM_OFFSET;
float DAT_MTK_CAM_OFFSET_x;
float DAT_MTK_CAM_OFFSET_y;
float DAT_MTK_CAM_OFFSET_z;
vector DAT_MTK_CAM_OFFSET;
float DAT_MTK_CAM_OFFSET_ALT_x;
float DAT_MTK_CAM_OFFSET_ALT_y;
float DAT_MTK_CAM_OFFSET_ALT_z;
vector DAT_MTK_CAM_OFFSET_ALT;
float DAT_MTK_WEP1_OFFSET_x;
float DAT_MTK_WEP1_OFFSET_y;
float DAT_MTK_WEP1_OFFSET_z;
vector DAT_MTK_WEP1_OFFSET;
float DAT_MTK_WEP2_OFFSET_x;
float DAT_MTK_WEP2_OFFSET_y;
float DAT_MTK_WEP2_OFFSET_z;
vector DAT_MTK_WEP2_OFFSET;
float DAT_MTK_WEP3_OFFSET_x;
float DAT_MTK_WEP3_OFFSET_y;
float DAT_MTK_WEP3_OFFSET_z;
vector DAT_MTK_WEP3_OFFSET;
float DAT_MTK_WEP4_OFFSET_x;
float DAT_MTK_WEP4_OFFSET_y;
float DAT_MTK_WEP4_OFFSET_z;
vector DAT_MTK_WEP4_OFFSET;
float DAT_MTK_WEP5_OFFSET_x;
float DAT_MTK_WEP5_OFFSET_y;
float DAT_MTK_WEP5_OFFSET_z;
vector DAT_MTK_WEP5_OFFSET;
float DAT_MNT_LEG_OFFSET_x;
float DAT_MNT_LEG_OFFSET_y;
float DAT_MNT_LEG_OFFSET_z;
vector DAT_MNT_LEG_OFFSET;
float DAT_MNT_LTOR_OFFSET_x;
float DAT_MNT_LTOR_OFFSET_y;
float DAT_MNT_LTOR_OFFSET_z;
vector DAT_MNT_LTOR_OFFSET;
float DAT_MNT_RTOR_OFFSET_x;
float DAT_MNT_RTOR_OFFSET_y;
float DAT_MNT_RTOR_OFFSET_z;
vector DAT_MNT_RTOR_OFFSET;
float DAT_MNT_LARM_OFFSET_x;
float DAT_MNT_LARM_OFFSET_y;
float DAT_MNT_LARM_OFFSET_z;
vector DAT_MNT_LARM_OFFSET;
float DAT_MNT_RARM_OFFSET_x;
float DAT_MNT_RARM_OFFSET_y;
float DAT_MNT_RARM_OFFSET_z;
vector DAT_MNT_RARM_OFFSET;
float DAT_MNT_CAM_OFFSET_x;
float DAT_MNT_CAM_OFFSET_y;
float DAT_MNT_CAM_OFFSET_z;
vector DAT_MNT_CAM_OFFSET;
float DAT_MNT_CAM_OFFSET_ALT_x;
float DAT_MNT_CAM_OFFSET_ALT_y;
float DAT_MNT_CAM_OFFSET_ALT_z;
vector DAT_MNT_CAM_OFFSET_ALT;
float DAT_MNT_WEP1_OFFSET_x;
float DAT_MNT_WEP1_OFFSET_y;
float DAT_MNT_WEP1_OFFSET_z;
vector DAT_MNT_WEP1_OFFSET;
float DAT_MNT_WEP2_OFFSET_x;
float DAT_MNT_WEP2_OFFSET_y;
float DAT_MNT_WEP2_OFFSET_z;
vector DAT_MNT_WEP2_OFFSET;
float DAT_MNT_WEP3_OFFSET_x;
float DAT_MNT_WEP3_OFFSET_y;
float DAT_MNT_WEP3_OFFSET_z;
vector DAT_MNT_WEP3_OFFSET;
float DAT_MNT_WEP4_OFFSET_x;
float DAT_MNT_WEP4_OFFSET_y;
float DAT_MNT_WEP4_OFFSET_z;
vector DAT_MNT_WEP4_OFFSET;
float DAT_MNT_WEP5_OFFSET_x;
float DAT_MNT_WEP5_OFFSET_y;
float DAT_MNT_WEP5_OFFSET_z;
vector DAT_MNT_WEP5_OFFSET;
float DAT_MNT_WEP6_OFFSET_x;
float DAT_MNT_WEP6_OFFSET_y;
float DAT_MNT_WEP6_OFFSET_z;
vector DAT_MNT_WEP6_OFFSET;
float DAT_MNT_WEP7_OFFSET_x;
float DAT_MNT_WEP7_OFFSET_y;
float DAT_MNT_WEP7_OFFSET_z;
vector DAT_MNT_WEP7_OFFSET;
float DAT_MNT_WEP8_OFFSET_x;
float DAT_MNT_WEP8_OFFSET_y;
float DAT_MNT_WEP8_OFFSET_z;
vector DAT_MNT_WEP8_OFFSET;
float DAT_MNT_WEP9_OFFSET_x;
float DAT_MNT_WEP9_OFFSET_y;
float DAT_MNT_WEP9_OFFSET_z;
vector DAT_MNT_WEP9_OFFSET;
float DAT_BLK_HARDPOINT_CNT;
float DAT_MTK_HARDPOINT_CNT;
float DAT_MNT_HARDPOINT_CNT;
float DAT_BLK_HARDPOINT1_SIZE;
float DAT_BLK_HARDPOINT2_SIZE;
float DAT_BLK_HARDPOINT3_SIZE;
float DAT_MTK_HARDPOINT1_SIZE;
float DAT_MTK_HARDPOINT2_SIZE;
float DAT_MTK_HARDPOINT3_SIZE;
float DAT_MTK_HARDPOINT4_SIZE;
float DAT_MTK_HARDPOINT5_SIZE;
float DAT_MNT_HARDPOINT1_SIZE;
float DAT_MNT_HARDPOINT2_SIZE;
float DAT_MNT_HARDPOINT3_SIZE;
float DAT_MNT_HARDPOINT4_SIZE;
float DAT_MNT_HARDPOINT5_SIZE;
float DAT_MNT_HARDPOINT6_SIZE;
float DAT_MNT_HARDPOINT7_SIZE;
float DAT_MNT_HARDPOINT8_SIZE;
float DAT_MNT_HARDPOINT9_SIZE;
float DAT_BLK_HARDPOINT1_TYPES;
float DAT_BLK_HARDPOINT2_TYPES;
float DAT_BLK_HARDPOINT3_TYPES;
float DAT_MTK_HARDPOINT1_TYPES;
float DAT_MTK_HARDPOINT2_TYPES;
float DAT_MTK_HARDPOINT3_TYPES;
float DAT_MTK_HARDPOINT4_TYPES;
float DAT_MTK_HARDPOINT5_TYPES;
float DAT_MNT_HARDPOINT1_TYPES;
float DAT_MNT_HARDPOINT2_TYPES;
float DAT_MNT_HARDPOINT3_TYPES;
float DAT_MNT_HARDPOINT4_TYPES;
float DAT_MNT_HARDPOINT5_TYPES;
float DAT_MNT_HARDPOINT6_TYPES;
float DAT_MNT_HARDPOINT7_TYPES;
float DAT_MNT_HARDPOINT8_TYPES;
float DAT_MNT_HARDPOINT9_TYPES;
float DAT_OTL_TECH_LEVEL;
float DAT_MTK_TECH_LEVEL;
float DAT_MNT_TECH_LEVEL;
float ID_VEC_HS_TRUCK_C;
float ID_VEC_HS_TRUCK_H;
float ID_VEC_HS_TRUCK_CS;
float ID_VEC_HS_DOZER;
float ID_VEC_HS_LOADR;
float ID_VEC_HS_EXCAT;
float ID_VEC_HS_TANK_L;
float ID_VEC_HS_TANK_H;
float ID_VEC_HS_TDEST_L;
float ID_VEC_HS_TDEST_H;
float ID_VEC_HS_SCOUT;
float ID_VEC_PSC_VTOL_L;
float DAT_HS_TRUCK_HP;
float DAT_H_TANKL_HP;
float DAT_H_TD_HP_CTOR;
float DAT_HS_GEVL_HP;
float DAT_PSC_VTOLL_HP;
string DAT_HS_TRUCKA_NAME;
string DAT_HS_TRUCKB_NAME;
string DAT_HS_TRUCKC_NAME;
string DAT_HS_TANKL_NAME;
string DAT_H_TD_VEC_NAME;
string DAT_HS_GEVL_NAME;
string DAT_PSC_VTOLL_NAME;
float DAT_TNK_CTOR_ARMOR;
float DAT_TNK_LEG_ARMOR;
float DAT_HS_TANKL_SHIELD_MAX;
float DAT_HS_TANKL_SHIELD_RATE;
float DAT_H_TD_SHIELD_MAX;
float DAT_H_TD_SHIELD_RATE;
float DAT_HS_GEVL_SHIELD_RATE;
float DAT_HS_GEVL_SHIELD_MAX;
float DAT_PSC_VTOLL_SHIELD_MAX;
float DAT_PSC_VTOLL_SHIELD_RATE;
float DAT_HS_TANKL_ENERGY_MAX;
float DAT_HS_TANKL_ENERGY_RATE;
float DAT_H_TD_ENERGY_MAX;
float DAT_H_TD_ENERGY_RATE;
float DAT_HS_GEVL_ENERGY_MAX;
float DAT_HS_GEVL_ENERGY_RATE;
float DAT_PSC_VTOLL_ENERGY_MAX;
float DAT_PSC_VTOLL_ENERGY_RATE;
float DAT_HS_TRUCK_FSPEED;
float DAT_HS_TRUCK_SSPEED;
float DAT_HS_TRUCK_BSPEED;
float DAT_HS_TANKL_FSPEED;
float DAT_HS_TANKL_SSPEED;
float DAT_HS_TANKL_BSPEED;
float DAT_H_TD_FSPEED;
float DAT_H_TD_SSPEED;
float DAT_H_TD_BSPEED;
float DAT_HS_GEVL_FSPEED;
float DAT_HS_GEVL_SSPEED;
float DAT_HS_GEVL_BSPEED;
float DAT_PSC_VTOLL_FSPEED;
float DAT_PSC_VTOLL_SSPEED;
float DAT_PSC_VTOLL_BSPEED;
float DAT_HS_TANKL_CTOR_BBX_N_x;
float DAT_HS_TANKL_CTOR_BBX_N_y;
float DAT_HS_TANKL_CTOR_BBX_N_z;
vector DAT_HS_TANKL_CTOR_BBX_N;
float DAT_HS_TANKL_CTOR_BBX_X_x;
float DAT_HS_TANKL_CTOR_BBX_X_y;
float DAT_HS_TANKL_CTOR_BBX_X_z;
vector DAT_HS_TANKL_CTOR_BBX_X;
float DAT_H_TD_CTOR_BBX_N_x;
float DAT_H_TD_CTOR_BBX_N_y;
float DAT_H_TD_CTOR_BBX_N_z;
vector DAT_H_TD_CTOR_BBX_N;
float DAT_H_TD_CTOR_BBX_X_x;
float DAT_H_TD_CTOR_BBX_X_y;
float DAT_H_TD_CTOR_BBX_X_z;
vector DAT_H_TD_CTOR_BBX_X;
float DAT_HS_GEVL_BBX_N_x;
float DAT_HS_GEVL_BBX_N_y;
float DAT_HS_GEVL_BBX_N_z;
vector DAT_HS_GEVL_BBX_N;
float DAT_HS_GEVL_BBX_X_x;
float DAT_HS_GEVL_BBX_X_y;
float DAT_HS_GEVL_BBX_X_z;
vector DAT_HS_GEVL_BBX_X;
float DAT_PSC_VTOLL_BBX_N_x;
float DAT_PSC_VTOLL_BBX_N_y;
float DAT_PSC_VTOLL_BBX_N_z;
vector DAT_PSC_VTOLL_BBX_N;
float DAT_PSC_VTOLL_BBX_X_x;
float DAT_PSC_VTOLL_BBX_X_y;
float DAT_PSC_VTOLL_BBX_X_z;
vector DAT_PSC_VTOLL_BBX_X;
float DAT_HS_TANKL_RADAR_RANGE;
float DAT_H_TD_RADAR_RANGE;
float DAT_HS_GEVL_RADAR_RANGE;
float DAT_PSC_VTOLL_RADAR_RANGE;
float DAT_HS_TRUCK_YAW_SPEED;
float DAT_HS_TANKL_YAW_SPEED;
float DAT_HS_TANKDEST_YAW_SPEED;
float DAT_HS_GEVL_YAW_SPEED;
float DAT_PSC_VTOLL_YAW_SPEED;
string DAT_HS_TANKL_CTOR_MODEL;
string DAT_HS_TANKL_MDL_CHASSIS;
string DAT_HS_TANKL_CAM_MODEL;
string DAT_H_TD_CTOR_MODEL;
string DAT_H_TD_CAM_MODEL;
string DAT_HS_GEVL_MDL;
string DAT_HS_GEVL_MDL_CAM;
string DAT_PSC_VTOLL_MODEL;
float DAT_HS_TANKL_LEG_OFFSET_x;
float DAT_HS_TANKL_LEG_OFFSET_y;
float DAT_HS_TANKL_LEG_OFFSET_z;
vector DAT_HS_TANKL_LEG_OFFSET;
float DAT_HS_TANKL_WEP1_OFFSET_x;
float DAT_HS_TANKL_WEP1_OFFSET_y;
float DAT_HS_TANKL_WEP1_OFFSET_z;
vector DAT_HS_TANKL_WEP1_OFFSET;
float DAT_HS_TANKL_WEP2_OFFSET_x;
float DAT_HS_TANKL_WEP2_OFFSET_y;
float DAT_HS_TANKL_WEP2_OFFSET_z;
vector DAT_HS_TANKL_WEP2_OFFSET;
float DAT_H_TD_WEP1_OFFSET_x;
float DAT_H_TD_WEP1_OFFSET_y;
float DAT_H_TD_WEP1_OFFSET_z;
vector DAT_H_TD_WEP1_OFFSET;
float DAT_HS_GEVL_WEP1_OFFSET_x;
float DAT_HS_GEVL_WEP1_OFFSET_y;
float DAT_HS_GEVL_WEP1_OFFSET_z;
vector DAT_HS_GEVL_WEP1_OFFSET;
float DAT_PSC_VTOLL_WEP1_OFFSET_x;
float DAT_PSC_VTOLL_WEP1_OFFSET_y;
float DAT_PSC_VTOLL_WEP1_OFFSET_z;
vector DAT_PSC_VTOLL_WEP1_OFFSET;
float DAT_PSC_VTOLL_WEP2_OFFSET_x;
float DAT_PSC_VTOLL_WEP2_OFFSET_y;
float DAT_PSC_VTOLL_WEP2_OFFSET_z;
vector DAT_PSC_VTOLL_WEP2_OFFSET;
float DAT_HS_TANKL_TECH_LEVEL;
float DAT_H_TD_TECH_LEVEL;
float ID_BLD_H_RADAR;
float ID_BLD_H_SHIELD;
float ID_BLD_H_POWER;
float ID_BLD_H_HANGAR_L;
float ID_BLD_H_FUEL;
float ID_BLD_H_TURRET;
float ID_BLD_H_REPAIR;
float DAT_BLD_H_FUELTANK_HP;
float DAT_BLD_H_LG_HANGAR_HP;
float DAT_BLD_H_SM_RADAR_HP;
float DAT_BLD_H_POWER_PLANT_HP;
float DAT_BLD_H_SHIELDGEN_HP;
float DAT_TUR_CTOR_HP;
float DAT_TUR_LEG_HP;
float DAT_BLD_H_REPAIR_HP;
float DAT_BLD_H_FUELTANK_AM;
float DAT_BLD_H_LG_HANGAR_AM;
float DAT_TUR_CTOR_ARMOR;
float DAT_TUR_LEG_ARMOR;
float DAT_BLD_H_FUELTANK_SH_MAX;
float DAT_BLD_H_FUELTANK_SH_RATE;
float DAT_BLD_H_LG_HANGAR_SH_MAX;
float DAT_BLD_H_LG_HANGAR_SH_RATE;
float DAT_BLD_H_SM_RADAR_SH_MAX;
float DAT_BLD_H_SM_RADAR_SH_RATE;
float DAT_BLD_H_POWER_PLANT_SH_MAX;
float DAT_BLD_H_POWER_PLANT_SH_RATE;
float DAT_BLD_H_SHIELDGEN_SH_MAX;
float DAT_BLD_H_SHIELDGEN_SH_RATE;
float DAT_BLD_H_SHIELD_RADIUS;
float DAT_BLD_H_REPAIR_SH_MAX;
float DAT_BLD_H_REPAIR_SH_RATE;
float DAT_TUR_SHIELD_MAX;
float DAT_TUR_SHIELD_RATE;
float DAT_BLD_H_POWER_PLANT_EN_MAX;
float DAT_BLD_H_POWER_PLANT_EN_RATE;
float DAT_BLD_H_POWER_PLANT_EN_RADIUS;
float DAT_BLD_H_REPAIR_EN_MAX;
float DAT_BLD_H_REPAIR_RL_MAX;
float DAT_BLD_H_REPAIR_RL_RATE;
float DAT_BLD_H_REPAIR_RL_RATIO;
float DAT_TUR_ENERGY_MAX;
float DAT_TUR_ENERGY_RATE;
float DAT_BLD_H_SM_RADAR_RADAR_RANGE;
float DAT_TUR_RADAR_RANGE;
string DAT_BLD_H_FUELTANK_MODEL;
string DAT_BLD_H_LG_HANGAR_MODEL;
string DAT_BLD_H_REPAIR_MODEL;
string DAT_BLD_H_SM_RADAR_MODEL;
string DAT_BLD_H_POWER_PLANT_MODEL;
string DAT_BLD_H_SHIELDGEN_MODEL;
string DAT_TUR_CTOR_MODEL;
string DAT_TUR_LEG_MODEL;
string DAT_TUR_CAM_MODEL;
float ID_TUR_HLITE;
float ID_TUR_HMED;
float ID_TUR_HHEV;
float ID_TUR_SLITE;
float DAT_TUR_HLITE_HP;
float DAT_TUR_HLITE_SH_MAX;
float DAT_TUR_HLITE_SH_RATE;
float DAT_TUR_HLITE_EN_MAX;
float DAT_TUR_HLITE_EN_RATE;
float DAT_TUR_HLITE_BBN_x;
float DAT_TUR_HLITE_BBN_y;
float DAT_TUR_HLITE_BBN_z;
vector DAT_TUR_HLITE_BBN;
float DAT_TUR_HLITE_BBX_x;
float DAT_TUR_HLITE_BBX_y;
float DAT_TUR_HLITE_BBX_z;
vector DAT_TUR_HLITE_BBX;
float DAT_TUR_HLITE_YAWS;
float DAT_TUR_HLITE_PITCH_x;
float DAT_TUR_HLITE_PITCH_y;
float DAT_TUR_HLITE_PITCH_z;
vector DAT_TUR_HLITE_PITCH;
float DAT_TUR_HLITE_RADRANGE;
float DAT_TUR_HLITE_LOCK;
float DAT_TUR_HLITE_SPREAD_x;
float DAT_TUR_HLITE_SPREAD_y;
float DAT_TUR_HLITE_SPREAD_z;
vector DAT_TUR_HLITE_SPREAD;
string DAT_TUR_HLITE_TUR;
string DAT_TUR_HLITE_BASE;
string DAT_TUR_HLITE_CAM;
float DAT_TUR_HLITE_WEP1_OFFSET_x;
float DAT_TUR_HLITE_WEP1_OFFSET_y;
float DAT_TUR_HLITE_WEP1_OFFSET_z;
vector DAT_TUR_HLITE_WEP1_OFFSET;
float DAT_TUR_HLITE_WEP1_OFFSET_ALT_x;
float DAT_TUR_HLITE_WEP1_OFFSET_ALT_y;
float DAT_TUR_HLITE_WEP1_OFFSET_ALT_z;
vector DAT_TUR_HLITE_WEP1_OFFSET_ALT;
float DAT_TUR_HLITE_WEP1_ADJ_ANG_x;
float DAT_TUR_HLITE_WEP1_ADJ_ANG_y;
float DAT_TUR_HLITE_WEP1_ADJ_ANG_z;
vector DAT_TUR_HLITE_WEP1_ADJ_ANG;
float DAT_TUR_HLITE_WEP2_OFFSET_x;
float DAT_TUR_HLITE_WEP2_OFFSET_y;
float DAT_TUR_HLITE_WEP2_OFFSET_z;
vector DAT_TUR_HLITE_WEP2_OFFSET;
float DAT_TUR_HLITE_WEP2_OFFSET_ALT_x;
float DAT_TUR_HLITE_WEP2_OFFSET_ALT_y;
float DAT_TUR_HLITE_WEP2_OFFSET_ALT_z;
vector DAT_TUR_HLITE_WEP2_OFFSET_ALT;
float DAT_TUR_HLITE_WEP2_ADJ_ANG_x;
float DAT_TUR_HLITE_WEP2_ADJ_ANG_y;
float DAT_TUR_HLITE_WEP2_ADJ_ANG_z;
vector DAT_TUR_HLITE_WEP2_ADJ_ANG;
float DAT_TUR_HLITE_CAM_CNAME;
float DAT_TUR_HLITE_CAM_OFFSET_x;
float DAT_TUR_HLITE_CAM_OFFSET_y;
float DAT_TUR_HLITE_CAM_OFFSET_z;
vector DAT_TUR_HLITE_CAM_OFFSET;
float DAT_TUR_HLITE_CAM_OFFSET_ALT_x;
float DAT_TUR_HLITE_CAM_OFFSET_ALT_y;
float DAT_TUR_HLITE_CAM_OFFSET_ALT_z;
vector DAT_TUR_HLITE_CAM_OFFSET_ALT;
float DAT_TUR_HLITE_LEG_OFFSET_x;
float DAT_TUR_HLITE_LEG_OFFSET_y;
float DAT_TUR_HLITE_LEG_OFFSET_z;
vector DAT_TUR_HLITE_LEG_OFFSET;
string DAT_TUR_HLITE_NAME;
float TE_CLIENT_INFO;
float TE_CLIENT_PING;
float TE_CLIENT_HIT;
float TE_CLIENT_DMG;
float TE_UI_BOX;
float TE_ESR_BEAM;
float TE_PAC_BEAM;
float TE_SMOKE_TEST;
float TE_SHIELD_TEST;
float TE_HUD_SPARK;
float TE_EVT_OBJ;
float TE_EVT_NAV;
float TE_EVT_DEP;
float TE_OBJECTIVE_COMPLETE;
float TE_OBJECTIVE_FAILED;
float TE_MISSION_WIN;
float TE_MISSION_LOSE;
float TE_NAV_REACH;
float TE_MSN_BOUND;
float TE_HEAT_SMALL;
float TE_MIS_TRAIL;
float TE_MIS_FLAME;
float TE_MIS_MUZZLE;
float TE_MIS_EXPL;
float TE_LASER_BEAM;
float TE_LAS_MUZZLE;
float TE_LAS_HIT;
float TE_RPC_MUZZLE;
float TE_RPC_TRAIL;
float TE_RPC_HIT;
float TE_RPC_BURN;
float AI_WALK_SPD;
float AI_RUN_SPD;
float AI_RANK_ACE;
float AI_RANK_VET;
float AI_RANK_REG;
float AI_RANK_ROK;
float AI_HUNT_NOV;
float AI_HUNT_REG;
float AI_HUNT_VET;
float AI_HUNT_ELT;
float AI_DMG_SKILL_ROK;
float AI_DMG_SKILL_REG;
float AI_DMG_SKILL_VET;
float AI_DMG_SKILL_ACE;
float AI_DMG_ROK;
float AI_DMG_REG;
float AI_DMG_VET;
float AI_DMG_ACE;
float AI_ATTACK_ROK;
float AI_ATTACK_REG;
float AI_ATTACK_VET;
float AI_ATTACK_ACE;
float AI_WEAPON_RPS_MOD;
float AI_PATROL_DIST;
float AI_DEFEND_DIST_MIN;
float AI_DEFEND_DIST;
float AI_ASSAULT_DIST_MIN;
float AI_ASSAULT_DIST;
float AI_CNV_ACE;
float AI_CNV_VET;
float AI_CNV_REG;
float AI_CNV_ROK;
float AI_RNG_ACE;
float AI_RNG_VET;
float AI_RNG_REG;
float AI_RNG_ROK;
float AI_ROT_ACE;
float AI_ROT_VET;
float AI_ROT_REG;
float AI_ROT_ROK;
float AI_ARMOR_EASY;
float AI_ARMOR_MEDM;
float AI_ARMOR_HARD;
float AI_ARMOR_NIGHT;
float AI_SHIELD_EASY;
float AI_SHIELD_MEDM;
float AI_SHIELD_HARD;
float AI_SHIELD_NIGHT;
float AI_LEAD_ACE;
float AI_LEAD_VET;
float AI_LEAD_REG;
float AI_LEAD_ROK;
float AI_PTNCE_ACE;
float AI_PTNCE_VET;
float AI_PTNCE_REG;
float AI_PTNCE_ROK;
float AI_RANGE_S;
float AI_RANGE_M;
float AI_RANGE_L;
float AI_VIEW_ROK;
float AI_VIEW_REG;
float AI_VIEW_VET;
float AI_VIEW_ACE;
float AI_FOV_ROK;
float AI_FOV_REG;
float AI_FOV_VET;
float AI_FOV_ACE;
float AI_REFLEX_ACE;
float AI_REFLEX_VET;
float AI_REFLEX_REG;
float AI_REFLEX_ROK;
float CLIENTS;
float WINDDIR_x;
float WINDDIR_y;
float WINDDIR_z;
vector WINDDIR;
float WINDSPEED;
.float client_num;
.string msn_file;
.string map_file;
void () mh_world_ini;
void (float) data_iniWep;
void (float) data_iniMech;
void (float) data_iniVehc;
void (float) data_iniProjectile;
void (float) data_iniTurret;
float MSG_ENTITY;
.float (entity, float) SendEntity;
.float SendFlags;
void () DecodeLevelParms;
void () respawn;
entity () SelectSpawnPoint;
float (entity) csqc_updateCompStat;
void () legacy_PlayerDie;
void () spawnpoint_select;
void () spawnpoint_Random;
entity () spawnpoint_coop;
entity () spawnpoint_single;
void () client_push_player_info;
void (entity) server_push_player_info;
void (entity) client_push_radar_ping;
void (entity) client_push_hud_highlight;
void (entity) client_send_boundary_warning;
void () client_push_mapobjects;
void (entity) client_send_navpoint;
void (entity) client_send_objective;
void (entity) client_send_deploypoint;
void (float, float) client_playTrack;
void (string, float) client_ParseMechCommand;
void (string, float) client_setWeapon;
void (string, float) client_setWeaponGroup;
void () client_sendMissionFileName;
void (string) client_sendAnimaticFileName;
void (string, float) client_setNavPoint;
void () client_updateWeaponReloads;
void (string) client_sendAvailableLightMechs;
void (string) client_sendAvailableMediumMechs;
void (string) client_sendAvailableHeavyMechs;
void (string) client_sendAvailableItems;
void (float) client_sendGameMode;
void (entity, float, vector, float, vector, float) client_sendFog;
void (entity, float, float) client_sendMusic;
void (float, float, float, string, string) client_update_moveSpeed;
void (string, string, string) client_update_viewBob;
void (string, string, string) client_update_modelBob;
void (string, string) client_update_viewPitch;
entity () FindIntermission;
void () GotoNextMap;
void () ExitIntermission;
void () IntermissionThink;
void () execute_changelevel;
void () changelevel_touch;
void () changelevel_use;
void () server_getTarget;
void () server_updateTargetInfo;
void () server_make_sweep;
string SAVE_FILE_NAME;
string SAVE_MAP;
string SAVE_MECHS_LIGHT;
string SAVE_MECHS_MEDIM;
string SAVE_MECHS_HEAVY;
string SAVE_ITEMS_ALL;
float SAVE_MISSN_POINTS;
string SAVE_FILE_EXT;
string SAVE_FILE_MSN_NAME;
string SAVE_FILE_MECHS_LIGHT;
string SAVE_FILE_MECHS_MEDIUM;
string SAVE_FILE_MECHS_HEAVY;
string SAVE_FILE_ITEMS;
string SAVE_FILES_POINTS;
void () savefile_load;
void () savefile_save;
void () savefile_default;
void () savefile_append;
string (string, string) savefile_insert;
void (string) savefile_changemap;
void () mapfile_coop_load;
void (float) mapfile_pvp_load;
void (string, float) cons_logAFloat;
void (string, vector) cons_logAVector;
void (string, string) cons_logAString;
void (string, float, string, float) cons_log2Float;
void (string, vector, string, vector) cons_log2Vectors;
void (string, string, string, string) cons_log2Strings;
vector (vector, vector, vector) util_findOpenSpawnArea;
float (entity) util_getMechHpAverage;
float (entity) util_getMechHpTotal;
float (float, float, float) util_checkAngNotIdeal;
void (entity, entity, vector) util_setOffsetOrigin;
void (string, float, float) util_setModel;
void (float, float, float) util_setCollider;
void (float, float, float, float) util_setHealthArmor;
float (vector, vector, vector) util_checkInBounds;
float (entity) util_checkPointAngle;
float (vector) util_checkPointAngleImpl;
float (vector) util_lockOnChoke;
void (entity, vector) util_chekPointToHitDir;
void (float, float, float, float) util_subThreeBits;
entity (float, entity) util_getPartFromName;
float (float) util_roll_dice;
vector (entity, float) util_traceForPlayer;
vector (vector, vector, float, entity) util_traceForAI;
vector (vector, float, vector, float) util_applySpreadToTrace;
vector (vector, vector, vector) util_getOffsetOfVector;
float (float) anglemod;
float (entity, float) util_cornerSlopeCheck;
void (entity) util_generateBuildingFoundation;
vector (vector, vector, float) util_dropToGround;
void () PlayerDie;
void () PlayerDead;
void () PlayerDeathThink;
void () PlayerJump;
void () player_makeObserver;
void () player_unmakeObserver;
void () player_makeVec;
void () player_makeMech;
void () player_unmakeMech;
entity (function) build_unit_camera;
void (function, entity) build_unit_component;
entity (function, float, entity, float, float, float, FIELD TYPE) build_unit_weapon;
void () build_unit_weapon_list;
void (function) build_mech_unit;
void (function) build_mech_bot;
entity (function) build_mech_legs;
void (function) build_mech_torsoCenter;
entity (function) build_mech_torsoRight;
entity (function) build_mech_torsoLeft;
entity (function) build_mech_armRight;
entity (function) build_mech_armLeft;
entity (function) build_unit_turret;
void (function) build_vehicle_unit;
void (function) build_vtol_unit;
void (function) build_turret_unit;
void (function) build_turret_top;
void () ctrl_updateCenterTorso;
void () ctrl_updateLegs;
void () ctrl_dieLegs;
void () ctrl_die_weapon;
void () ctrl_die_comp;
void () touch_mech;
void () touch_mechPiece;
void () ctrl_updateTurret;
void () building_think;
void () building_die;
void (entity) ctrl_wpn_think;
void () ctrl_wpn_think_clip;
void () ctrl_wpn_think_ene;
void (entity, float) ctrl_weapon_addState;
void (entity, float) ctrl_weapon_subState;
void (entity, float, float) ctrl_weapon_clearState;
void (entity, float) ctrl_weapon_isReload;
void (entity, float) ctrl_weapon_isReady;
void () leg_stand1;
void () leg_die1;
void () leg_die2;
void () leg_die3;
void () leg_die4;
void () leg_walk1;
void () leg_walk2;
void () leg_walk3;
void () leg_walk4;
void () leg_walk5;
void () leg_walk6;
void () leg_walk7;
void () ctor_stand;
void () ctor_die1;
void () ctor_die2;
void () ctor_die3;
void () cycleWeaponGroup;
void () cycleWeaponGroupReverse;
void () playerAttack;
void () ImpulseCommands;
void () ButtonCommands;
entity (vector, float, entity) t_find_part;
entity (entity, entity, entity, float, float, vector, vector) t_damage;
float (entity, entity, float) t_damage_bal;
float (entity, entity, float) t_damage_ene;
float (entity, entity, float) t_damage_mis;
void (entity, entity, float) killed;
float (entity, float, float, float) damage_armor;
entity (entity, vector, float) closestWeapon;
void () mech_clearWeaponGroups;
void () ctrl_update_mechplayer;
void () mech_player_die;
void () mech_player_cameradie;
void (entity) mech_player_compdie;
void () mech_cleanupMech;
void () mech_player_removecamera;
void (entity) mech_player_removecomp;
float AI_SPAWNFLAG_CAMPAIGN;
float AI_SPAWNFLAG_COOP;
float AI_SPAWNFLAG_DM;
float AI_SPAWNFLAG_TDM;
float AI_SPAWNFLAG_COLDSTART;
float AI_SPAWNFLAG_RANDDOMSTART;
float AI_SPAWNFLAG_HASRADAR;
float AI_SPAWNFLAG_PROMOTE;
float AI_SPAWNFLAG_DEMOTE;
float AI_SPAWNFLAG_NONOV;
float AI_SPAWNFLAG_NOREG;
float AI_SPAWNFLAG_NOVET;
float AI_SPAWNFLAG_NOELT;
float AI_SPAWNFLAG_NODROP;
float AI_SPAWNFLAG_TRIGGERME;
float ST_STAND;
float ST_WALK;
float ST_FLYDIR;
float ST_RUN;
float ST_RUN_STRAFE;
float ST_RUN_CHARGE;
float ST_MISSILE;
float ST_MELEE;
float ST_MISSILE_STRAFE;
float ST_HUNT;
float ST_RADAR;
float ST_HUNT_START;
float ST_PAIN;
float TR_NORM;
float TR_TARG;
float TR_GOAL;
float TR_YAW;
float VIS_FAIL;
float VIS_FRAC;
float VIS_TRG;
float VIS_FRN;
float enemy_infront;
float enemy_range;
float enemy_yaw;
float enemy_vis;
entity AI_NODES;
.void () th_fly;
.void () th_run_strafe;
.void () th_run_charge;
.void () th_missile_strafe;
.void () th_hunt;
.float ai_rank;
.float ai_action_time;
.float ai_action_mod;
.float ai_leading;
.float ai_minrange;
.float ai_fov;
.float ai_view;
.float patience;
.float maxpatience;
.float ai_pitch_x;
.float ai_pitch_y;
.float ai_pitch_z;
.vector ai_pitch;
.float ai_viewtime;
.float ai_viewcheck;
.entity ai_hunt_node;
.float ai_hunt_total;
.float ai_attack_chance;
.float ai_dir;
float (float) ai_pilot_optical_range;
float (float) ai_pilot_view_interval;
float (float) ai_pilot_view_range;
float () ai_pilot_rating_leading;
float () ai_pilot_yaw_mod;
float () ai_pilot_armor_mod;
float () ai_pilot_shield_mod;
float () ai_pilot_rating_patience;
void () ai_pilot_mech_armor;
void () ai_pilot_vec_armor;
float (float) ai_pilot_action_mod;
float (float) ai_pilot_attack_interval;
float (float, float) ai_pilot_mod_damage;
vector (float, vector) ai_pilot_accuracy;
void () ai_unit_ini_var;
void (float) ai_pilot_ini_stats;
void () node_touch;
void () node_setup;
void () ai_node_t_defend;
void () ai_node_t_attack;
entity (vector, string, float, float, function) ai_node_hunt;
float (function) ai_hunt_dropnode;
float () ai_can_spawn;
float () ai_find_target_visual;
float () ai_find_target_radar;
entity (float) ai_find_friend;
vector (entity) ai_attack_trace;
void () ai_ranged_attack;
float (entity) ai_attack_blockcheck;
float (entity) ai_valid_target;
void () ai_wep_calcranges;
void (float, float, float) ai_wep_group_track;
float (float, float, float) ai_move_time;
float (float, float, float, float) ai_randyaw_time;
float (entity) ai_attack_checkEne;
void (entity, entity, float) ai_give_target;
float () ai_panic_time;
float (float) ai_wait_for_shot;
float (function) ai_unit_setup;
void () ai_unit_make_multi;
void () ai_unit_make_trigger;
void () ai_walk_setup;
void () ai_hunt_target;
void (float, float) ai_sfx_spotted;
void () ai_found_target;
void (string) ai_node_pick_rand;
void (entity, entity) ai_damage_react;
void (function) ai_leg_frame;
void (float) ai_next_state;
void (float) ai_state_control;
void () ai_pilot_validate_states;
void (float) ai_initialize_system;
void () ai_turret_control;
void (float) ai_turret_set_state;
void () ai_generic_stand;
void () ai_generic_walk;
void () ai_generic_fly;
void () ai_generic_run;
void () ai_generic_run_strafe;
void () ai_generic_run_charge;
void () ai_generic_missile;
void () ai_generic_melee;
void () ai_generic_missile_strafe;
void () ai_generic_hunt;
void () ai_generic_pain;
float (float) ai_check_scan;
void (float) ai_walkgoal;
void () ai_face_targ;
float (entity, float) ai_check_face;
float (entity) ai_check_range;
float (entity) ai_check_vis;
float () ai_attack;
void () ai_move_turn;
float (float, float) ai_move;
float (float) ai_walk_back;
float (float) ai_walk_left;
float (float) ai_walk_right;
float (float) ai_yaw_back;
float (float) ai_yaw_left;
float (float) ai_yaw_right;
float (float, float) ai_yaw_move;
void (float, float) ai_fly_update;
void (float) ai_update_accuracy;
void (float) q1_ai_forward;
void (float) q1_ai_back;
void () q1_ai_stand;
void (float) q1_ai_walk;
void () q1_ai_turn;
void (float) q1_ai_run;
void () q1_ai_run_slide;
void () q1_ai_run_attack;
void () s_explode1;
void () s_explode2;
void() s_explode1 = asm
{
	STATE		TRUE,	s_explode2;
	DONE;
}

void () s_explode3;
void() s_explode2 = asm
{
	STATE		FL_SWIM,	s_explode3;
	DONE;
}

void () s_explode4;
void() s_explode3 = asm
{
	STATE		MOVETYPE_WALK,	s_explode4;
	DONE;
}

void () s_explode5;
void() s_explode4 = asm
{
	STATE		MOVETYPE_STEP,	s_explode5;
	DONE;
}

void () s_explode6;
void() s_explode5 = asm
{
	STATE		MOVETYPE_FLY,	s_explode6;
	DONE;
}

void() s_explode6 = asm
{
	STATE		MOVETYPE_TOSS,	SUB_Remove;
	DONE;
}

void () BecomeExplosion;
vector (float) VelocityForDamage;
.float controllingFaction;
.float isActive;
.float nav_name;
void () ai_mech;
void () ai_spawner_use;
void () ai_spawner_think;
void () ai_spawner_activate;
.float traileffectnum;
void (vector, vector) te_beam_esr;
void (vector, vector) te_beam_pac;
void (vector, vector, float) te_smoke_test;
void (vector, vector) te_shield_test;
void (vector, float) te_heat_small;
void (vector, vector, float) te_mis_trail;
void (vector, float) te_mis_flame;
void (vector) te_mis_expl;
void (vector, vector) te_beam_laser;
void (vector, float, float) te_laser_hit;
void (vector, vector, vector, float, float) te_muzzle_generic;
void () te_nav_reach;
void (float) te_objective_complete;
void () te_objective_failed;
void () te_mission_win;
void () te_mission_lose;
void () te_msn_boundary;
void () map_initTrigger;
void () map_trigger_highlighthud;
void () map_trigger_multiple;
void () map_trigger_once;
void () map_trigger_relay;
void () map_trigger_secret;
void () map_trigger_counter;
void () map_trigger_teleport;
void () map_trigger_setskill;
void () map_trigger_hurt;
void () map_trigger_push;
void () map_trigger_changelevel;
void() SUB_Null = asm
{
	DONE;
}

void() SUB_Remove = asm
{
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void() SetMovedir = asm
{
local float locked_427;
local vector temp_0;
local float temp_1;
	INDIRECT_V	self,	movedir_x,	locked_427;
	NE_V		locked_427,	VEC_ORIGIN,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	movedir_x,	locked_427;
	INDIRECT_V	self,	movedir_x,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_427;
	GOTO		17;
	INDIRECT_V	self,	angles_x,	temp_0;
	EQ_V		temp_0,	'0.000000 -1.000000 0.000000',	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	movedir_x,	temp_0_x;
	STOREP_V	'0.000000 0.000000 1.000000',	temp_0;
	GOTO		11;
	INDIRECT_V	self,	angles_x,	temp_0;
	EQ_V		temp_0,	'0.000000 -2.000000 0.000000',	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	movedir_x,	temp_0_x;
	STOREP_V	'0.000000 0.000000 -1.000000',	temp_0;
	GOTO		5;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	ADDRESS	self,	movedir_x,	temp_0_x;
	STOREP_V	v_forward_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	DONE;
}

void() InitTrigger = asm
{
local vector temp_0;
local float temp_1;
	INDIRECT_V	self,	movedir_x,	temp_0;
	EQ_V		temp_0,	VEC_ORIGIN,	temp_1;
	IFNOT		temp_1,	5;
	INDIRECT_V	self,	angles_x,	temp_0;
	NE_V		temp_0,	VEC_ORIGIN,	temp_1;
	IFNOT		temp_1,	2;
	CALL0		SetMovedir;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	TRUE,	temp_1;
	INDIRECT_S	self,	model,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		setmodel;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	modelindex,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	model,	temp_1;
	STOREP_S	"",	temp_1;
	DONE;
}

void() InitSolidBSPTrigger = asm
{
local vector temp_0;
local float temp_1;
	INDIRECT_V	self,	movedir_x,	temp_0;
	EQ_V		temp_0,	VEC_ORIGIN,	temp_1;
	IFNOT		temp_1,	5;
	INDIRECT_V	self,	angles_x,	temp_0;
	NE_V		temp_0,	VEC_ORIGIN,	temp_1;
	IFNOT		temp_1,	2;
	CALL0		SetMovedir;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	INDIRECT_S	self,	model,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		setmodel;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	model,	temp_1;
	STOREP_S	"",	temp_1;
	DONE;
}

void(entity ent, vector tdest, float tspeed, void () func) SUB_CalcMoveEnt = asm
{
	STORE_ENT	self,	stemp;
	STORE_ENT	ent,	self;
	STORE_V	tdest,	parm0;
	STORE_F	tspeed,	parm1_x;
	STORE_F	func,	parm2_x;
	CALL3		SUB_CalcMove;
	STORE_ENT	stemp,	self;
	DONE;
}

void(vector tdest, float tspeed, void () func) SUB_CalcMove = asm
{
local float traveltime;
local float len;
local vector vdestdelta;
local vector temp_0;
local float temp_1;
local float temp_2;
local vector temp_3;
	NE_F		tspeed,	FALSE,	temp_1;
	IF		temp_1,	3;
	STORE_F	"No speed is defined!",	parm0_x;
	CALL1		objerror;
	ADDRESS	self,	think1,	temp_1;
	STOREP_FNC	func,	temp_1;
	ADDRESS	self,	dest3_x,	temp_0_x;
	STOREP_V	tdest_x,	temp_0;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	SUB_CalcMoveDone,	temp_1;
	INDIRECT_V	self,	origin_x,	temp_0;
	EQ_V		tdest,	temp_0,	temp_1;
	IFNOT		temp_1,	8;
	ADDRESS	self,	velocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	ltime,	temp_2;
	ADD_F		temp_2,	0.100000,	temp_2;
	STOREP_F	temp_2,	temp_1;
	RETURN	offset_0;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		tdest,	temp_0,	vdestdelta;
	STORE_V	vdestdelta,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	len;
	DIV_F		len,	tspeed,	traveltime;
	LT		traveltime,	0.100000,	temp_1;
	IFNOT		temp_1,	8;
	ADDRESS	self,	velocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	ltime,	temp_2;
	ADD_F		temp_2,	0.100000,	temp_2;
	STOREP_F	temp_2,	temp_1;
	RETURN	offset_0;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	ltime,	temp_2;
	ADD_F		temp_2,	traveltime,	temp_2;
	STOREP_F	temp_2,	temp_1;
	ADDRESS	self,	velocity_x,	temp_0_x;
	DIV_F		TRUE,	traveltime,	temp_1;
	MUL_VF	vdestdelta,	temp_1,	temp_3;
	STOREP_V	temp_3_x,	temp_0;
	INDIRECT_F	self,	movetype,	temp_1;
	EQ_F		temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	velocity_x,	temp_0_x;
	INDIRECT_V	self,	velocity_x,	temp_3;
	MUL_VF	temp_3,	0.100000,	temp_3;
	STOREP_V	temp_3_x,	temp_0;
	DONE;
}

void() SUB_CalcMoveDone = asm
{
local vector temp_0;
local float temp_1;
	INDIRECT_V	self,	dest3_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	velocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	nextthink,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	INDIRECT_FU	self,	think1,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_FU	self,	think1,	temp_1;
	CALL0		temp_1;
	DONE;
}

void(entity ent, vector destangle, float tspeed, void () func) SUB_CalcAngleMoveEnt = asm
{
	STORE_ENT	self,	stemp;
	STORE_ENT	ent,	self;
	STORE_V	destangle,	parm0;
	STORE_F	tspeed,	parm1_x;
	STORE_F	func,	parm2_x;
	CALL3		SUB_CalcAngleMove;
	STORE_ENT	stemp,	self;
	DONE;
}

void(vector destangle, float tspeed, void () func) SUB_CalcAngleMove = asm
{
local float traveltime;
local float len;
local vector destdelta;
local vector temp_0;
local float temp_1;
local float temp_2;
local vector temp_3;
	NE_F		tspeed,	FALSE,	temp_1;
	IF		temp_1,	3;
	STORE_F	"No speed is defined!",	parm0_x;
	CALL1		objerror;
	INDIRECT_V	self,	angles_x,	temp_0;
	SUB_V		destangle,	temp_0,	destdelta;
	STORE_V	destdelta,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	len;
	DIV_F		len,	tspeed,	traveltime;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	ltime,	temp_2;
	ADD_F		temp_2,	traveltime,	temp_2;
	STOREP_F	temp_2,	temp_1;
	ADDRESS	self,	avelocity_x,	temp_0_x;
	DIV_F		TRUE,	traveltime,	temp_1;
	MUL_VF	destdelta,	temp_1,	temp_3;
	STOREP_V	temp_3_x,	temp_0;
	ADDRESS	self,	think1,	temp_1;
	STOREP_FNC	func,	temp_1;
	ADDRESS	self,	dest4_x,	temp_0_x;
	STOREP_V	destangle_x,	temp_0;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	SUB_CalcAngleMoveDone,	temp_1;
	DONE;
}

void() SUB_CalcAngleMoveDone = asm
{
local vector temp_0;
local float temp_1;
local vector temp_3;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_V	self,	dest4_x,	temp_3;
	STOREP_V	temp_3_x,	temp_0;
	ADDRESS	self,	avelocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	nextthink,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	INDIRECT_FU	self,	think1,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_FU	self,	think1,	temp_1;
	CALL0		temp_1;
	DONE;
}

void() DelayThink = asm
{
local float temp_1;
	INDIRECT_E	self,	enemy,	activator;
	CALL0		SUB_UseTargets;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void() SUB_UseTargets = asm
{
local entity act;
local entity t;
local float temp_1;
local float temp_2;
	INDIRECT_F	self,	delay,	temp_1;
	IFNOT		temp_1,	23;
	CALL0		spawn;
	STORE_ENT	return_x,	t;
	ADDRESS	t,	classname,	temp_1;
	STOREP_S	"DelayedUse",	temp_1;
	ADDRESS	t,	nextthink,	temp_1;
	INDIRECT_F	self,	delay,	temp_2;
	ADD_F		time,	temp_2,	temp_2;
	STOREP_F	temp_2,	temp_1;
	ADDRESS	t,	think,	temp_1;
	STOREP_FNC	DelayThink,	temp_1;
	ADDRESS	t,	enemy,	temp_1;
	STOREP_ENT	activator,	temp_1;
	ADDRESS	t,	message,	temp_1;
	INDIRECT_S	self,	message,	temp_2;
	STOREP_S	temp_2,	temp_1;
	ADDRESS	t,	killtarget,	temp_1;
	INDIRECT_S	self,	killtarget,	temp_2;
	STOREP_S	temp_2,	temp_1;
	ADDRESS	t,	target,	temp_1;
	INDIRECT_S	self,	target,	temp_2;
	STOREP_S	temp_2,	temp_1;
	RETURN	offset_0;
	INDIRECT_S	activator,	classname,	temp_1;
	EQ_S		temp_1,	"player",	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_S	self,	message,	temp_2;
	NE_S		temp_2,	"",	temp_2;
	AND		temp_1,	temp_2,	temp_1;
	IFNOT		temp_1,	17;
	INDIRECT_F	activator,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	5;
	INDIRECT_S	self,	message,	temp_1;
	STORE_F	activator,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		centerprint;
	INDIRECT_S	self,	noise,	temp_1;
	NOT_S		temp_1,	temp_1;
	IFNOT		temp_1,	7;
	STORE_F	activator,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	"misc/talk.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_S	self,	killtarget,	temp_1;
	IFNOT		temp_1,	13;
	STORE_ENT	world,	t;
	INDIRECT_S	self,	killtarget,	temp_1;
	STORE_F	t,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	t;
	IF		t,	2;
	RETURN	offset_0;
	STORE_F	t,	parm0_x;
	CALL1		remove;
	GOTO		-10;
	INDIRECT_S	self,	target,	temp_1;
	IFNOT		temp_1,	23;
	STORE_ENT	activator,	act;
	STORE_ENT	world,	t;
	INDIRECT_S	self,	target,	temp_1;
	STORE_F	t,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	t;
	IF		t,	2;
	RETURN	offset_0;
	STORE_ENT	self,	stemp;
	STORE_ENT	other,	otemp;
	STORE_ENT	t,	self;
	STORE_ENT	stemp,	other;
	INDIRECT_FU	self,	use,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_FU	self,	use,	temp_1;
	CALL0		temp_1;
	STORE_ENT	stemp,	self;
	STORE_ENT	otemp,	other;
	STORE_ENT	act,	activator;
	GOTO		-19;
	DONE;
}

void(float normal) SUB_AttackFinished = asm
{
local float temp_1;
local float temp_2;
	ADDRESS	self,	cnt,	temp_1;
	STOREP_F	FALSE,	temp_1;
	LT		skill,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	attack_finished,	temp_1;
	ADD_F		time,	normal,	temp_2;
	STOREP_F	temp_2,	temp_1;
	DONE;
}

void(void () thinkst) SUB_CheckRefire = asm
{
local float temp_1;
	LT		skill,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	cnt,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		visible;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	2;
	RETURN	offset_0;
	ADDRESS	self,	cnt,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	thinkst,	temp_1;
	DONE;
}

vector(vector ang) SUB_NormalizeAngles = asm
{
local float temp_1;
	GT		ang_x,	360.000000,	temp_1;
	IFNOT		temp_1,	3;
	SUB_F		ang_x,	360.000000,	ang_x;
	GOTO		-3;
	LT		ang_x,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADD_F		ang_x,	360.000000,	ang_x;
	GOTO		-3;
	GT		ang_y,	360.000000,	temp_1;
	IFNOT		temp_1,	3;
	SUB_F		ang_y,	360.000000,	ang_y;
	GOTO		-3;
	LT		ang_y,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADD_F		ang_y,	360.000000,	ang_y;
	GOTO		-3;
	GT		ang_z,	360.000000,	temp_1;
	IFNOT		temp_1,	3;
	SUB_F		ang_z,	360.000000,	ang_z;
	GOTO		-3;
	LT		ang_z,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADD_F		ang_z,	360.000000,	ang_z;
	GOTO		-3;
	RETURN	ang_x;
	DONE;
}

void () data_prj_sfga_touch;
void () data_prj_sfga_raddmg;
void() data_prj_sfga_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_2;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"prj_sfga",	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	data_prj_sfga_touch,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	p_velocity,	temp_1;
	STOREP_F	DAT_PRJ_EMP_VELOCITY,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_PRJ_SFGA_MODEL,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	effects,	temp_1;
	INDIRECT_F	self,	effects,	temp_2;
	BITOR		temp_2,	DAT_PRJ_SFGA_EFFECTS,	temp_2;
	STOREP_F	temp_2,	temp_1;
	ADDRESS	self,	modelflags,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_MODELFLAGS,	temp_1;
	ADDRESS	self,	alpha,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	DAT_PRJ_SFGA_COLORMOD_x,	temp_0;
	ADDRESS	self,	glow_color,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_GLOWCOLOR,	temp_1;
	ADDRESS	self,	glow_size,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_GLOWSIZE,	temp_1;
	ADDRESS	self,	glow_trail,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_GLOWTRAIL,	temp_1;
	DONE;
}

void() data_prj_sfga_touch = asm
{
local vector temp_0;
local float temp_1;
local float temp_2;
local float temp_4;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		pointcontents;
	EQ_F		return_x,	CONTENT_SKY,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_S	other,	classname,	temp_1;
	EQ_S		temp_1,	"worldspawn",	temp_1;
	IFNOT		temp_1,	4;
	CALL0		data_prj_sfga_raddmg;
	CALL0		BecomeExplosion;
	RETURN	offset_0;
	INDIRECT_E	self,	owner,	temp_1;
	EQ_E		other,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	takedamage,	temp_1;
	IFNOT		temp_1,	19;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_2;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_2,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	INDIRECT_F	other,	sh_cur,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	CALL0		data_prj_sfga_raddmg;
	CALL0		BecomeExplosion;
	DONE;
}

void() data_prj_sfga_raddmg = asm
{
local float dmg_act;
local float d;
local entity f;
local vector temp_0;
local float temp_1;
local float temp_2;
local vector temp_3;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_1,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	f;
	IFNOT		f,	45;
	NE_E		f,	other,	temp_1;
	IFNOT		temp_1,	41;
	INDIRECT_F	f,	comp_id,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	38;
	INDIRECT_V	f,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_3;
	SUB_V		temp_0,	temp_3,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	d;
	LT		d,	37.500000,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	p_damage,	dmg_act;
	GOTO		11;
	GT		d,	37.500000,	temp_1;
	IFNOT		temp_1,	2;
	LT		d,	TE_PLASMABURN,	temp_2;
	AND		temp_1,	temp_2,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_F	self,	p_damage,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	dmg_act;
	GOTO		3;
	INDIRECT_F	self,	p_damage,	temp_1;
	DIV_F		temp_1,	MOVETYPE_STEP,	dmg_act;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	f,	origin_x,	temp_3;
	INDIRECT_E	self,	owner,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_3,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	CALL4		traceline;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_2;
	STORE_F	f,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	dmg_act,	parm3_x;
	STORE_F	temp_2,	parm4_x;
	STORE_V	trace_endpos,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	INDIRECT_E	f,	chain,	f;
	GOTO		-44;
	DONE;
}

void () data_prj_emp_touch;
void () data_prj_emp_think;
void () data_prj_emp_explode;
void() data_prj_emp_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_2;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"prj_emp",	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	data_prj_emp_touch,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	p_velocity,	temp_1;
	STOREP_F	DAT_PRJ_EMP_VELOCITY,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_PRJ_EMP_MODEL,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	STOREP_F	DAT_PRJ_EMP_LIFETIME,	temp_1;
	ADDRESS	self,	effects,	temp_1;
	INDIRECT_F	self,	effects,	temp_2;
	BITOR		temp_2,	4128.000000,	temp_2;
	STOREP_F	temp_2,	temp_1;
	ADDRESS	self,	modelflags,	temp_1;
	STOREP_F	DAT_PRJ_EMP_MODELFLAGS,	temp_1;
	ADDRESS	self,	alpha,	temp_1;
	STOREP_F	SHVBAL_EFFNON_REDUCE,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	DAT_PRJ_EMP_COLORMOD_x,	temp_0;
	ADDRESS	self,	glow_color,	temp_1;
	STOREP_F	DAT_PRJ_EMP_GLOWCOLOR,	temp_1;
	ADDRESS	self,	glow_size,	temp_1;
	STOREP_F	DAT_PRJ_EMP_GLOWSIZE,	temp_1;
	ADDRESS	self,	glow_trail,	temp_1;
	STOREP_F	DAT_PRJ_EMP_GLOWTRAIL,	temp_1;
	DONE;
}

void() data_prj_emp_think = asm
{
local float ln;
local entity f;
local entity proxy;
local float explode;
local float dist;
local vector temp_0;
local float temp_1;
local float temp_2;
local vector temp_3;
	STORE_F	FALSE,	explode;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	32;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	DAT_PRJ_QRFL_VELOCITY,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	proxy;
	IFNOT		proxy,	27;
	INDIRECT_F	proxy,	takedamage,	temp_1;
	IFNOT		temp_1,	23;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	proxy,	origin_x,	temp_3;
	INDIRECT_E	self,	owner,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_3,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	CALL4		traceline;
	IFNOT		trace_ent,	14;
	INDIRECT_F	trace_ent,	comp_id,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	trace_ent,	owner,	f;
	GOTO		2;
	STORE_ENT	trace_ent,	f;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		trace_endpos,	temp_0,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	ln;
	LE		ln,	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	explode;
	INDIRECT_E	proxy,	chain,	proxy;
	GOTO		-26;
	INDIRECT_F	self,	p_lifetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	explode;
	IFNOT		explode,	4;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_emp_explode,	temp_1;
	GOTO		3;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_emp_think,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_2;
	STOREP_F	temp_2,	temp_1;
	DONE;
}

void() data_prj_emp_explode = asm
{
local float ln;
local entity lst;
local vector temp_0;
local float temp_1;
local float temp_2;
local vector temp_3;
local float temp_4;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	DAT_PRJ_ABT_CLST_VELOCITY,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	lst;
	IFNOT		lst,	32;
	INDIRECT_F	lst,	takedamage,	temp_1;
	IFNOT		temp_1,	28;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	lst,	origin_x,	temp_3;
	INDIRECT_E	self,	owner,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_3,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	CALL4		traceline;
	IFNOT		trace_ent,	19;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		trace_endpos,	temp_0,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	ln;
	LE		ln,	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	IFNOT		temp_1,	13;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_2;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	lst,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_2,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	INDIRECT_E	lst,	chain,	lst;
	GOTO		-31;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		te_tarexplosion;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_2;
	STOREP_F	temp_2,	temp_1;
	DONE;
}

void() data_prj_emp_touch = asm
{
local vector temp_0;
local float temp_1;
local float temp_2;
local float temp_4;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		pointcontents;
	EQ_F		return_x,	CONTENT_SKY,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_S	other,	classname,	temp_1;
	EQ_S		temp_1,	"worldspawn",	temp_1;
	IFNOT		temp_1,	9;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		te_tarexplosion;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_2;
	STOREP_F	temp_2,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_emp_explode,	temp_1;
	RETURN	offset_0;
	INDIRECT_E	self,	owner,	temp_1;
	EQ_E		other,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	takedamage,	temp_1;
	IFNOT		temp_1,	15;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		te_tarexplosion;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_2;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_2,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void () data_prj_mis_touch;
void() data_prj_mis_touch = asm
{
local vector temp_0;
local float temp_1;
local float temp_2;
local float temp_4;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		pointcontents;
	EQ_F		return_x,	CONTENT_SKY,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_E	self,	owner,	temp_1;
	EQ_E		other,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	takedamage,	temp_1;
	IFNOT		temp_1,	19;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_2;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_2,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	INDIRECT_F	other,	sh_cur,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		te_mis_expl;
	CALL0		BecomeExplosion;
	DONE;
}

void () data_prj_mis_th;
void() data_prj_mis_th = asm
{
local vector smk1;
local vector temp_0;
local float temp_1;
local float temp_2;
local vector temp_3;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_forward,	-2.500000,	temp_3;
	ADD_V		temp_0,	temp_3,	smk1;
	STORE_V	smk1,	parm0;
	STORE_F	TRUE,	parm1_x;
	CALL2		te_mis_flame;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_mis_th,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	ARM_LT_MOD,	temp_2;
	STOREP_F	temp_2,	temp_1;
	INDIRECT_F	self,	power_timer,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	ARM_LT_MOD,	temp_2;
	STOREP_F	temp_2,	temp_1;
	DONE;
}

void() data_prj_mis_ini = asm
{
local float locked_916;
local vector temp_0;
local float temp_2;
	ADDRESS	self,	classname,	locked_916;
	STOREP_S	"prj_rck",	locked_916;
	ADDRESS	self,	touch,	locked_916;
	STOREP_FNC	data_prj_mis_touch,	locked_916;
	ADDRESS	self,	data_idx,	locked_916;
	STOREP_F	MOVETYPE_WALK,	locked_916;
	ADDRESS	self,	p_velocity,	locked_916;
	STOREP_F	DAT_PRJ_MIS_VELOCITY,	locked_916;
	ADDRESS	self,	c_model,	locked_916;
	STOREP_S	DAT_PRJ_MIS_MODEL,	locked_916;
	ADDRESS	self,	p_lifetime,	locked_916;
	STOREP_F	DAT_PRJ_MIS_LIFETIME,	locked_916;
	ADDRESS	self,	effects,	locked_916;
	INDIRECT_F	self,	effects,	temp_2;
	BITOR		temp_2,	FL_JUMPRELEASED,	temp_2;
	STOREP_F	temp_2,	locked_916;
	ADDRESS	self,	modelflags,	locked_916;
	STOREP_F	FALSE,	locked_916;
	ADDRESS	self,	alpha,	locked_916;
	STOREP_F	TRUE,	locked_916;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	DAT_PRJ_MIS_COLORMOD_x,	temp_0;
	ADDRESS	self,	glow_color,	locked_916;
	STOREP_F	FALSE,	locked_916;
	ADDRESS	self,	glow_size,	locked_916;
	STOREP_F	FALSE,	locked_916;
	ADDRESS	self,	glow_trail,	locked_916;
	STOREP_F	DAT_PRJ_MIS_GLOWTRAIL,	locked_916;
	ADDRESS	self,	traileffectnum,	locked_916;
	STORE_F	"TE_MIS_TRAIL",	parm0_x;
	CALL1		particleeffectnum;
	STOREP_F	return_x,	locked_916;
	DONE;
}

float DAT_PRJ_MLGD_IDX;
void () data_prj_mlgd_th;
void () data_prj_mlgd_touch;
void() data_prj_mlgd_ini = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"prj_mlgd",	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	data_prj_mlgd_touch,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	DAT_PRJ_MLGD_IDX,	temp_1;
	ADDRESS	self,	p_velocity,	temp_1;
	STOREP_F	DAT_PRJ_MLGD_VELOCITY,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_PRJ_MLGD_MODEL,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	STOREP_F	SHVENE_EFFRAM_PERCENTAGE,	temp_1;
	ADDRESS	self,	effects,	temp_1;
	STOREP_F	4128.000000,	temp_1;
	ADDRESS	self,	modelflags,	temp_1;
	STOREP_F	DAT_PRJ_MLGD_MODELFLAGS,	temp_1;
	ADDRESS	self,	alpha,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	DAT_PRJ_MLGD_COLORMOD_x,	temp_0;
	ADDRESS	self,	glow_color,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	glow_size,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	glow_trail,	temp_1;
	STOREP_F	DAT_PRJ_MLGD_GLOWTRAIL,	temp_1;
	DONE;
}

void() data_prj_mlgd_th = asm
{
local float locked_2790;
local float turnrate;
local vector nuv;
local vector olddir;
local vector dir;
local vector lorg;
local float temp_1;
local float temp_2;
local vector temp_3;
	STORE_F	0.900000,	turnrate;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_V	temp_1,	laser_sight_org_x,	lorg;
	NE_V		lorg,	VEC_ORIGIN,	temp_1;
	IFNOT		temp_1,	43;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		normalize;
	STORE_V	return,	olddir;
	INDIRECT_V	self,	origin_x,	locked_2790;
	SUB_V		lorg,	locked_2790,	parm0;
	CALL1		normalize;
	STORE_V	return,	dir;
	SUB_F		olddir_x,	dir_x,	temp_1;
	GT		temp_1,	turnrate,	temp_1;
	IFNOT		temp_1,	2;
	SUB_F		olddir_x,	turnrate,	dir_x;
	SUB_F		olddir_x,	dir_x,	temp_1;
	MUL_F		CONTENT_EMPTY,	turnrate,	temp_2;
	LT		temp_1,	temp_2,	temp_1;
	IFNOT		temp_1,	2;
	ADD_F		olddir_x,	turnrate,	dir_x;
	SUB_F		olddir_y,	dir_y,	temp_1;
	GT		temp_1,	turnrate,	temp_1;
	IFNOT		temp_1,	2;
	SUB_F		olddir_y,	turnrate,	dir_y;
	SUB_F		olddir_y,	dir_y,	temp_1;
	MUL_F		CONTENT_EMPTY,	turnrate,	temp_2;
	LT		temp_1,	temp_2,	temp_1;
	IFNOT		temp_1,	2;
	ADD_F		olddir_y,	turnrate,	dir_y;
	SUB_F		olddir_z,	dir_z,	temp_1;
	GT		temp_1,	turnrate,	temp_1;
	IFNOT		temp_1,	2;
	SUB_F		olddir_z,	turnrate,	dir_z;
	SUB_F		olddir_z,	dir_z,	temp_1;
	MUL_F		CONTENT_EMPTY,	turnrate,	temp_2;
	LT		temp_1,	temp_2,	temp_1;
	IFNOT		temp_1,	2;
	ADD_F		olddir_z,	turnrate,	dir_z;
	ADDRESS	self,	velocity_x,	locked_2790;
	INDIRECT_F	self,	p_velocity,	temp_1;
	MUL_VF	dir,	temp_1,	temp_3;
	STOREP_V	temp_3_x,	locked_2790;
	ADDRESS	self,	angles_x,	locked_2790;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2790;
	INDIRECT_F	self,	p_lifetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_2;
	STOREP_F	temp_2,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	GOTO		6;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	DAT_LATC_RL_RATE,	temp_2;
	STOREP_F	temp_2,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_mlgd_th,	temp_1;
	DONE;
}

void() data_prj_mlgd_touch = asm
{
local vector temp_0;
local float temp_1;
local float temp_2;
local float temp_4;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		pointcontents;
	EQ_F		return_x,	CONTENT_SKY,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_E	self,	owner,	temp_1;
	EQ_E		other,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	takedamage,	temp_1;
	IFNOT		temp_1,	19;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_2;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_2,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	INDIRECT_F	other,	sh_cur,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	CALL0		BecomeExplosion;
	DONE;
}

float DAT_PRJ_MARH_IDX;
float DAT_PRJ_MARH_DAMAGE;
float DAT_PRJ_MARH_DMGTYPE;
void () data_prj_marh_th;
void () data_prj_marh_touch;
void() data_prj_marh_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_2;
local float temp_4;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"prj_marh",	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	data_prj_marh_touch,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	DAT_PRJ_MARH_IDX,	temp_1;
	ADDRESS	self,	p_velocity,	temp_1;
	STOREP_F	DAT_PRJ_MARH_VELOCITY,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_PRJ_MARH_MODEL,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	STOREP_F	IMP_SWEAPON1,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	effects,	temp_1;
	INDIRECT_F	self,	effects,	temp_2;
	INDIRECT_F	self,	effects,	temp_4;
	BITAND	temp_4,	IT_WEAPON10,	temp_4;
	SUB_F		temp_2,	temp_4,	temp_2;
	STOREP_F	temp_2,	temp_1;
	ADDRESS	self,	effects,	temp_1;
	INDIRECT_F	self,	effects,	temp_2;
	BITOR		temp_2,	FL_JUMPRELEASED,	temp_2;
	STOREP_F	temp_2,	temp_1;
	ADDRESS	self,	modelflags,	temp_1;
	STOREP_F	DAT_PRJ_MARH_MODELFLAGS,	temp_1;
	ADDRESS	self,	alpha,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	DAT_PRJ_MARH_COLORMOD_x,	temp_0;
	ADDRESS	self,	glow_color,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	glow_size,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	glow_trail,	temp_1;
	STOREP_F	DAT_PRJ_MARH_GLOWTRAIL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	DONE;
}

void() data_prj_marh_th = asm
{
local float locked_2790;
local float turnrate;
local vector olddir;
local vector vtemp;
local vector dir;
local float temp_1;
local float temp_2;
local vector temp_3;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	temp_1,	health,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	9;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	TRUE,	temp_2;
	CALL0		random;
	ADD_F		temp_2,	return_x,	temp_2;
	STOREP_F	temp_2,	temp_1;
	RETURN	offset_0;
	INDIRECT_E	self,	enemy,	temp_1;
	EQ_E		temp_1,	world,	temp_1;
	IFNOT		temp_1,	9;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	TRUE,	temp_2;
	CALL0		random;
	ADD_F		temp_2,	return_x,	temp_2;
	STOREP_F	temp_2,	temp_1;
	RETURN	offset_0;
	STORE_F	DAT_MNT_SHIELD_RATE,	turnrate;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	stat_lck_stt,	temp_1;
	BITAND	temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	62;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_V	temp_1,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	locked_2790;
	ADD_V		locked_2790,	'0.000000 0.000000 10.000000',	locked_2790;
	CALL0		crandom;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	temp_1,	maxs_x,	temp_1;
	MUL_F		return_x,	temp_1,	temp_1;
	MUL_FV	temp_1,	v_right,	temp_3;
	ADD_V		locked_2790,	temp_3,	locked_2790;
	CALL0		crandom;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	temp_1,	maxs_x,	temp_1;
	MUL_F		return_x,	temp_1,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_3;
	ADD_V		locked_2790,	temp_3,	vtemp;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		normalize;
	STORE_V	return,	olddir;
	INDIRECT_V	self,	origin_x,	locked_2790;
	SUB_V		vtemp,	locked_2790,	parm0;
	CALL1		normalize;
	STORE_V	return,	dir;
	SUB_F		olddir_x,	dir_x,	temp_1;
	GT		temp_1,	turnrate,	temp_1;
	IFNOT		temp_1,	2;
	SUB_F		olddir_x,	turnrate,	dir_x;
	SUB_F		olddir_x,	dir_x,	temp_1;
	MUL_F		CONTENT_EMPTY,	turnrate,	temp_2;
	LT		temp_1,	temp_2,	temp_1;
	IFNOT		temp_1,	2;
	ADD_F		olddir_x,	turnrate,	dir_x;
	SUB_F		olddir_y,	dir_y,	temp_1;
	GT		temp_1,	turnrate,	temp_1;
	IFNOT		temp_1,	2;
	SUB_F		olddir_y,	turnrate,	dir_y;
	SUB_F		olddir_y,	dir_y,	temp_1;
	MUL_F		CONTENT_EMPTY,	turnrate,	temp_2;
	LT		temp_1,	temp_2,	temp_1;
	IFNOT		temp_1,	2;
	ADD_F		olddir_y,	turnrate,	dir_y;
	SUB_F		olddir_z,	dir_z,	temp_1;
	GT		temp_1,	turnrate,	temp_1;
	IFNOT		temp_1,	2;
	SUB_F		olddir_z,	turnrate,	dir_z;
	SUB_F		olddir_z,	dir_z,	temp_1;
	MUL_F		CONTENT_EMPTY,	turnrate,	temp_2;
	LT		temp_1,	temp_2,	temp_1;
	IFNOT		temp_1,	2;
	ADD_F		olddir_z,	turnrate,	dir_z;
	ADDRESS	self,	velocity_x,	locked_2790;
	INDIRECT_F	self,	p_velocity,	temp_1;
	MUL_VF	dir,	temp_1,	temp_3;
	STOREP_V	temp_3_x,	locked_2790;
	ADDRESS	self,	angles_x,	locked_2790;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2790;
	GOTO		6;
	ADDRESS	self,	p_lifetime,	temp_1;
	INDIRECT_F	self,	p_lifetime,	temp_2;
	SUB_F		temp_2,	0.250000,	temp_2;
	STOREP_F	temp_2,	temp_1;
	RETURN	offset_0;
	INDIRECT_F	self,	p_lifetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	GOTO		3;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_marh_th,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	DAT_EQP_LSAR_EN_RATE,	temp_2;
	STOREP_F	temp_2,	temp_1;
	DONE;
}

void() data_prj_marh_touch = asm
{
local vector temp_0;
local float temp_1;
local float temp_2;
local float temp_4;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		pointcontents;
	EQ_F		return_x,	CONTENT_SKY,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_S	other,	classname,	temp_1;
	EQ_S		temp_1,	"worldspawn",	temp_1;
	IFNOT		temp_1,	3;
	CALL0		BecomeExplosion;
	RETURN	offset_0;
	INDIRECT_E	self,	owner,	temp_1;
	EQ_E		other,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	takedamage,	temp_1;
	IFNOT		temp_1,	13;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_2;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_2,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	CALL0		BecomeExplosion;
	DONE;
}

float DAT_PRJ_RPLAS_IDX;
void () data_prj_rplas_touch;
void () data_prj_rplas_burn;
void() data_prj_rplas_ini = asm
{
local float locked_916;
local vector temp_0;
local float temp_2;
	ADDRESS	self,	touch,	locked_916;
	STOREP_FNC	data_prj_rplas_touch,	locked_916;
	ADDRESS	self,	data_idx,	locked_916;
	STOREP_F	DAT_PRJ_RPLAS_IDX,	locked_916;
	ADDRESS	self,	p_velocity,	locked_916;
	STOREP_F	DAT_PRJ_RPLAS_VELOCITY,	locked_916;
	ADDRESS	self,	c_model,	locked_916;
	STOREP_S	DAT_PRJ_RPLAS_MODEL,	locked_916;
	ADDRESS	self,	p_lifetime,	locked_916;
	STOREP_F	DAT_PRJ_RPLAS_LIFETIME,	locked_916;
	ADDRESS	self,	effects,	locked_916;
	INDIRECT_F	self,	effects,	temp_2;
	BITOR		temp_2,	DAT_PRJ_RPLAS_EFFECTS,	temp_2;
	STOREP_F	temp_2,	locked_916;
	ADDRESS	self,	modelflags,	locked_916;
	STOREP_F	FALSE,	locked_916;
	ADDRESS	self,	alpha,	locked_916;
	STOREP_F	SHVBAL_EFFNON_REDUCE,	locked_916;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	DAT_PRJ_RPLAS_COLORMOD_x,	temp_0;
	ADDRESS	self,	glow_color,	locked_916;
	STOREP_F	DAT_PRJ_RPLAS_GLOWCOLOR,	locked_916;
	ADDRESS	self,	glow_size,	locked_916;
	STOREP_F	FL_MONSTER,	locked_916;
	ADDRESS	self,	glow_trail,	locked_916;
	STOREP_F	DAT_PRJ_RPLAS_GLOWTRAIL,	locked_916;
	ADDRESS	self,	traileffectnum,	locked_916;
	STORE_F	"TE_RPC_TRAIL",	parm0_x;
	CALL1		particleeffectnum;
	STOREP_F	return_x,	locked_916;
	DONE;
}

void() data_prj_rplas_burn = asm
{
local entity e;
local float temp_0;
local vector temp_1;
local float temp_2;
local float temp_3;
local float temp_5;
	INDIRECT_E	self,	enemy,	temp_2;
	INDIRECT_F	temp_2,	deadflag,	temp_2;
	GT		temp_2,	FALSE,	temp_2;
	IFNOT		temp_2,	7;
	ADDRESS	self,	think,	temp_2;
	STOREP_FNC	SUB_Remove,	temp_2;
	ADDRESS	self,	nextthink,	temp_2;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_2;
	RETURN	offset_0;
	INDIRECT_E	self,	enemy,	temp_2;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	self,	p_dmgtype,	temp_5;
	INDIRECT_E	self,	e_cam,	temp_0;
	INDIRECT_V	temp_0,	origin_x,	temp_1;
	STORE_F	temp_2,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	0.500000,	parm3_x;
	STORE_F	temp_5,	parm4_x;
	STORE_V	temp_1,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	STORE_F	"TE_RPC_BURN",	parm0_x;
	CALL1		particleeffectnum;
	INDIRECT_V	self,	origin_x,	temp_1;
	STORE_F	return_x,	parm0_x;
	STORE_V	temp_1,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	STORE_F	TRUE,	parm3_x;
	CALL4		pointparticles;
	INDIRECT_F	self,	p_lifetime,	temp_0;
	GT		time,	temp_0,	temp_0;
	IFNOT		temp_0,	8;
	ADDRESS	self,	think,	temp_0;
	STOREP_FNC	SUB_Remove,	temp_0;
	ADDRESS	self,	nextthink,	temp_0;
	ADD_F		time,	0.100000,	temp_2;
	STOREP_F	temp_2,	temp_0;
	RETURN	offset_0;
	GOTO		6;
	ADDRESS	self,	think,	temp_0;
	STOREP_FNC	data_prj_rplas_burn,	temp_0;
	ADDRESS	self,	nextthink,	temp_0;
	ADD_F		time,	0.100000,	temp_2;
	STOREP_F	temp_2,	temp_0;
	DONE;
}

void() data_prj_rplas_touch = asm
{
local entity hit;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
local vector temp_5;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		pointcontents;
	EQ_F		return_x,	CONTENT_SKY,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_F	self,	solid,	temp_1;
	STORE_F	" self solid",	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		cons_logAFloat;
	INDIRECT_F	other,	solid,	temp_1;
	STORE_F	" other solid",	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		cons_logAFloat;
	STORE_F	"TE_RPC_HIT",	parm0_x;
	CALL1		particleeffectnum;
	INDIRECT_V	self,	origin_x,	temp_2;
	STORE_F	return_x,	parm0_x;
	STORE_V	temp_2,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	STORE_F	TRUE,	parm3_x;
	CALL4		pointparticles;
	INDIRECT_F	other,	takedamage,	temp_1;
	IFNOT		temp_1,	74;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_3;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	INDIRECT_V	self,	origin_x,	temp_2;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	temp_2,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	STORE_ENT	return_x,	hit;
	INDIRECT_F	other,	sh_cur,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	58;
	STORE_F	self,	parm0_x;
	STORE_F	"progs/plasmashot.spr32",	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_FOLLOW,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	velocity_x,	temp_2_x;
	STOREP_V	VEC_ORIGIN_x,	temp_2;
	ADDRESS	self,	avelocity_x,	temp_2_x;
	STOREP_V	VEC_ORIGIN_x,	temp_2;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	other,	temp_1;
	ADDRESS	self,	e_cam,	temp_1;
	STOREP_ENT	hit,	temp_1;
	ADDRESS	self,	aiment,	temp_1;
	INDIRECT_E	self,	e_cam,	temp_3;
	STOREP_ENT	temp_3,	temp_1;
	ADDRESS	self,	punchangle_x,	temp_2_x;
	INDIRECT_E	self,	e_cam,	temp_1;
	INDIRECT_V	temp_1,	angles_x,	temp_5;
	STOREP_V	temp_5_x,	temp_2;
	ADDRESS	self,	view_ofs_x,	temp_2_x;
	INDIRECT_V	self,	origin_x,	temp_5;
	INDIRECT_E	self,	e_cam,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_0;
	SUB_V		temp_5,	temp_0,	temp_0;
	STOREP_V	temp_0_x,	temp_2;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_E	self,	e_cam,	temp_1;
	INDIRECT_V	temp_1,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	v_angle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_2;
	INDIRECT_E	self,	e_cam,	temp_1;
	INDIRECT_V	temp_1,	angles_x,	temp_5;
	SUB_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	INDIRECT_E	self,	e_cam,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_rplas_burn,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.001000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	INDIRECT_F	self,	p_lifetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

float DAT_PRJ_QRFL_IDX;
void () data_prj_qrfl_touch;
void() data_prj_qrfl_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"prj_qrfl",	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	data_prj_qrfl_touch,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_IDX,	temp_1;
	ADDRESS	self,	p_velocity,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_PRJ_QRFL_MODEL,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	effects,	temp_1;
	INDIRECT_F	self,	effects,	temp_3;
	BITOR		temp_3,	DAT_PRJ_QRFL_EFFECTS,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	modelflags,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_MODELFLAGS,	temp_1;
	ADDRESS	self,	alpha,	temp_1;
	STOREP_F	SHVBAL_EFFNON_REDUCE,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	DAT_PRJ_QRFL_COLORMOD_x,	temp_0;
	ADDRESS	self,	glow_color,	temp_1;
	STOREP_F	DAT_PRJ_EMP_GLOWCOLOR,	temp_1;
	ADDRESS	self,	glow_size,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_GLOWSIZE,	temp_1;
	ADDRESS	self,	glow_trail,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_GLOWTRAIL,	temp_1;
	DONE;
}

void() data_prj_qrfl_touch = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		pointcontents;
	EQ_F		return_x,	CONTENT_SKY,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_S	other,	classname,	temp_1;
	EQ_S		temp_1,	"worldspawn",	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		te_superspike;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_E	self,	owner,	temp_1;
	EQ_E		other,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	takedamage,	temp_1;
	IFNOT		temp_1,	13;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_3;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void () data_prj_ion_touch;
void () data_prj_ion_think;
void () data_prj_ion_explode;
void () data_prj_ion_ini;
void() data_prj_ion_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"prj_ion",	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	data_prj_ion_touch,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	p_velocity,	temp_1;
	STOREP_F	DAT_PRJ_ION_VELOCITY,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_PRJ_ION_MODEL,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	effects,	temp_1;
	INDIRECT_F	self,	effects,	temp_3;
	BITOR		temp_3,	4128.000000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	modelflags,	temp_1;
	STOREP_F	DAT_PRJ_ION_MODELFLAGS,	temp_1;
	ADDRESS	self,	alpha,	temp_1;
	STOREP_F	SHVBAL_EFFNON_REDUCE,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	DAT_PRJ_ION_COLORMOD_x,	temp_0;
	ADDRESS	self,	glow_color,	temp_1;
	STOREP_F	DAT_PRJ_EMP_GLOWCOLOR,	temp_1;
	ADDRESS	self,	glow_size,	temp_1;
	STOREP_F	DAT_PRJ_EMP_GLOWSIZE,	temp_1;
	ADDRESS	self,	glow_trail,	temp_1;
	STOREP_F	DAT_PRJ_ION_GLOWTRAIL,	temp_1;
	DONE;
}

void() data_prj_ion_think = asm
{
local float ln;
local entity f;
local entity proxy;
local float explode;
local float dist;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	STORE_F	FALSE,	explode;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	35;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	DAT_PRJ_QRFL_VELOCITY,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	proxy;
	IFNOT		proxy,	30;
	INDIRECT_F	proxy,	takedamage,	temp_1;
	IFNOT		temp_1,	26;
	INDIRECT_F	proxy,	deadflag,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	23;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	proxy,	origin_x,	temp_2;
	INDIRECT_E	self,	owner,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	CALL4		traceline;
	IFNOT		trace_ent,	14;
	INDIRECT_F	trace_ent,	comp_id,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	trace_ent,	owner,	f;
	GOTO		2;
	STORE_ENT	trace_ent,	f;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		trace_endpos,	temp_0,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	ln;
	LE		ln,	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	explode;
	INDIRECT_E	proxy,	chain,	proxy;
	GOTO		-29;
	INDIRECT_F	self,	p_lifetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	explode;
	IFNOT		explode,	4;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_ion_explode,	temp_1;
	GOTO		3;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_ion_think,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_prj_ion_explode = asm
{
local float ln;
local entity lst;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	DAT_PRJ_ABT_CLST_VELOCITY,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	lst;
	IFNOT		lst,	32;
	INDIRECT_F	lst,	takedamage,	temp_1;
	IFNOT		temp_1,	28;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	lst,	origin_x,	temp_2;
	INDIRECT_E	self,	owner,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	CALL4		traceline;
	IFNOT		trace_ent,	19;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		trace_endpos,	temp_0,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	ln;
	LE		ln,	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	IFNOT		temp_1,	13;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_3;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	lst,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	INDIRECT_E	lst,	chain,	lst;
	GOTO		-31;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		te_tarexplosion;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.001000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_prj_ion_touch = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		pointcontents;
	EQ_F		return_x,	CONTENT_SKY,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_S	other,	classname,	temp_1;
	EQ_S		temp_1,	"worldspawn",	temp_1;
	IFNOT		temp_1,	9;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		te_tarexplosion;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_ion_explode,	temp_1;
	RETURN	offset_0;
	INDIRECT_E	self,	owner,	temp_1;
	EQ_E		other,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	takedamage,	temp_1;
	IFNOT		temp_1,	15;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		te_tarexplosion;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_3;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void () data_prj_swrm_think;
void () data_prj_swrm_touch;
void() data_prj_swrm_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"missile",	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	data_prj_swrm_touch,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	p_velocity,	temp_1;
	STOREP_F	DAT_PRJ_RPLAS_VELOCITY,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_PRJ_SWRM_MODEL,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	STOREP_F	RADAR_SWEEP,	temp_1;
	ADDRESS	self,	effects,	temp_1;
	INDIRECT_F	self,	effects,	temp_3;
	BITOR		temp_3,	FL_MONSTER,	temp_3;
	BITOR		temp_3,	FL_JUMPRELEASED,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	modelflags,	temp_1;
	STOREP_F	DAT_PRJ_SWRM_MODELFLAGS,	temp_1;
	ADDRESS	self,	alpha,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	DAT_PRJ_SWRM_COLORMOD_x,	temp_0;
	ADDRESS	self,	glow_color,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	glow_size,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	glow_trail,	temp_1;
	STOREP_F	DAT_PRJ_SWRM_GLOWTRAIL,	temp_1;
	DONE;
}

void() data_prj_swrm_think = asm
{
local float locked_2939;
local vector ph;
local vector vels;
local vector vele;
local float temp_1;
local vector temp_2;
local float temp_3;
local vector temp_5;
	INDIRECT_F	self,	p_lifetime,	temp_1;
	GE		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	CALL0		BecomeExplosion;
	RETURN	offset_0;
	INDIRECT_F	self,	movetype,	temp_1;
	NE_F		temp_1,	MOVETYPE_BOUNCE,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	locked_2939;
	ADD_V		locked_2939,	'0.000000 0.000000 16.000000',	locked_2939;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		locked_2939,	temp_2,	vele;
	STORE_V	vele,	parm0;
	CALL1		normalize;
	STORE_V	return,	vele;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		normalize;
	STORE_V	return,	vels;
	INDIRECT_V	self,	origin_x,	locked_2939;
	INDIRECT_V	self,	origin_x,	temp_2;
	MUL_VF	vele,	DAT_BLD_H_SM_RADAR_RADAR_RANGE,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	STORE_V	locked_2939,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	NE_F		trace_fraction,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	self,	enemy,	temp_3;
	NE_E		temp_3,	world,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	15;
	ADD_V		vele,	vels,	locked_2939;
	ADD_V		locked_2939,	vels,	locked_2939;
	ADD_V		locked_2939,	vels,	locked_2939;
	ADD_V		locked_2939,	vels,	ph;
	MUL_VF	ph,	DAT_LATC_RL_RATE,	ph;
	ADDRESS	self,	velocity_x,	locked_2939;
	ADD_V		vels,	ph,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	temp_2;
	INDIRECT_F	self,	p_velocity,	temp_1;
	MUL_VF	temp_2,	temp_1,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	angles_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	aflag,	temp_1;
	INDIRECT_F	self,	aflag,	temp_3;
	ADD_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	aflag,	temp_1;
	GE		temp_1,	DAT_OTL_CTOR_HP,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	world,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_swrm_think,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_prj_swrm_touch = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		pointcontents;
	EQ_F		return_x,	CONTENT_SKY,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_S	other,	classname,	temp_1;
	EQ_S		temp_1,	"worldspawn",	temp_1;
	IFNOT		temp_1,	3;
	CALL0		BecomeExplosion;
	RETURN	offset_0;
	INDIRECT_E	self,	owner,	temp_1;
	EQ_E		other,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	takedamage,	temp_1;
	IFNOT		temp_1,	19;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_3;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	INDIRECT_F	other,	sh_cur,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	CALL0		BecomeExplosion;
	DONE;
}

float DAT_LATC_HPX;
void () data_latc_atk;
void () data_latc_think;
void() data_latc_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_LATC_NAME,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	TRUE,	temp_3;
	BITOR		temp_3,	FL_CLIENT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	DAT_LATC_DMG,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_LATC_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_LATC_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_latc_atk,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	DAT_LATC_RL_RATE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	DAT_LATC_RL_RATE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	DAT_LATC_RL_RATE,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_LATC_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_latc_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_LATC_RANGE,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_LATC_ACC_x,	temp_0;
	DONE;
}

void() data_latc_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		19;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_latc_atk = asm
{
local entity bul_fx;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity proj;
local entity player;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_V	self,	c_ofs_x,	temp_0;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		temp_0,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	temp_0;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	15;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		7;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	w_firerate,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	IFNOT		trace_ent,	22;
	INDIRECT_F	self,	p_damage,	temp_1;
	STORE_F	trace_ent,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	player,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	STORE_V	dir,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	INDIRECT_F	trace_ent,	sh_cur,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	STORE_V	dir,	parm0;
	CALL1		te_superspike;
	CALL0		spawn;
	STORE_ENT	return_x,	bul_fx;
	ADDRESS	bul_fx,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	bul_fx,	solid,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	bul_fx,	classname,	temp_1;
	STOREP_S	"missile",	temp_1;
	STORE_F	bul_fx,	parm0_x;
	STORE_F	"progs/muzzleflash.spr32",	parm1_x;
	CALL2		setmodel;
	STORE_F	bul_fx,	parm0_x;
	STORE_V	'-1.000000 -1.000000 -1.000000',	parm1;
	STORE_V	'1.000000 1.000000 1.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	MUL_VF	v_forward,	MOVETYPE_FLY,	temp_0;
	ADD_V		org,	temp_0,	temp_0;
	STORE_F	bul_fx,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	bul_fx,	alpha,	temp_1;
	STOREP_F	0.850000,	temp_1;
	ADDRESS	bul_fx,	glow_color,	temp_1;
	STOREP_F	DAT_PAC_DMG,	temp_1;
	ADDRESS	bul_fx,	glow_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	bul_fx,	glow_trail,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	bul_fx,	color_x,	temp_0_x;
	STOREP_V	'1.000000 0.000000 0.000000',	temp_0;
	ADDRESS	bul_fx,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	bul_fx,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

float DAT_FLAK_HPX;
void () data_flak_atk;
void () data_flak_think;
void() data_flak_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_FOLLOW,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_FLAK_NAME,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	0.500000,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_FLAK_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_FLAK_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_flak_atk,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	DAT_FLAK_RL_RATE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_FLAK_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_flak_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_PRJ_ION_VELOCITY,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_FLAK_ACC_x,	temp_0;
	DONE;
}

void() data_flak_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		19;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_flak_atk = asm
{
local float locked_2939;
local entity bul_fx;
local float totes;
local float d;
local vector v;
local vector ang;
local entity boom;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity enm;
local entity this;
local entity oself;
local entity player;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_V	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	locked_2939,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	STORE_ENT	trace_ent,	enm;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	17;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		20;
	INDIRECT_F	self,	flags,	temp_1;
	MUL_F		temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	8;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	DIV_F		temp_3,	MOVETYPE_BOUNCE,	temp_3;
	DIV_F		temp_3,	SHVBAL_EFFRAM_PERCENTAGE,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		6;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	DIV_F		temp_3,	FL_SWIM,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	TRUE,	temp_1;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_V	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	player,	origin_x,	locked_2939;
	MUL_VF	v_up,	adj_y,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	MUL_VF	v_right,	adj_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	MUL_VF	v_forward,	adj_z,	temp_2;
	ADD_V		locked_2939,	temp_2,	org;
	IFNOT		enm,	2;
	NE_E		enm,	world,	temp_1;
	AND		enm,	temp_1,	temp_1;
	IFNOT		temp_1,	85;
	STORE_F	DPCONTENTS_LIQUIDSMASK,	totes;
	INDIRECT_F	enm,	sh_cur,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_3;
	MUL_F		temp_3,	totes,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	14;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_3;
	MUL_F		temp_3,	totes,	temp_3;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	STORE_F	enm,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	trace_endpos,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	GOTO		65;
	GT		totes,	FALSE,	temp_1;
	IFNOT		temp_1,	51;
	INDIRECT_V	enm,	origin_x,	locked_2939;
	SUB_V		locked_2939,	dir,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	d;
	INDIRECT_V	enm,	origin_x,	locked_2939;
	SUB_V		locked_2939,	dir,	parm0;
	CALL1		vectoangles;
	STORE_V	return,	ang;
	STORE_V	ang,	parm0;
	CALL1		makevectors;
	MUL_VF	v_forward,	d,	locked_2939;
	ADD_V		dir,	locked_2939,	locked_2939;
	CALL0		crandom;
	STORE_F	return_x,	temp_1;
	CALL0		random;
	STORE_F	return_x,	temp_3;
	STORE_F	temp_1,	return_x;
	MUL_F		temp_3,	TE_BLOOD,	temp_1;
	DIV_F		temp_1,	MOVETYPE_WALK,	temp_1;
	MUL_F		return_x,	temp_1,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	CALL0		crandom;
	STORE_F	return_x,	temp_1;
	CALL0		random;
	STORE_F	return_x,	temp_3;
	STORE_F	temp_1,	return_x;
	MUL_F		temp_3,	TE_BLOOD,	temp_1;
	DIV_F		temp_1,	MOVETYPE_WALK,	temp_1;
	MUL_F		return_x,	temp_1,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		locked_2939,	temp_2,	v;
	STORE_V	dir,	parm0;
	STORE_V	v,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_3;
	INDIRECT_F	self,	p_dmgtype,	temp_4;
	STORE_F	enm,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	STORE_F	temp_4,	parm4_x;
	STORE_V	trace_endpos,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	SUB_F		totes,	TRUE,	totes;
	GOTO		-51;
	CALL0		spawn;
	STORE_ENT	return_x,	boom;
	ADDRESS	boom,	color_x,	locked_2939;
	STOREP_V	DAT_PRJ_FLAK_COLORMOD_x,	locked_2939;
	STORE_F	boom,	parm0_x;
	STORE_V	dir,	parm1;
	CALL2		setorigin;
	ADDRESS	boom,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	boom,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	GOTO		13;
	CALL0		spawn;
	STORE_ENT	return_x,	boom;
	ADDRESS	boom,	color_x,	locked_2939;
	STOREP_V	DAT_PRJ_FLAK_COLORMOD_x,	locked_2939;
	STORE_F	boom,	parm0_x;
	STORE_V	dir,	parm1;
	CALL2		setorigin;
	ADDRESS	boom,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	boom,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	CALL0		spawn;
	STORE_ENT	return_x,	bul_fx;
	ADDRESS	bul_fx,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	bul_fx,	solid,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	bul_fx,	classname,	temp_1;
	STOREP_S	"missile",	temp_1;
	STORE_F	bul_fx,	parm0_x;
	STORE_F	"progs/muzzleflash.spr32",	parm1_x;
	CALL2		setmodel;
	STORE_F	bul_fx,	parm0_x;
	STORE_V	'-1.000000 -1.000000 -1.000000',	parm1;
	STORE_V	'1.000000 1.000000 1.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	MUL_VF	v_forward,	MOVETYPE_FLY,	locked_2939;
	ADD_V		org,	locked_2939,	locked_2939;
	STORE_F	bul_fx,	parm0_x;
	STORE_V	locked_2939,	parm1;
	CALL2		setorigin;
	ADDRESS	bul_fx,	alpha,	temp_1;
	STOREP_F	0.850000,	temp_1;
	ADDRESS	bul_fx,	glow_color,	temp_1;
	STOREP_F	DAT_PAC_DMG,	temp_1;
	ADDRESS	bul_fx,	glow_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	bul_fx,	glow_trail,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	bul_fx,	color_x,	locked_2939;
	STOREP_V	'1.000000 0.000000 0.000000',	locked_2939;
	ADDRESS	bul_fx,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	bul_fx,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

float DAT_SFGA_HPX;
void () data_sfga_atk;
void () data_sfga_think;
void() data_sfga_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_BOUNCEMISSILE,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_SFGA_NAME,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	TRUE,	temp_3;
	BITOR		temp_3,	FL_ONGROUND,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	DAT_SFGA_DMG,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_SFGA_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_SFGA_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_sfga_atk,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	DAT_SFGA_PROJ_ID,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	0.100000,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_SFGA_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_sfga_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_QRFL_RANGE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_SFGA_ACC_x,	temp_0;
	DONE;
}

void() data_sfga_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		19;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_sfga_atk = asm
{
local float locked_2939;
local entity bul_fx;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity proj;
local entity player;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_V	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	locked_2939,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	15;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		7;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	w_firerate,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	self,	oself;
	STORE_ENT	newmis,	self;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	player,	temp_1;
	INDIRECT_F	oself,	w_proj,	parm0_x;
	CALL1		data_iniProjectile;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	oself,	p_dmgtype,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	INDIRECT_F	oself,	p_damage,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	velocity_x,	locked_2939;
	SUB_V		dir,	org,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	temp_2;
	INDIRECT_F	self,	p_velocity,	temp_1;
	MUL_VF	temp_2,	temp_1,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	velocity_z,	temp_1;
	INDIRECT_F	self,	velocity_z,	temp_3;
	ADD_F		temp_3,	DAT_PRJ_QRFL_VELOCITY,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	velocity_z,	temp_1;
	INDIRECT_F	self,	velocity_z,	temp_3;
	ADD_F		temp_3,	DAT_PRJ_QRFL_VELOCITY,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	p_lifetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	MOVETYPE_BOUNCE,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	STORE_F	self,	parm0_x;
	STORE_V	org,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	angles_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2939;
	STORE_ENT	oself,	self;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	player,	punchangle_x,	locked_2939;
	CALL0		randomvec;
	STOREP_V	return_x,	locked_2939;
	CALL0		spawn;
	STORE_ENT	return_x,	bul_fx;
	ADDRESS	bul_fx,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	bul_fx,	classname,	temp_1;
	STOREP_S	"missile",	temp_1;
	STORE_F	bul_fx,	parm0_x;
	STORE_F	"progs/muzzleflash.spr32",	parm1_x;
	CALL2		setmodel;
	STORE_F	bul_fx,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	fx_origin_x,	locked_2939;
	STORE_F	bul_fx,	parm0_x;
	STORE_V	locked_2939,	parm1;
	CALL2		setorigin;
	ADDRESS	bul_fx,	glow_color,	temp_1;
	STOREP_F	DAT_PAC_DMG,	temp_1;
	ADDRESS	bul_fx,	glow_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	bul_fx,	glow_trail,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	bul_fx,	color_x,	locked_2939;
	STOREP_V	'1.000000 0.000000 0.000000',	locked_2939;
	ADDRESS	bul_fx,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	bul_fx,	nextthink,	temp_1;
	ADD_F		time,	0.001000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

float DAT_EMP_HPX;
void () data_emp_atk;
void () data_emp_think;
void() data_emp_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_EMP_NAME,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_EMP_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_EMP_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_emp_atk,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	DAT_EMP_PROJ_ID,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	0.100000,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	DAT_EMP_EN_RATE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_EMP_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_emp_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	FL_SWIM,	temp_3;
	BITOR		temp_3,	FL_MONSTER,	temp_3;
	BITOR		temp_3,	FL_ITEM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_EMP_RANGE,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	DAT_SFGA_DMG,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_EMP_ACC_x,	temp_0;
	DONE;
}

void() data_emp_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		19;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_emp_atk = asm
{
local float locked_2939;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity proj;
local entity player;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_F	self,	en_rate,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	GE		temp_3,	temp_4,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	player,	en_cur,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_1;
	LT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	player,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		2;
	RETURN	offset_0;
	INDIRECT_V	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	locked_2939,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	15;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		7;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	w_firerate,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	self,	oself;
	STORE_ENT	newmis,	self;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	player,	temp_1;
	INDIRECT_F	oself,	w_proj,	parm0_x;
	CALL1		data_iniProjectile;
	ADDRESS	self,	velocity_x,	locked_2939;
	SUB_V		dir,	org,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	oself,	p_dmgtype,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	INDIRECT_F	oself,	p_damage,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	INDIRECT_F	self,	p_lifetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	ADD_F		time,	0.500000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	temp_2;
	INDIRECT_F	self,	p_velocity,	temp_1;
	MUL_VF	temp_2,	temp_1,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	angles_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_emp_think,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	MOVETYPE_FLYMISSILE,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	STORE_F	self,	parm0_x;
	STORE_V	org,	parm1;
	CALL2		setorigin;
	STORE_ENT	oself,	self;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

float DAT_ION_HPX;
void () data_ion_atk;
void () data_ion_think;
void () data_ion_ini;
void() data_ion_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	IMP_SWEAPON1,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_ION_NAME,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_ION_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_ION_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_ion_atk,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	DAT_ION_PROJ_ID,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	DAT_ION_RL_RATE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	DAT_ION_EN_RATE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_ION_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_ion_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	FL_SWIM,	temp_3;
	BITOR		temp_3,	FL_MONSTER,	temp_3;
	BITOR		temp_3,	FL_ITEM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_LATC_RANGE,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	TE_PLASMABURN,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_ION_ACC_x,	temp_0;
	DONE;
}

void() data_ion_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		19;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_ion_atk = asm
{
local float locked_2939;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity proj;
local entity player;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_F	self,	en_rate,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	GE		temp_3,	temp_4,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	player,	en_cur,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_1;
	LT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	player,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		2;
	RETURN	offset_0;
	INDIRECT_V	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	locked_2939,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	17;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		10;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	MUL_F		temp_3,	SHVBAL_EFFRAM_PERCENTAGE,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	TRUE,	temp_1;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	self,	oself;
	STORE_ENT	newmis,	self;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	player,	temp_1;
	INDIRECT_F	oself,	w_proj,	parm0_x;
	CALL1		data_iniProjectile;
	ADDRESS	self,	velocity_x,	locked_2939;
	SUB_V		dir,	org,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	oself,	p_dmgtype,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	INDIRECT_F	oself,	p_damage,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	INDIRECT_F	self,	p_lifetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	ADD_F		time,	0.500000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	temp_2;
	INDIRECT_F	self,	p_velocity,	temp_1;
	MUL_VF	temp_2,	temp_1,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	angles_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_ion_think,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	MOVETYPE_FLYMISSILE,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	STORE_F	self,	parm0_x;
	STORE_V	org,	parm1;
	CALL2		setorigin;
	STORE_ENT	oself,	self;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

float DAT_MIS_HPX;
void () data_mis_atk;
void () data_mis_think;
void() data_mis_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_MIS_NAME,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_MIS_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MIS_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_mis_atk,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	DAT_MIS_PROJ_ID,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	DAT_MIS_RL_RATE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_MIS_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_mis_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_PRJ_ABT_VELOCITY,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	MOVETYPE_STEP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	TE_PLASMABURN,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_MIS_ACC_x,	temp_0;
	DONE;
}

void() data_mis_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	9;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		17;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	14;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_mis_atk = asm
{
local float locked_2939;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity proj;
local entity player;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_V	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	locked_2939,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	MUL_VF	v_forward,	TRUE,	locked_2939;
	ADD_V		org,	locked_2939,	locked_2939;
	SUB_V		dir,	org,	parm0;
	CALL1		normalize;
	INDIRECT_V	player,	velocity_x,	temp_2;
	STORE_V	locked_2939,	parm0;
	STORE_V	return,	parm1;
	STORE_V	temp_2,	parm2;
	STORE_F	STAT_PLR_NAME,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		te_muzzle_generic;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	17;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		20;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	8;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	DIV_F		temp_3,	SHVBAL_EFFRAM_PERCENTAGE,	temp_3;
	MUL_F		temp_3,	2.250000,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		6;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	DIV_F		temp_3,	SHVENE_EFFRAM_PERCENTAGE,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	player,	punchangle_x,	temp_1;
	CALL0		random;
	MUL_F		return_x,	CONTENT_SOLID,	temp_3;
	ADD_F		CONTENT_SOLID,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	player,	punchangle_y,	temp_1;
	CALL0		random;
	MUL_F		return_x,	CONTENT_SLIME,	temp_3;
	ADD_F		CONTENT_WATER,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	self,	oself;
	STORE_ENT	newmis,	self;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	player,	temp_1;
	INDIRECT_F	oself,	w_proj,	parm0_x;
	CALL1		data_iniProjectile;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	oself,	p_dmgtype,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	INDIRECT_F	oself,	p_damage,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	INDIRECT_S	self,	c_model,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	STORE_F	self,	parm0_x;
	STORE_V	org,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	velocity_x,	locked_2939;
	SUB_V		dir,	org,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	temp_2;
	INDIRECT_F	self,	p_velocity,	temp_1;
	MUL_VF	temp_2,	temp_1,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	angles_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	oself,	origin_x,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	power_timer,	temp_1;
	INDIRECT_F	self,	p_lifetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_ENT	oself,	self;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

void () data_las_atk;
void () data_las_think;
void() data_las_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	FL_SWIM,	temp_3;
	BITOR		temp_3,	FL_MONSTER,	temp_3;
	BITOR		temp_3,	FL_ITEM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_LAS_NAME,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_LAS_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_LAS_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_las_atk,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	DAT_LAS_EN_RATE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	DAT_LAS_RL_RATE,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	DAT_LAS_RL_RATE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_LAS_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_las_think,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	ADDRESS	self,	health,	temp_3;
	STOREP_F	TRUE,	temp_3;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_PRJ_ION_VELOCITY,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_LAS_ACC_x,	temp_0;
	DONE;
}

void() data_las_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		19;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_las_atk = asm
{
local entity laser_org;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity proj;
local entity player;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
local vector temp_5;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_F	self,	en_rate,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	GE		temp_3,	temp_4,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	player,	en_cur,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_1;
	LT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	player,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		2;
	RETURN	offset_0;
	INDIRECT_V	self,	c_ofs_x,	temp_0;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		temp_0,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	temp_0;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	15;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		7;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	w_firerate,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	CALL0		spawn;
	STORE_ENT	return_x,	laser_org;
	ADDRESS	laser_org,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	laser_org,	classname,	temp_1;
	STOREP_S	"missile",	temp_1;
	STORE_F	laser_org,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	STORE_F	laser_org,	parm0_x;
	STORE_V	org,	parm1;
	CALL2		setorigin;
	ADDRESS	laser_org,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	laser_org,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_V	laser_org,	origin_x,	parm0;
	STORE_V	dir,	parm1;
	CALL2		te_beam_laser;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	laser_org,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	player,	angles_x,	temp_2;
	INDIRECT_V	player,	velocity_x,	temp_5;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_V	temp_5,	parm2;
	STORE_F	STAT_PLR_ANG_Y,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		te_muzzle_generic;
	INDIRECT_F	self,	p_damage,	temp_1;
	STORE_F	trace_ent,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	player,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	FL_SWIM,	parm4_x;
	STORE_V	dir,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	INDIRECT_F	trace_ent,	sh_cur,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	11;
	MUL_VF	v_forward,	CONTENT_SLIME,	temp_0;
	ADD_V		dir,	temp_0,	temp_0;
	CALL0		random;
	MUL_F		return_x,	MOVETYPE_STEP,	temp_1;
	INDIRECT_F	self,	takedamage,	temp_3;
	GT		temp_3,	FALSE,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_1,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	CALL3		te_laser_hit;
	DONE;
}

float DAT_MLGD_HPX;
void () data_mlgd_atk;
void () data_mlgd_think;
void() data_mlgd_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_MLGD_NAME,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	MOVETYPE_STEP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	DAT_MLGD_DMG,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_MLGD_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MLGD_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_mlgd_atk,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	DAT_MLGD_PROJ_ID,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	DAT_LATC_RL_RATE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_MLGD_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_mlgd_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_MLGD_HPX,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_MLGD_HPX,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_RPLAS_RANGE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_LGM_ACC_x,	temp_0;
	DONE;
}

void() data_mlgd_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	9;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		17;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	14;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_mlgd_atk = asm
{
local float locked_2939;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity proj;
local entity player;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_F	self,	en_rate,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	GE		temp_3,	temp_4,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	player,	en_cur,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_1;
	LT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	player,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		2;
	RETURN	offset_0;
	INDIRECT_V	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	locked_2939,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	15;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		7;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	self,	oself;
	STORE_ENT	newmis,	self;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	player,	temp_1;
	INDIRECT_F	oself,	w_proj,	parm0_x;
	CALL1		data_iniProjectile;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	oself,	p_dmgtype,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	INDIRECT_F	oself,	p_damage,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	velocity_x,	locked_2939;
	SUB_V		dir,	org,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_mlgd_th,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	INDIRECT_F	self,	p_lifetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	MOVETYPE_FLYMISSILE,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	STORE_F	self,	parm0_x;
	STORE_V	org,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	temp_2;
	INDIRECT_F	self,	p_velocity,	temp_1;
	MUL_VF	temp_2,	temp_1,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	angles_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2939;
	STORE_ENT	oself,	self;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

float DAT_MARH_HPX;
void () data_marh_atk;
void () data_marh_think;
void() data_marh_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	MOVETYPE_STEP,	temp_3;
	BITOR		temp_3,	FL_ONGROUND,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_MARH_NAME,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_MARH_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MARH_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_marh_atk,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	DAT_MARH_PROJ_ID,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	DAT_MARH_RL_RATE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_MARH_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_marh_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_MARH_ACC_x,	temp_0;
	DONE;
}

void() data_marh_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		19;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_marh_atk = asm
{
local float locked_2939;
local vector start;
local vector arc;
local float dist;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity cam;
local entity proj;
local entity player;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	player,	stat_rdr_mode,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	179;
	INDIRECT_F	player,	stat_lck_stt,	temp_1;
	BITAND	temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	176;
	INDIRECT_V	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	locked_2939,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	17;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		17;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		5;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	TRUE,	temp_1;
	SUB_V		dir,	org,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	dist;
	CALL0		crandom;
	MUL_F		return_x,	20.000000,	temp_1;
	ADD_F		DAT_PRJ_ABT_CLST_VELOCITY,	temp_1,	temp_1;
	MUL_VF	v_forward,	temp_1,	locked_2939;
	ADD_V		org,	locked_2939,	arc;
	CALL0		crandom;
	MUL_F		return_x,	20.000000,	temp_1;
	ADD_F		DAT_PRJ_ABT_CLST_VELOCITY,	temp_1,	temp_1;
	MUL_VF	v_up,	temp_1,	locked_2939;
	ADD_V		arc,	locked_2939,	locked_2939;
	CALL0		crandom;
	MUL_F		return_x,	20.000000,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		locked_2939,	temp_2,	arc;
	CALL0		crandom;
	MUL_F		return_x,	20.000000,	temp_1;
	MUL_VF	v_right,	temp_1,	locked_2939;
	ADD_V		arc,	locked_2939,	arc;
	CALL0		crandom;
	MUL_F		return_x,	FL_SWIM,	temp_1;
	MUL_FV	temp_1,	v_right,	locked_2939;
	ADD_V		org,	locked_2939,	locked_2939;
	CALL0		crandom;
	MUL_F		return_x,	MOVETYPE_STEP,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		locked_2939,	temp_2,	start;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	self,	oself;
	STORE_ENT	newmis,	self;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	player,	temp_1;
	INDIRECT_F	oself,	w_proj,	parm0_x;
	CALL1		data_iniProjectile;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	oself,	p_dmgtype,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	INDIRECT_F	oself,	p_damage,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	enemy,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_E	temp_3,	enemy,	temp_3;
	STOREP_ENT	temp_3,	temp_1;
	ADDRESS	self,	c_ofs_x,	locked_2939;
	STOREP_V	arc_x,	locked_2939;
	ADDRESS	self,	p_lifetime,	temp_1;
	INDIRECT_F	self,	p_lifetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	MOVETYPE_FLYMISSILE,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	STORE_F	self,	parm0_x;
	STORE_V	start,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	velocity_x,	locked_2939;
	SUB_V		arc,	start,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	temp_2;
	INDIRECT_F	self,	p_velocity,	temp_1;
	MUL_VF	temp_2,	temp_1,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	angles_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_marh_th,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_S	oself,	fire_sound,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	STORE_ENT	oself,	self;
	DONE;
}

float DAT_RPLAS_HPX;
float DAT_RPLAS_SHOT;
void () data_rplas_atk;
void () data_rplas_think;
void() data_rplas_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_RPC_NAME,	temp_1;
	ADDRESS	self,	w_isready,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	TRUE,	temp_3;
	BITOR		temp_3,	FL_CLIENT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	DAT_RPLAS_DMG,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_RPLAS_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	"progs/casing.mdl",	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_rplas_atk,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	DAT_RPLAS_PROJ_ID,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	ARM_HV_MOD,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	DAT_RPLAS_EN_RATE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_RPLAS_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_rplas_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_RPLAS_RANGE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_RPC_ACC_x,	temp_0;
	DONE;
}

void() data_rplas_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		19;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_rplas_atk = asm
{
local float locked_2939;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity player;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_F	self,	en_rate,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	GE		temp_3,	temp_4,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	player,	en_cur,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_1;
	LT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	player,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		2;
	RETURN	offset_0;
	INDIRECT_V	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	locked_2939,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	17;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		20;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	8;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	DIV_F		temp_3,	SHVBAL_EFFRAM_PERCENTAGE,	temp_3;
	MUL_F		temp_3,	FL_SWIM,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		6;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	DIV_F		temp_3,	SHVBAL_EFFRAM_PERCENTAGE,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	TRUE,	temp_1;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_V	player,	angles_x,	locked_2939;
	INDIRECT_V	player,	velocity_x,	temp_2;
	STORE_V	org,	parm0;
	STORE_V	locked_2939,	parm1;
	STORE_V	temp_2,	parm2;
	STORE_F	TE_RPC_MUZZLE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		te_muzzle_generic;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	self,	oself;
	STORE_ENT	newmis,	self;
	STORE_F	self,	parm0_x;
	CALL1		num_for_edict;
	STORE_F	"plas #",	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		cons_logAFloat;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	player,	temp_1;
	INDIRECT_F	oself,	w_proj,	parm0_x;
	CALL1		data_iniProjectile;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	oself,	p_dmgtype,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	INDIRECT_F	oself,	p_damage,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"missile",	temp_1;
	ADDRESS	self,	velocity_x,	locked_2939;
	SUB_V		dir,	org,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	temp_2;
	INDIRECT_F	self,	p_velocity,	temp_1;
	MUL_VF	temp_2,	temp_1,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	angles_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	p_lifetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_S	self,	c_model,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	STORE_F	self,	parm0_x;
	STORE_V	org,	parm1;
	CALL2		setorigin;
	STORE_ENT	oself,	self;
	DONE;
}

float DAT_QRFL_HPX;
float DAT_QRFL_QBITS;
void () data_qrfl_atk;
void () data_qrfl_think;
void() data_qrfl_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_QRF_NAME,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	TRUE,	temp_3;
	BITOR		temp_3,	FL_MONSTER,	temp_3;
	BITOR		temp_3,	FL_ITEM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_QRFL_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_QRFL_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_qrfl_atk,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	DAT_QRFL_PROJ_ID,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	0.100000,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_QRFL_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_qrfl_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_QRFL_RANGE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_QRFL_ACC_x,	temp_0;
	DONE;
}

void() data_qrfl_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		19;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_qrfl_atk = asm
{
local float locked_2932;
local float locked_2939;
local vector rando;
local float qbits;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity proj;
local entity player;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	self,	w_currentammo,	locked_2932;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	EQ_F		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	20;
	INDIRECT_F	self,	en_rate,	locked_2932;
	IFNOT		locked_2932,	4;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	GE		temp_3,	temp_4,	temp_3;
	AND		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	12;
	ADDRESS	player,	en_cur,	locked_2932;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	player,	en_cur,	locked_2932;
	LT		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	player,	en_cur,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	GOTO		2;
	RETURN	offset_0;
	INDIRECT_V	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	locked_2932;
	BITAND	locked_2932,	FL_MONSTER,	locked_2932;
	IFNOT		locked_2932,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	7;
	INDIRECT_F	self,	w_range,	locked_2932;
	STORE_F	player,	parm0_x;
	STORE_F	locked_2932,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	locked_2932;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	locked_2932,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	locked_2932;
	STORE_V	locked_2939,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	locked_2932,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	locked_2932;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	w_currentammo,	locked_2932;
	LE		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	15;
	ADDRESS	self,	rl_cur,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	ADDRESS	self,	w_currentammo,	locked_2932;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	w_state,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	ADDRESS	self,	w_firetime,	locked_2932;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	count1,	locked_2932;
	STOREP_F	time,	locked_2932;
	GOTO		7;
	ADDRESS	self,	w_firetime,	locked_2932;
	INDIRECT_F	self,	w_firerate,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	w_state,	locked_2932;
	STOREP_F	MOVETYPE_STEP,	locked_2932;
	STORE_F	FL_CLIENT,	qbits;
	GT		qbits,	FALSE,	locked_2932;
	IFNOT		locked_2932,	73;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	self,	oself;
	STORE_ENT	newmis,	self;
	ADDRESS	self,	owner,	locked_2932;
	STOREP_ENT	player,	locked_2932;
	INDIRECT_F	oself,	w_proj,	parm0_x;
	CALL1		data_iniProjectile;
	CALL0		randomvec;
	STORE_V	return,	rando;
	ADD_F		dir_x,	rando_x,	locked_2932;
	CALL0		crandom;
	MUL_F		return_x,	STAT_PLR_ANG_X,	temp_3;
	ADD_F		TE_BLOOD,	temp_3,	temp_3;
	ADD_F		locked_2932,	temp_3,	rando_x;
	ADD_F		dir_y,	rando_y,	locked_2932;
	CALL0		crandom;
	MUL_F		return_x,	STAT_PLR_ANG_X,	temp_3;
	ADD_F		TE_BLOOD,	temp_3,	temp_3;
	ADD_F		locked_2932,	temp_3,	rando_y;
	ADD_F		dir_z,	rando_z,	locked_2932;
	CALL0		crandom;
	MUL_F		return_x,	STAT_PLR_ANG_X,	temp_3;
	ADD_F		TE_BLOOD,	temp_3,	temp_3;
	ADD_F		locked_2932,	temp_3,	rando_z;
	ADDRESS	self,	p_dmgtype,	locked_2932;
	INDIRECT_F	oself,	p_dmgtype,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	p_damage,	locked_2932;
	INDIRECT_F	oself,	p_damage,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	velocity_x,	locked_2939;
	SUB_V		dir,	rando,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	SUB_Remove,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	INDIRECT_F	self,	p_lifetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	temp_2;
	INDIRECT_F	self,	p_velocity,	locked_2932;
	MUL_VF	temp_2,	locked_2932,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	angles_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2939;
	STORE_V	rando,	parm0;
	CALL1		pointcontents;
	NE_F		return_x,	CONTENT_SOLID,	locked_2932;
	IFNOT		locked_2932,	17;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	MOVETYPE_FLYMISSILE,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	STORE_F	self,	parm0_x;
	STORE_V	rando,	parm1;
	CALL2		setorigin;
	SUB_F		qbits,	TRUE,	qbits;
	STORE_ENT	oself,	self;
	GOTO		-73;
	INDIRECT_S	self,	fire_sound,	locked_2932;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	locked_2932,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

float DAT_ESR_HPX;
void () data_esr_atk;
void () data_esr_think;
void() data_esr_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_ESR_NAME,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	FL_SWIM,	temp_3;
	BITOR		temp_3,	FL_ITEM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	IMP_SHOWOBJ,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	20.000000,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	20.000000,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_ESR_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_ESR_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_esr_atk,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	DAT_ESR_RL_RATE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_ESR_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_esr_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_PRJ_MLGD_VELOCITY,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_ESR_ACC_x,	temp_0;
	DONE;
}

void() data_esr_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		19;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_esr_atk = asm
{
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity this;
local entity oself;
local entity proj;
local entity player;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_F	self,	en_rate,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	GE		temp_3,	temp_4,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	player,	en_cur,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_1;
	LT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	player,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		2;
	RETURN	offset_0;
	INDIRECT_V	self,	c_ofs_x,	temp_0;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		temp_0,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	temp_0;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	17;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		9;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	TRUE,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_1;
	STORE_F	trace_ent,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	player,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	FL_SWIM,	parm4_x;
	STORE_V	dir,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	STORE_ENT	self,	this;
	CALL0		spawn;
	STORE_ENT	return_x,	proj;
	STORE_ENT	proj,	self;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"missile",	temp_1;
	INDIRECT_V	this,	angles_x,	parm0;
	CALL1		makevectors;
	MUL_VF	v_forward,	FL_SWIM,	temp_0;
	ADD_V		org,	temp_0,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	ADDRESS	self,	scale,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_ENT	this,	self;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	proj,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_V	proj,	origin_x,	parm0;
	STORE_V	dir,	parm1;
	CALL2		te_beam_esr;
	STORE_V	dir,	parm0;
	STORE_V	'0.000000 15.000000 0.000000',	parm1;
	STORE_F	MOVETYPE_FLY,	parm2_x;
	CALL3		te_flamejet;
	STORE_V	dir,	parm0;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	MOVETYPE_BOUNCE,	parm2_x;
	STORE_V	'0.000000 0.000000 1.000000',	parm3;
	CALL4		te_customflash;
	DONE;
}

float DAT_PAC_HPX;
void () data_pac_atk;
void () data_pac_think;
void() data_pac_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_PAC_NAME,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	DAT_PAC_DMG,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	FL_SWIM,	temp_3;
	BITOR		temp_3,	FL_CLIENT,	temp_3;
	BITOR		temp_3,	FL_ITEM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_PAC_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_PAC_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_pac_atk,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	0.100000,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	DAT_PAC_EN_RATE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_PAC_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_pac_think,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_PAC_RANGE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_PAC_ACC_x,	temp_0;
	DONE;
}

void() data_pac_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	9;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		17;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	14;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_pac_atk = asm
{
local entity laser_org;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity proj;
local entity player;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_F	self,	en_rate,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	GE		temp_3,	temp_4,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	player,	en_cur,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	player,	en_cur,	temp_1;
	LT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	player,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		2;
	RETURN	offset_0;
	INDIRECT_V	self,	c_ofs_x,	temp_0;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		temp_0,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	temp_0;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	15;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		7;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	w_firerate,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	CALL0		spawn;
	STORE_ENT	return_x,	laser_org;
	ADDRESS	laser_org,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	laser_org,	solid,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	laser_org,	classname,	temp_1;
	STOREP_S	"missile",	temp_1;
	STORE_F	laser_org,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	MUL_VF	v_forward,	DAT_PAC_FIRE_OFS_z,	temp_0;
	ADD_V		org,	temp_0,	temp_0;
	STORE_F	laser_org,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	INDIRECT_F	self,	p_damage,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	MUL_VF	v_forward,	MOVETYPE_WALK,	temp_0;
	ADD_V		dir,	temp_0,	temp_0;
	STORE_F	trace_ent,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	player,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	temp_3,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	laser_org,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	STORE_V	org,	parm0;
	STORE_V	dir,	parm1;
	CALL2		te_beam_pac;
	STORE_V	dir,	parm0;
	STORE_V	'0.000000 25.000000 0.000000',	parm1;
	STORE_F	MOVETYPE_FLY,	parm2_x;
	CALL3		te_flamejet;
	STORE_V	dir,	parm0;
	CALL1		te_plasmaburn;
	ADDRESS	laser_org,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	laser_org,	nextthink,	temp_1;
	ADD_F		time,	0.011000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

float DAT_SWRM_HPX;
void () data_swrm_atk;
void () data_swrm_think;
void() data_swrm_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	DPCONTENTS_LIQUIDSMASK,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_SWRM_NAME,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	DAT_SWRM_FIRE_OFS_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_SWRM_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	data_swrm_atk,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_swrm_think,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	DAT_SWRM_PROJ_ID,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	0.100000,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	DAT_SWRM_FIRESOUND,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	DAT_PRJ_RPLAS_VELOCITY,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	MOVETYPE_STEP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	STOREP_F	20.000000,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_SWRM_ACC_x,	temp_0;
	DONE;
}

void() data_swrm_think = asm
{
local float max;
local float delta;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		19;
	INDIRECT_F	self,	w_state,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	self,	w_firetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	count1,	temp_1;
	SUB_F		time,	temp_1,	delta;
	INDIRECT_F	self,	rl_max,	max;
	ADDRESS	self,	rl_cur,	temp_1;
	DIV_F		delta,	max,	temp_3;
	MUL_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_swrm_atk = asm
{
local float locked_2939;
local entity mis;
local entity targs;
local float maxtarg;
local float range;
local vector angl;
local vector adj;
local vector end;
local vector org;
local vector dir;
local entity oself;
local entity proj;
local entity player;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	player,	stat_rdr_mode,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_V	self,	c_ofs_x,	locked_2939;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	INDIRECT_V	player,	angles_x,	angl;
	INDIRECT_F	self,	w_range,	range;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	player,	v_angle_x,	angl;
	INDIRECT_F	player,	ai_minrange,	range;
	INDIRECT_V	player,	origin_x,	parm0;
	STORE_V	adj,	parm1;
	STORE_V	angl,	parm2;
	CALL3		util_getOffsetOfVector;
	STORE_V	return,	org;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_F	player,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		util_traceForPlayer;
	STORE_V	return,	end;
	GOTO		8;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	angl,	parm1;
	STORE_F	temp_1,	parm2_x;
	STORE_F	player,	parm3_x;
	CALL4		util_traceForAI;
	STORE_V	return,	end;
	INDIRECT_V	player,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	INDIRECT_F	player,	accuracy,	temp_1;
	STORE_V	locked_2939,	parm0;
	STORE_F	range,	parm1_x;
	STORE_V	temp_2,	parm2;
	STORE_F	temp_1,	parm3_x;
	CALL4		util_applySpreadToTrace;
	STORE_V	return,	dir;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_currentammo,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	17;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	INDIRECT_F	self,	w_clipsize,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	count1,	temp_1;
	STOREP_F	time,	temp_1;
	GOTO		12;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_F	self,	rl_rate,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	CALL0		random;
	MUL_F		return_x,	0.100000,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	w_isburst,	temp_1;
	STOREP_F	TRUE,	temp_1;
	STORE_F	MOVETYPE_WALK,	maxtarg;
	INDIRECT_V	player,	origin_x,	locked_2939;
	INDIRECT_F	self,	w_range,	temp_1;
	STORE_V	locked_2939,	parm0;
	STORE_F	temp_1,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	targs;
	IFNOT		targs,	95;
	GT		maxtarg,	FALSE,	temp_1;
	IFNOT		temp_1,	91;
	STORE_F	targs,	parm0_x;
	STORE_F	DAT_MNT_SHIELD_RATE,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	2;
	NE_E		targs,	player,	temp_1;
	AND		return_x,	temp_1,	temp_1;
	IFNOT		temp_1,	84;
	INDIRECT_F	targs,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	targs,	flags,	temp_3;
	BITAND	temp_3,	FL_MONSTER,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	77;
	INDIRECT_F	targs,	i_faction,	temp_1;
	INDIRECT_F	player,	i_faction,	temp_3;
	NE_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	73;
	INDIRECT_F	targs,	deadflag,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	70;
	SUB_F		maxtarg,	TRUE,	maxtarg;
	CALL0		spawn;
	STORE_ENT	return_x,	mis;
	STORE_ENT	self,	oself;
	STORE_ENT	mis,	self;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	player,	temp_1;
	INDIRECT_F	oself,	w_proj,	parm0_x;
	CALL1		data_iniProjectile;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	MOVETYPE_BOUNCE,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	oself,	p_dmgtype,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	p_damage,	temp_1;
	INDIRECT_F	oself,	p_damage,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	targs,	temp_1;
	ADDRESS	self,	p_lifetime,	temp_1;
	INDIRECT_F	self,	p_lifetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	data_prj_swrm_touch,	temp_1;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	targs,	origin_x,	temp_2;
	SUB_V		temp_2,	org,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	temp_2;
	INDIRECT_F	self,	p_velocity,	temp_1;
	MUL_VF	temp_2,	temp_1,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	velocity_z,	temp_1;
	INDIRECT_F	self,	velocity_z,	temp_3;
	ADD_F		temp_3,	DAT_OTL_CTOR_HP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	data_prj_swrm_think,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	org,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	angles_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2939;
	STORE_ENT	oself,	self;
	INDIRECT_S	self,	fire_sound,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_E	targs,	chain,	targs;
	GOTO		-94;
	DONE;
}

void () data_eqp_atgm_upgrade;
void () data_eqp_atgm_die;
void() data_eqp_atgm_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	IMP_SWEAPON3,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_EQP_ATGM_NAME,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_ATGM_ACC_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_EQP_ATGM_MODEL,	temp_1;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_eqp_atgm_die,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	"",	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_eqp_atgm_upgrade,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	FL_NOTARGET,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	FALSE,	temp_1;
	DONE;
}

void() data_eqp_atgm_upgrade = asm
{
local float acc_x;
local float acc_n;
local float lock;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
local float temp_6;
	ADDRESS	self,	w_firetime,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	w_firetime,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_V	temp_1,	spreadDefault_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	accuracyMod,	temp_1;
	INDIRECT_F	self,	spreadDefault_z,	temp_3;
	INDIRECT_F	self,	w_fire_ofs_z,	temp_4;
	MUL_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	accuracyMod,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	accuracyMod,	temp_3;
	INDIRECT_F	self,	accuracyMod,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	spreadDefault_x,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	spreadDefault_x,	temp_3;
	INDIRECT_E	self,	owner,	temp_4;
	INDIRECT_F	temp_4,	spreadDefault_x,	temp_4;
	INDIRECT_F	self,	spreadDefault_x,	temp_6;
	MUL_F		temp_4,	temp_6,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	spreadDefault_y,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	spreadDefault_y,	temp_3;
	INDIRECT_E	self,	owner,	temp_4;
	INDIRECT_F	temp_4,	spreadDefault_y,	temp_4;
	INDIRECT_F	self,	spreadDefault_y,	temp_6;
	MUL_F		temp_4,	temp_6,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	spreadDefault_z,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	spreadDefault_z,	temp_3;
	INDIRECT_E	self,	owner,	temp_4;
	INDIRECT_F	temp_4,	spreadDefault_z,	temp_4;
	INDIRECT_F	self,	spreadDefault_z,	temp_6;
	MUL_F		temp_4,	temp_6,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	w_firetime,	lock;
	INDIRECT_F	self,	w_fire_ofs_z,	temp_1;
	MUL_F		lock,	temp_1,	temp_1;
	SUB_F		lock,	temp_1,	lock;
	LT		lock,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	POWERUP_DEBUG,	lock;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	w_firetime,	temp_1;
	STOREP_F	lock,	temp_1;
	DONE;
}

void() data_eqp_atgm_die = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	w_firetime,	temp_1;
	INDIRECT_F	self,	w_firetime,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	spreadDefault_x,	temp_0_x;
	INDIRECT_V	self,	w_fire_ofs_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	accuracyMod,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	accuracyMod,	temp_3;
	INDIRECT_F	self,	accuracyMod,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () data_eqp_enbat_upgrade;
void () data_eqp_enbat_die;
void() data_eqp_enbat_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FL_INWATER,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_EQP_ENBAT_NAME,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_EQP_ENBAT_MODEL,	temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_eqp_enbat_die,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	0.250000,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_eqp_enbat_upgrade,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	"",	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	FL_NOTARGET,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	FALSE,	temp_1;
	DONE;
}

void() data_eqp_enbat_upgrade = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
local float temp_6;
	ADDRESS	self,	en_max,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	en_max,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	en_max,	temp_3;
	INDIRECT_E	self,	owner,	temp_4;
	INDIRECT_F	temp_4,	en_max,	temp_4;
	INDIRECT_F	self,	en_rate,	temp_6;
	MUL_F		temp_4,	temp_6,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_eqp_enbat_die = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	en_max,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () data_eqp_recap_upgrade;
void () data_eqp_recap_die;
void() data_eqp_recap_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	20.000000,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_EQP_RECAP_NAME,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_EQP_RECAP_MODEL,	temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_eqp_recap_die,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	DAT_LATC_RL_RATE,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_eqp_recap_upgrade,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	"",	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	FL_NOTARGET,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	FALSE,	temp_1;
	DONE;
}

void() data_eqp_recap_upgrade = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
local float temp_6;
	ADDRESS	self,	en_max,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	en_rate,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	en_rate,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	en_rate,	temp_3;
	INDIRECT_E	self,	owner,	temp_4;
	INDIRECT_F	temp_4,	en_rate,	temp_4;
	INDIRECT_F	self,	en_rate,	temp_6;
	MUL_F		temp_4,	temp_6,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_eqp_recap_die = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	en_rate,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () data_eqp_lsar_upgrade;
void () data_eqp_lsar_die;
void() data_eqp_lsar_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	IMP_SWEAPON6,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_EQP_LSAR_NAME,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_EQP_LSAR_MODEL,	temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_eqp_lsar_die,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	DAT_EQP_LSAR_EN_RATE,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_eqp_lsar_upgrade,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	"",	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	FL_NOTARGET,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	FALSE,	temp_1;
	DONE;
}

void() data_eqp_lsar_upgrade = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
local float temp_6;
	ADDRESS	self,	en_max,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	radar_range,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	radar_range,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	radar_range,	temp_3;
	INDIRECT_E	self,	owner,	temp_4;
	INDIRECT_F	temp_4,	radar_range,	temp_4;
	INDIRECT_F	self,	en_rate,	temp_6;
	MUL_F		temp_4,	temp_6,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_eqp_lsar_die = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	radar_range,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () data_eqp_hsem_upgrade;
void () data_eqp_hsem_die;
void() data_eqp_hsem_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	IMP_SWEAPON5,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_EQP_HSEM_NAME,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_EQP_HSEM_MODEL,	temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_eqp_hsem_die,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	0.500000,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_eqp_hsem_upgrade,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	"",	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	FL_NOTARGET,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	FALSE,	temp_1;
	DONE;
}

void() data_eqp_hsem_upgrade = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
local float temp_6;
	ADDRESS	self,	en_max,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	sh_rate,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	sh_rate,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	sh_rate,	temp_3;
	INDIRECT_E	self,	owner,	temp_4;
	INDIRECT_F	temp_4,	sh_rate,	temp_4;
	INDIRECT_F	self,	en_rate,	temp_6;
	MUL_F		temp_4,	temp_6,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_eqp_hsem_die = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	sh_rate,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () data_eqp_scap_upgrade;
void () data_eqp_scap_die;
void() data_eqp_scap_ini = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	IMP_SWEAPON7,	temp_1;
	ADDRESS	self,	w_name,	temp_1;
	STOREP_S	DAT_EQP_SCAP_NAME,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_EQP_SCAP_MODEL,	temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_eqp_scap_die,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	ARM_HV_MOD,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	i_size,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	w_think,	temp_1;
	STOREP_FNC	data_eqp_scap_upgrade,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_clipsize,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_currentammo,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_fire_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fire_sound,	temp_1;
	STOREP_S	"",	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	p_dmgtype,	temp_1;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITOR		temp_3,	FL_NOTARGET,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_range,	temp_1;
	STOREP_F	FALSE,	temp_1;
	DONE;
}

void() data_eqp_scap_upgrade = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
local float temp_6;
	ADDRESS	self,	en_max,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	sh_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	sh_max,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	sh_max,	temp_3;
	INDIRECT_E	self,	owner,	temp_4;
	INDIRECT_F	temp_4,	sh_max,	temp_4;
	INDIRECT_F	self,	en_rate,	temp_6;
	MUL_F		temp_4,	temp_6,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() data_eqp_scap_die = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	sh_max,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

float DAT_OTL_RESERVE_COST;
float DAT_OTL_WEP1_IDX;
float DAT_OTL_WEP2_IDX;
float DAT_OTL_WEP3_IDX;
float DAT_OTL_WEP1_GROUP;
float DAT_OTL_WEP2_GROUP;
float DAT_OTL_WEP3_GROUP;
string DAT_OTL_M_ROLLANGLE;
string DAT_OTL_M_PITCH_N;
string DAT_OTL_M_PITCH_X;
string DAT_OTL_M_BOB;
string DAT_OTL_M_BCYCLE;
string DAT_OTL_M_BUP;
string DAT_OTL_M_BMODEL;
string DAT_OTL_M_BSIDE;
string DAT_OTL_M_BSPD;
float DAT_OTL_CAM_CNAME;
void () data_otl_legs;
void () data_otl_ctor;
void () data_otl_ltor;
void () data_otl_rtor;
void () data_otl_larm;
void () data_otl_rarm;
void () data_otl_cam;
void () data_otl_wep1;
void () data_otl_wep2;
void () data_otl_wep3;
void() data_otl_ini = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	unit_legs,	temp_1;
	STOREP_FNC	data_otl_legs,	temp_1;
	ADDRESS	self,	unit_ctor,	temp_1;
	STOREP_FNC	data_otl_ctor,	temp_1;
	ADDRESS	self,	unit_ltor,	temp_1;
	STOREP_FNC	data_otl_ltor,	temp_1;
	ADDRESS	self,	unit_rtor,	temp_1;
	STOREP_FNC	data_otl_rtor,	temp_1;
	ADDRESS	self,	unit_larm,	temp_1;
	STOREP_FNC	data_otl_larm,	temp_1;
	ADDRESS	self,	unit_rarm,	temp_1;
	STOREP_FNC	data_otl_rarm,	temp_1;
	ADDRESS	self,	unit_cam,	temp_1;
	STOREP_FNC	data_otl_cam,	temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_otl_wep1,	temp_1;
	ADDRESS	self,	unit_wep2,	temp_1;
	STOREP_FNC	data_otl_wep2,	temp_1;
	ADDRESS	self,	unit_wep3,	temp_1;
	STOREP_FNC	data_otl_wep3,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	vec_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	MCH_NAME_BLK,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_OTL_CTOR_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_OTL_CTOR_HP,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	DAT_OTL_RADAR_RANGE,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	i_reserve,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	DAT_SFGA_DMG,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	DAT_SFGA_DMG,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_OTL_CTOR_MODEL,	temp_1;
	ADDRESS	self,	weaponmodel,	temp_1;
	STOREP_S	DAT_OTL_CPIT_MODEL,	temp_1;
	ADDRESS	self,	weaponframe,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	ACCURACY_SKIRMISH_x,	temp_0;
	ADDRESS	self,	m_rot_speed,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	m_fspeed,	temp_1;
	STOREP_F	DAT_OTL_M_FSPEED,	temp_1;
	ADDRESS	self,	m_sspeed,	temp_1;
	STOREP_F	DAT_OTL_M_SSPEED,	temp_1;
	ADDRESS	self,	m_bspeed,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	m_maccel,	temp_1;
	STOREP_F	SHVBAL_EFFRAM_PERCENTAGE,	temp_1;
	ADDRESS	self,	m_rollangle,	temp_1;
	STOREP_S	DAT_OTL_M_ROLLANGLE,	temp_1;
	ADDRESS	self,	m_pitch_max,	temp_1;
	STOREP_S	DAT_OTL_M_PITCH_N,	temp_1;
	ADDRESS	self,	m_pitch_min,	temp_1;
	STOREP_S	DAT_OTL_M_PITCH_X,	temp_1;
	ADDRESS	self,	m_bob,	temp_1;
	STOREP_S	DAT_OTL_M_BOB,	temp_1;
	ADDRESS	self,	m_bcycle,	temp_1;
	STOREP_S	DAT_OTL_M_BCYCLE,	temp_1;
	ADDRESS	self,	m_bup,	temp_1;
	STOREP_S	DAT_OTL_M_BUP,	temp_1;
	ADDRESS	self,	m_bmodel,	temp_1;
	STOREP_S	DAT_OTL_M_BMODEL,	temp_1;
	ADDRESS	self,	m_bside,	temp_1;
	STOREP_S	DAT_OTL_M_BSIDE,	temp_1;
	ADDRESS	self,	m_bobspd,	temp_1;
	STOREP_S	DAT_OTL_M_BSPD,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	ADDRESS	self,	hardpoint_cnt,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	DAT_OTL_CTOR_BBX_N,	parm1;
	STORE_V	DAT_OTL_CTOR_BBX_X,	parm2;
	CALL3		setsize;
	DONE;
}

void() data_otl_ctor = asm
{
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_OTL_CTOR_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_OTL_CTOR_HP,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_OTL_CTOR_MODEL,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	DONE;
}

void() data_otl_legs = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_OTL_LEG_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_OTL_LEG_HP,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_OTL_LEG_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_OTL_LEG_OFFSET_x,	temp_0;
	DONE;
}

void() data_otl_ltor = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_OTL_LTOR_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_OTL_LTOR_HP,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_OTL_LTOR_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_OTL_LTOR_OFFSET_x,	temp_0;
	DONE;
}

void() data_otl_rtor = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_OTL_LTOR_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_OTL_LTOR_HP,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_OTL_RTOR_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_OTL_RTOR_OFFSET_x,	temp_0;
	DONE;
}

void() data_otl_larm = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_OTL_LARM_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_OTL_LARM_HP,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_OTL_LARM_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_OTL_LARM_OFFSET_x,	temp_0;
	DONE;
}

void() data_otl_rarm = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_OTL_LARM_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_OTL_LARM_HP,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_OTL_RARM_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_OTL_RARM_OFFSET_x,	temp_0;
	DONE;
}

void() data_otl_cam = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_OTL_CAM_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	DAT_OTL_CAM_OFFSET_ALT_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_OTL_CAM_MODEL,	temp_1;
	DONE;
}

void() data_otl_wep1 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	DAT_OTL_WEP1_IDX,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_OTL_WEP1_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

void() data_otl_wep2 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	DAT_OTL_WEP2_IDX,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_OTL_WEP2_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	DONE;
}

void() data_otl_wep3 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	DAT_OTL_WEP3_IDX,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_OTL_WEP3_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	DONE;
}

string DAT_MTK_VEC_NAME;
float DAT_MTK_RESERVE_COST;
float DAT_MTK_WEP1_IDX;
float DAT_MTK_WEP2_IDX;
float DAT_MTK_WEP3_IDX;
float DAT_MTK_WEP4_IDX;
float DAT_MTK_WEP5_IDX;
float DAT_MTK_WEP1_GROUP;
float DAT_MTK_WEP2_GROUP;
float DAT_MTK_WEP3_GROUP;
float DAT_MTK_WEP4_GROUP;
float DAT_MTK_WEP5_GROUP;
string DAT_MTK_M_ROLLANGLE;
string DAT_MTK_M_PITCH_N;
string DAT_MTK_M_PITCH_X;
string DAT_MTK_M_BOB;
string DAT_MTK_M_BCYCLE;
string DAT_MTK_M_BUP;
string DAT_MTK_M_BMODEL;
string DAT_MTK_M_BSIDE;
string DAT_MTK_M_BSPD;
void () data_mtk_legs;
void () data_mtk_ctor;
void () data_mtk_ltor;
void () data_mtk_rtor;
void () data_mtk_larm;
void () data_mtk_rarm;
void () data_mtk_cam;
void () data_mtk_wep1;
void () data_mtk_wep2;
void () data_mtk_wep3;
void () data_mtk_wep4;
void () data_mtk_wep5;
void() data_mtk_ini = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	unit_legs,	temp_1;
	STOREP_FNC	data_mtk_legs,	temp_1;
	ADDRESS	self,	unit_ltor,	temp_1;
	STOREP_FNC	data_mtk_ltor,	temp_1;
	ADDRESS	self,	unit_ctor,	temp_1;
	STOREP_FNC	data_mtk_ctor,	temp_1;
	ADDRESS	self,	unit_rtor,	temp_1;
	STOREP_FNC	data_mtk_rtor,	temp_1;
	ADDRESS	self,	unit_larm,	temp_1;
	STOREP_FNC	data_mtk_larm,	temp_1;
	ADDRESS	self,	unit_rarm,	temp_1;
	STOREP_FNC	data_mtk_rarm,	temp_1;
	ADDRESS	self,	unit_cam,	temp_1;
	STOREP_FNC	data_mtk_cam,	temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_mtk_wep1,	temp_1;
	ADDRESS	self,	unit_wep2,	temp_1;
	STOREP_FNC	data_mtk_wep2,	temp_1;
	ADDRESS	self,	unit_wep3,	temp_1;
	STOREP_FNC	data_mtk_wep3,	temp_1;
	ADDRESS	self,	unit_wep4,	temp_1;
	STOREP_FNC	data_mtk_wep4,	temp_1;
	ADDRESS	self,	unit_wep5,	temp_1;
	STOREP_FNC	data_mtk_wep5,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	DAT_MTK_VEC_NAME,	temp_1;
	ADDRESS	self,	vec_size,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_MARH_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_MARH_VELOCITY,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	DAT_MTK_RADAR_RANGE,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	i_reserve,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	DAT_PRJ_MLGD_VELOCITY,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	DAT_PRJ_MLGD_VELOCITY,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	DAT_MTK_SHIELD_MAX,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	DAT_MTK_SHIELD_MAX,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	SHVBAL_EFFRAM_PERCENTAGE,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MTK_CTOR_MODEL,	temp_1;
	ADDRESS	self,	m_rot_speed,	temp_1;
	STOREP_F	RADAR_SWEEP,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	ACCURACY_MARKSMAN_x,	temp_0;
	ADDRESS	self,	m_fspeed,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	m_sspeed,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	m_bspeed,	temp_1;
	STOREP_F	STAT_TRG_ORGZ,	temp_1;
	ADDRESS	self,	m_maccel,	temp_1;
	STOREP_F	SHVBAL_EFFRAM_PERCENTAGE,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	hardpoint_cnt,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	23;
	ADDRESS	self,	weaponmodel,	temp_1;
	STOREP_S	DAT_MTK_CPIT_MODEL,	temp_1;
	ADDRESS	self,	weaponframe,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	m_rollangle,	temp_1;
	STOREP_S	DAT_MTK_M_ROLLANGLE,	temp_1;
	ADDRESS	self,	m_pitch_max,	temp_1;
	STOREP_S	DAT_MTK_M_PITCH_N,	temp_1;
	ADDRESS	self,	m_pitch_min,	temp_1;
	STOREP_S	DAT_MTK_M_PITCH_X,	temp_1;
	ADDRESS	self,	m_bob,	temp_1;
	STOREP_S	DAT_MTK_M_BOB,	temp_1;
	ADDRESS	self,	m_bcycle,	temp_1;
	STOREP_S	DAT_MTK_M_BCYCLE,	temp_1;
	ADDRESS	self,	m_bup,	temp_1;
	STOREP_S	DAT_MTK_M_BUP,	temp_1;
	ADDRESS	self,	m_bmodel,	temp_1;
	STOREP_S	DAT_MTK_M_BMODEL,	temp_1;
	ADDRESS	self,	m_bside,	temp_1;
	STOREP_S	DAT_MTK_M_BSIDE,	temp_1;
	ADDRESS	self,	m_bobspd,	temp_1;
	STOREP_S	DAT_MTK_M_BSPD,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	DAT_MTK_CTOR_BBX_N,	parm1;
	STORE_V	DAT_MTK_CTOR_BBX_X,	parm2;
	CALL3		setsize;
	DONE;
}

void() data_mtk_legs = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_MTK_LEG_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_MTK_LEG_HP,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MTK_LEG_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_LEG_OFFSET_x,	temp_0;
	DONE;
}

void() data_mtk_ctor = asm
{
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_MARH_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_MARH_VELOCITY,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MTK_CTOR_MODEL,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	DONE;
}

void() data_mtk_ltor = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_MTK_LTOR_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_MTK_LTOR_HP,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MTK_LTOR_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_LTOR_OFFSET_x,	temp_0;
	DONE;
}

void() data_mtk_rtor = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_MTK_LTOR_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_MTK_LTOR_HP,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MTK_RTOR_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_RTOR_OFFSET_x,	temp_0;
	DONE;
}

void() data_mtk_larm = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_MTK_LARM_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_MTK_LARM_HP,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MTK_LARM_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_LARM_OFFSET_x,	temp_0;
	DONE;
}

void() data_mtk_rarm = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_MTK_LARM_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_MTK_LARM_HP,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MTK_RARM_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_RARM_OFFSET_x,	temp_0;
	DONE;
}

void() data_mtk_cam = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_CAM_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_CAM_OFFSET_ALT_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MTK_CAM_MODEL,	temp_1;
	DONE;
}

void() data_mtk_wep1 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_WEP1_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

void() data_mtk_wep2 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_WEP2_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	DONE;
}

void() data_mtk_wep3 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_WEP3_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	DONE;
}

void() data_mtk_wep4 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_WEP4_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	DONE;
}

void() data_mtk_wep5 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MTK_WEP5_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_INWATER,	temp_1;
	DONE;
}

float DAT_MNT_RESERVE_COST;
float DAT_MNT_WEP1_IDX;
float DAT_MNT_WEP2_IDX;
float DAT_MNT_WEP3_IDX;
float DAT_MNT_WEP4_IDX;
float DAT_MNT_WEP5_IDX;
float DAT_MNT_WEP6_IDX;
float DAT_MNT_WEP7_IDX;
float DAT_MNT_WEP8_IDX;
float DAT_MNT_WEP9_IDX;
float DAT_MNT_WEP1_GROUP;
string DAT_MNT_M_ROLLANGLE;
string DAT_MNT_M_PITCH_N;
string DAT_MNT_M_PITCH_X;
string DAT_MNT_M_BOB;
string DAT_MNT_M_BCYCLE;
string DAT_MNT_M_BUP;
string DAT_MNT_M_BMODEL;
string DAT_MNT_M_BSIDE;
string DAT_MNT_M_BSPD;
void () data_mnt_legs;
void () data_mnt_ctor;
void () data_mnt_ltor;
void () data_mnt_rtor;
void () data_mnt_larm;
void () data_mnt_rarm;
void () data_mnt_cam;
void () data_mnt_wep1;
void () data_mnt_wep2;
void () data_mnt_wep3;
void () data_mnt_wep4;
void () data_mnt_wep5;
void () data_mnt_wep6;
void () data_mnt_wep7;
void () data_mnt_wep8;
void () data_mnt_wep9;
void() data_mnt_ini = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	unit_legs,	temp_1;
	STOREP_FNC	data_mnt_legs,	temp_1;
	ADDRESS	self,	unit_ltor,	temp_1;
	STOREP_FNC	data_mnt_ltor,	temp_1;
	ADDRESS	self,	unit_ctor,	temp_1;
	STOREP_FNC	data_mnt_ctor,	temp_1;
	ADDRESS	self,	unit_rtor,	temp_1;
	STOREP_FNC	data_mnt_rtor,	temp_1;
	ADDRESS	self,	unit_larm,	temp_1;
	STOREP_FNC	data_mnt_larm,	temp_1;
	ADDRESS	self,	unit_rarm,	temp_1;
	STOREP_FNC	data_mnt_rarm,	temp_1;
	ADDRESS	self,	unit_cam,	temp_1;
	STOREP_FNC	data_mnt_cam,	temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_mnt_wep1,	temp_1;
	ADDRESS	self,	unit_wep2,	temp_1;
	STOREP_FNC	data_mnt_wep2,	temp_1;
	ADDRESS	self,	unit_wep3,	temp_1;
	STOREP_FNC	data_mnt_wep3,	temp_1;
	ADDRESS	self,	unit_wep4,	temp_1;
	STOREP_FNC	data_mnt_wep4,	temp_1;
	ADDRESS	self,	unit_wep5,	temp_1;
	STOREP_FNC	data_mnt_wep5,	temp_1;
	ADDRESS	self,	unit_wep6,	temp_1;
	STOREP_FNC	data_mnt_wep6,	temp_1;
	ADDRESS	self,	unit_wep7,	temp_1;
	STOREP_FNC	data_mnt_wep7,	temp_1;
	ADDRESS	self,	unit_wep8,	temp_1;
	STOREP_FNC	data_mnt_wep8,	temp_1;
	ADDRESS	self,	unit_wep9,	temp_1;
	STOREP_FNC	data_mnt_wep9,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	MCH_NAME_MNT,	temp_1;
	ADDRESS	self,	vec_size,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_MNT_CTOR_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_MNT_CTOR_HP,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	DAT_MNT_RADAR_RANGE,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	i_reserve,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	DAT_OTL_LEG_HP,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	DAT_OTL_LEG_HP,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	DAT_MTK_LTOR_HP,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	DAT_MTK_LTOR_HP,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	DAT_MNT_SHIELD_RATE,	temp_1;
	ADDRESS	self,	m_rot_speed,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MNT_CTOR_MODEL,	temp_1;
	ADDRESS	self,	weaponmodel,	temp_1;
	STOREP_S	DAT_MNT_CPIT_MODEL,	temp_1;
	ADDRESS	self,	weaponframe,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	ACCURACY_LOWTECH_x,	temp_0;
	ADDRESS	self,	m_fspeed,	temp_1;
	STOREP_F	STAT_PLR_PTC,	temp_1;
	ADDRESS	self,	m_sspeed,	temp_1;
	STOREP_F	STAT_PLR_PTC,	temp_1;
	ADDRESS	self,	m_bspeed,	temp_1;
	STOREP_F	STAT_PLR_PTC,	temp_1;
	ADDRESS	self,	m_maccel,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	m_rollangle,	temp_1;
	STOREP_S	DAT_MNT_M_ROLLANGLE,	temp_1;
	ADDRESS	self,	m_pitch_max,	temp_1;
	STOREP_S	DAT_MNT_M_PITCH_N,	temp_1;
	ADDRESS	self,	m_pitch_min,	temp_1;
	STOREP_S	DAT_MNT_M_PITCH_X,	temp_1;
	ADDRESS	self,	m_bob,	temp_1;
	STOREP_S	DAT_MNT_M_BOB,	temp_1;
	ADDRESS	self,	m_bcycle,	temp_1;
	STOREP_S	DAT_MNT_M_BCYCLE,	temp_1;
	ADDRESS	self,	m_bup,	temp_1;
	STOREP_S	DAT_MNT_M_BUP,	temp_1;
	ADDRESS	self,	m_bmodel,	temp_1;
	STOREP_S	DAT_MNT_M_BMODEL,	temp_1;
	ADDRESS	self,	m_bside,	temp_1;
	STOREP_S	DAT_MNT_M_BSIDE,	temp_1;
	ADDRESS	self,	m_bobspd,	temp_1;
	STOREP_S	DAT_MNT_M_BSPD,	temp_1;
	ADDRESS	self,	w_firetime,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	hardpoint_cnt,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	DAT_MNT_CTOR_BBX_N,	parm1;
	STORE_V	DAT_MNT_CTOR_BBX_X,	parm2;
	CALL3		setsize;
	DONE;
}

void() data_mnt_legs = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_EMP_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_EMP_VELOCITY,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MNT_LEG_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_LEG_OFFSET_x,	temp_0;
	DONE;
}

void() data_mnt_ctor = asm
{
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_MNT_CTOR_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_MNT_CTOR_HP,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MNT_CTOR_MODEL,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	DONE;
}

void() data_mnt_ltor = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_MNT_CTOR_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_MNT_CTOR_HP,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MNT_LTOR_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_LTOR_OFFSET_x,	temp_0;
	DONE;
}

void() data_mnt_rtor = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_MNT_CTOR_HP,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_MNT_CTOR_HP,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MNT_RTOR_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_RTOR_OFFSET_x,	temp_0;
	DONE;
}

void() data_mnt_larm = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_ABT_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_ABT_VELOCITY,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MNT_LARM_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_LARM_OFFSET_x,	temp_0;
	DONE;
}

void() data_mnt_rarm = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_ABT_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_ABT_VELOCITY,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MNT_RARM_MODEL,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_RARM_OFFSET_x,	temp_0;
	DONE;
}

void() data_mnt_cam = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_CAM_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_CAM_OFFSET_ALT_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_MNT_CAM_MODEL,	temp_1;
	DONE;
}

void() data_mnt_wep1 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_WEP1_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

void() data_mnt_wep2 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_WEP2_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	DONE;
}

void() data_mnt_wep3 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_WEP3_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	DONE;
}

void() data_mnt_wep4 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_WEP4_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	DONE;
}

void() data_mnt_wep5 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_WEP5_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_INWATER,	temp_1;
	DONE;
}

void() data_mnt_wep6 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_WEP6_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_MONSTER,	temp_1;
	DONE;
}

void() data_mnt_wep7 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_WEP7_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_GODMODE,	temp_1;
	DONE;
}

void() data_mnt_wep8 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_WEP8_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_NOTARGET,	temp_1;
	DONE;
}

void() data_mnt_wep9 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_MNT_WEP9_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_ITEM,	temp_1;
	DONE;
}

void () data_HS_TruckA_ini;
void() data_HS_TruckA_ini = asm
{
local float temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	DAT_HS_TRUCKA_NAME,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	DAT_H_TD_RADAR_RANGE,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_SFGA_DMG,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_SFGA_DMG,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_H_TD_CTOR_MODEL,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	DAT_H_TD_CTOR_BBX_N,	parm1;
	STORE_V	DAT_H_TD_CTOR_BBX_X,	parm2;
	CALL3		setsize;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	m_rot_speed,	temp_1;
	STOREP_F	DAT_HS_TRUCK_YAW_SPEED,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_H_TD_CTOR_MODEL,	temp_1;
	ADDRESS	self,	m_fspeed,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	m_sspeed,	temp_1;
	STOREP_F	TE_PLASMABURN,	temp_1;
	ADDRESS	self,	m_bspeed,	temp_1;
	STOREP_F	IMP_SHOWOBJ,	temp_1;
	DONE;
}

void () data_HS_TruckB_ini;
void () data_HS_TruckB_chas;
void() data_HS_TruckB_ini = asm
{
	DONE;
}

void() data_HS_TruckB_chas = asm
{
	DONE;
}

void () data_HS_TruckC_ini;
void () data_HS_TruckC_chas;
void() data_HS_TruckC_ini = asm
{
	DONE;
}

void() data_HS_TruckC_chas = asm
{
	DONE;
}

void () data_HS_Dozer_ini;
void () data_HS_Dozer_chas;
void() data_HS_Dozer_ini = asm
{
	DONE;
}

void() data_HS_Dozer_chas = asm
{
	DONE;
}

void () data_HS_Loader_ini;
void () data_HS_Loader_chas;
void() data_HS_Loader_ini = asm
{
	DONE;
}

void() data_HS_Loader_chas = asm
{
	DONE;
}

void () data_HS_Excat_ini;
void () data_HS_Excat_chas;
void() data_HS_Excat_ini = asm
{
	DONE;
}

void() data_HS_Excat_chas = asm
{
	DONE;
}

string DAT_H_TD_PITCH_N;
string DAT_H_TD_PITCH_X;
void () data_H_TD_ini;
void () data_H_TD_cam;
void () data_H_TD_wep1;
void() data_H_TD_ini = asm
{
local float temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_H_TD_wep1,	temp_1;
	ADDRESS	self,	unit_cam,	temp_1;
	STOREP_FNC	data_H_TD_cam,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	DAT_H_TD_VEC_NAME,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	DAT_H_TD_RADAR_RANGE,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_H_TD_CTOR_MODEL,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	DAT_H_TD_CTOR_BBX_N,	parm1;
	STORE_V	DAT_H_TD_CTOR_BBX_X,	parm2;
	CALL3		setsize;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	DAT_OTL_LARM_HP,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	DAT_OTL_LARM_HP,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	DAT_FLAK_RL_RATE,	temp_1;
	ADDRESS	self,	m_rot_speed,	temp_1;
	STOREP_F	RADAR_SWEEP,	temp_1;
	ADDRESS	self,	m_fspeed,	temp_1;
	STOREP_F	TE_BLOOD,	temp_1;
	ADDRESS	self,	m_sspeed,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	m_bspeed,	temp_1;
	STOREP_F	IMP_SWEAPON3,	temp_1;
	ADDRESS	self,	m_pitch_max,	temp_1;
	STOREP_S	DAT_H_TD_PITCH_N,	temp_1;
	ADDRESS	self,	m_pitch_min,	temp_1;
	STOREP_S	DAT_H_TD_PITCH_X,	temp_1;
	DONE;
}

void() data_H_TD_wep1 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_H_TD_WEP1_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

string DAT_HS_TANKL_PITCH_N;
string DAT_HS_TANKL_PITCH_X;
float DAT_HS_TANKL_CAM_CNAME;
float DAT_HS_TANKL_CAM_OFFSET_x;
float DAT_HS_TANKL_CAM_OFFSET_y;
float DAT_HS_TANKL_CAM_OFFSET_z;
vector DAT_HS_TANKL_CAM_OFFSET;
float DAT_HS_TANKL_CAM_OFFSET_ALT_x;
float DAT_HS_TANKL_CAM_OFFSET_ALT_y;
float DAT_HS_TANKL_CAM_OFFSET_ALT_z;
vector DAT_HS_TANKL_CAM_OFFSET_ALT;
void () data_HS_TANKL_ini;
void () data_HS_TANKL_ctor;
void () data_HS_TANKL_cam;
void () data_HS_TANKL_wep1;
void () data_HS_TANKL_wep2;
void() data_HS_TANKL_ini = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	unit_ctor,	temp_1;
	STOREP_FNC	data_HS_TANKL_ctor,	temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_HS_TANKL_wep1,	temp_1;
	ADDRESS	self,	unit_wep2,	temp_1;
	STOREP_FNC	data_HS_TANKL_wep2,	temp_1;
	ADDRESS	self,	unit_cam,	temp_1;
	STOREP_FNC	data_HS_TANKL_cam,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	DAT_HS_TANKL_NAME,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	DAT_PRJ_ION_VELOCITY,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	DAT_FLAK_RL_RATE,	temp_1;
	ADDRESS	self,	m_rot_speed,	temp_1;
	STOREP_F	RADAR_SWEEP,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_HS_TANKL_MDL_CHASSIS,	temp_1;
	ADDRESS	self,	m_fspeed,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	m_sspeed,	temp_1;
	STOREP_F	TE_PLASMABURN,	temp_1;
	ADDRESS	self,	m_bspeed,	temp_1;
	STOREP_F	IMP_SHOWOBJ,	temp_1;
	ADDRESS	self,	m_pitch_max,	temp_1;
	STOREP_S	DAT_HS_TANKL_PITCH_N,	temp_1;
	ADDRESS	self,	m_pitch_min,	temp_1;
	STOREP_S	DAT_HS_TANKL_PITCH_X,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	DAT_HS_TANKL_CTOR_BBX_N,	parm1;
	STORE_V	DAT_HS_TANKL_CTOR_BBX_X,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	DONE;
}

void() data_HS_TANKL_ctor = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_HS_TANKL_CTOR_MODEL,	temp_1;
	ADDRESS	self,	yaw_speed,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	attack_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	DONE;
}

void() data_HS_TANKL_wep1 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_HS_TANKL_WEP1_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

void() data_HS_TANKL_wep2 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_HS_TANKL_WEP2_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	DONE;
}

void() data_HS_TANKL_cam = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_HS_TANKL_CAM_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	DAT_HS_TANKL_CAM_OFFSET_ALT_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_HS_TANKL_CAM_MODEL,	temp_1;
	DONE;
}

void () data_HS_GEVL_ini;
void () data_HS_GEVL_cam;
void () data_HS_GEVL_wep1;
void() data_HS_GEVL_ini = asm
{
local float temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_HS_GEVL_wep1,	temp_1;
	ADDRESS	self,	unit_cam,	temp_1;
	STOREP_FNC	data_HS_GEVL_cam,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_BOUNCEMISSILE,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	DAT_HS_GEVL_NAME,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	DAT_HS_GEVL_RADAR_RANGE,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	DAT_HS_GEVL_BBX_N,	parm1;
	STORE_V	DAT_HS_GEVL_BBX_X,	parm2;
	CALL3		setsize;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_HS_GEVL_MDL,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	TE_BLOOD,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	ARM_LT_MOD,	temp_1;
	ADDRESS	self,	m_rot_speed,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	m_fspeed,	temp_1;
	STOREP_F	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	ADDRESS	self,	m_sspeed,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	m_bspeed,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	m_pitch_max,	temp_1;
	STOREP_S	DAT_H_TD_PITCH_N,	temp_1;
	ADDRESS	self,	m_pitch_min,	temp_1;
	STOREP_S	DAT_H_TD_PITCH_X,	temp_1;
	DONE;
}

void() data_HS_GEVL_cam = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	'0.000000 12.000000 20.000000',	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	DONE;
}

void() data_HS_GEVL_wep1 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_HS_GEVL_WEP1_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

void () data_PSC_VTOLL_ini;
void () data_PSC_VTOLL_cam;
void () data_PSC_VTOLL_wep1;
void () data_PSC_VTOLL_wep2;
void() data_PSC_VTOLL_ini = asm
{
local float temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_PSC_VTOLL_wep1,	temp_1;
	ADDRESS	self,	unit_wep2,	temp_1;
	STOREP_FNC	data_PSC_VTOLL_wep2,	temp_1;
	ADDRESS	self,	unit_cam,	temp_1;
	STOREP_FNC	data_PSC_VTOLL_cam,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	STAT_PLR_HITDIR,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	DAT_PSC_VTOLL_NAME,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	DAT_MNT_RADAR_RANGE,	temp_1;
	ADDRESS	self,	i_techlvl,	temp_1;
	STOREP_F	TRUE,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	DAT_PSC_VTOLL_BBX_N,	parm1;
	STORE_V	DAT_PSC_VTOLL_BBX_X,	parm2;
	CALL3		setsize;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_H_TD_CTOR_MODEL,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	ARM_HV_MOD,	temp_1;
	ADDRESS	self,	m_rot_speed,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_PSC_VTOLL_MODEL,	temp_1;
	ADDRESS	self,	m_fspeed,	temp_1;
	STOREP_F	DAT_PSC_VTOLL_FSPEED,	temp_1;
	ADDRESS	self,	m_sspeed,	temp_1;
	STOREP_F	DAT_OTL_LTOR_HP,	temp_1;
	ADDRESS	self,	m_bspeed,	temp_1;
	STOREP_F	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	ADDRESS	self,	m_pitch_max,	temp_1;
	STOREP_S	DAT_H_TD_PITCH_N,	temp_1;
	ADDRESS	self,	m_pitch_min,	temp_1;
	STOREP_S	DAT_H_TD_PITCH_X,	temp_1;
	DONE;
}

void() data_PSC_VTOLL_cam = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	'0.000000 0.000000 24.000000',	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	DONE;
}

void() data_PSC_VTOLL_wep1 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_PSC_VTOLL_WEP1_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

void() data_PSC_VTOLL_wep2 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_PSC_VTOLL_WEP2_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	DONE;
}

void () building_radar_cooldown;
void() building_radar_cooldown = asm
{
local float temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	world,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void () building_radar_has_enemy;
void() building_radar_has_enemy = asm
{
local float rng;
local float dist;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	dist;
	INDIRECT_F	self,	radar_range,	rng;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	temp_1,	stat_rdr_mode,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	radar_range,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	rng;
	INDIRECT_F	self,	radar_range,	temp_1;
	GT		dist,	temp_1,	temp_1;
	IFNOT		temp_1,	8;
	STORE_F	MOVETYPE_BOUNCE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_FLY,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void () building_radar_send_target;
void() building_radar_send_target = asm
{
local entity this;
local entity ally;
local vector temp_0;
local float temp_1;
local vector temp_2;
	STORE_ENT	self,	this;
	INDIRECT_F	self,	i_faction,	temp_1;
	STORE_F	i_faction,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		findchainfloat;
	STORE_ENT	return_x,	ally;
	IFNOT		ally,	22;
	INDIRECT_V	ally,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	INDIRECT_F	self,	radar_range,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	temp_1;
	LE		return_x,	temp_1,	temp_1;
	IFNOT		temp_1,	12;
	STORE_F	ally,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	9;
	INDIRECT_E	ally,	w_slot,	temp_1;
	NE_E		temp_1,	world,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_E	self,	enemy,	temp_1;
	STORE_F	ally,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		ai_give_target;
	INDIRECT_E	ally,	chain,	ally;
	GOTO		-21;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	world,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void () building_radar_sweep;
void() building_radar_sweep = asm
{
local float locked_2932;
local float yaw;
local float high;
local float low;
local float sweep;
local float rng;
local entity found;
local entity blip;
local vector temp_0;
local vector temp_2;
local float temp_3;
	ADDRESS	self,	radar_time,	locked_2932;
	INDIRECT_F	self,	radar_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_TOSS,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	radar_time,	sweep;
	SUB_F		sweep,	MOVETYPE_FLY,	parm0_x;
	CALL1		anglemod;
	STORE_F	return_x,	low;
	ADD_F		sweep,	TRUE,	parm0_x;
	CALL1		anglemod;
	STORE_F	return_x,	high;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_F	self,	radar_range,	locked_2932;
	STORE_V	temp_0,	parm0;
	STORE_F	locked_2932,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	blip;
	IFNOT		blip,	36;
	INDIRECT_F	blip,	deadflag,	locked_2932;
	LE		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	31;
	INDIRECT_F	blip,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	28;
	INDIRECT_F	blip,	i_faction,	locked_2932;
	INDIRECT_F	self,	i_faction,	temp_3;
	NE_F		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	24;
	INDIRECT_F	self,	radar_range,	rng;
	INDIRECT_F	blip,	stat_rdr_mode,	locked_2932;
	EQ_F		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	3;
	INDIRECT_F	self,	radar_range,	locked_2932;
	DIV_F		locked_2932,	FL_SWIM,	rng;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	blip,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STORE_F	return_x,	yaw;
	GE		yaw,	low,	locked_2932;
	IFNOT		locked_2932,	2;
	LE		yaw,	high,	temp_3;
	AND		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	8;
	INDIRECT_V	blip,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	LE		return_x,	rng,	locked_2932;
	IFNOT		locked_2932,	2;
	STORE_ENT	blip,	found;
	INDIRECT_E	blip,	chain,	blip;
	GOTO		-35;
	NE_E		found,	world,	locked_2932;
	IFNOT		locked_2932,	10;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	found,	locked_2932;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_FLY,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	DONE;
}

void () building_radar_think;
void() building_radar_think = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	attack_state,	parm0_x;
	CALL1		ai_state_control;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	building_radar_think,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () building_radar;
void() building_radar = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	"Listening Post",	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	FL_MONSTER,	temp_3;
	BITOR		temp_3,	FL_UNIT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	vec_size,	temp_1;
	STOREP_F	TRUE,	temp_1;
	INDIRECT_F	self,	skin,	temp_1;
	STORE_F	DAT_BLD_H_SM_RADAR_MODEL,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setCollider;
	STORE_F	DAT_PAC_DMG,	parm0_x;
	STORE_F	DAT_PAC_DMG,	parm1_x;
	STORE_F	TRUE,	parm2_x;
	STORE_F	STAT_PLR_ANG_X,	parm3_x;
	CALL4		util_setHealthArmor;
	STORE_F	self,	parm0_x;
	STORE_V	'-20.000000 -20.000000 0.000000',	parm1;
	STORE_V	'20.000000 20.000000 26.000000',	parm2;
	CALL3		setsize;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	stat_rdr_mode,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	DAT_BLD_H_SM_RADAR_RADAR_RANGE,	temp_1;
	ADDRESS	self,	scale,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_V	self,	angles_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_F	self,	mins_z,	temp_1;
	ADD_F		temp_1,	MOVETYPE_STEP,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	temp_1,	parm2_x;
	CALL3		util_dropToGround;
	STORE_F	self,	parm0_x;
	STORE_V	return,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	building_radar_sweep,	temp_1;
	ADDRESS	self,	th_run,	temp_1;
	STOREP_FNC	building_radar_has_enemy,	temp_1;
	ADDRESS	self,	th_missile,	temp_1;
	STOREP_FNC	building_radar_send_target,	temp_1;
	ADDRESS	self,	th_hunt,	temp_1;
	STOREP_FNC	building_radar_cooldown,	temp_1;
	ADDRESS	self,	ai_action_mod,	temp_1;
	STOREP_F	ARM_HV_MOD,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_initialize_system;
	STORE_F	self,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_cornerSlopeCheck;
	IFNOT		return_x,	3;
	STORE_F	self,	parm0_x;
	CALL1		util_generateBuildingFoundation;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	building_die,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	building_radar_think,	temp_1;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	multi_trigger,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () hshield_die;
void () hshield_die1;
void() hshield_die = asm
{
local entity head;
local vector temp_0;
local float temp_1;
local float temp_3;
	STATE		FALSE,	hshield_die1;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	DAT_SFGA_DMG,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	head;
	IFNOT		head,	17;
	INDIRECT_F	head,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	head,	sh_cur,	temp_1;
	INDIRECT_F	head,	sh_cur,	temp_3;
	ADD_F		temp_3,	DAT_PAC_DMG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	head,	sh_cur,	temp_1;
	INDIRECT_F	head,	sh_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	head,	sh_cur,	temp_1;
	INDIRECT_F	head,	sh_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	head,	chain,	head;
	GOTO		-16;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	takedamage,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	DONE;
}

void () hshield_die2;
void() hshield_die1 = asm
{
	STATE		TRUE,	hshield_die2;
	DONE;
}

void () hshield_die3;
void() hshield_die2 = asm
{
	STATE		FL_SWIM,	hshield_die3;
	DONE;
}

void () hshield_die4;
void() hshield_die3 = asm
{
	STATE		MOVETYPE_WALK,	hshield_die4;
	DONE;
}

void () hshield_die5;
void() hshield_die4 = asm
{
	STATE		MOVETYPE_STEP,	hshield_die5;
	DONE;
}

void () hshield_die6;
void() hshield_die5 = asm
{
	STATE		MOVETYPE_FLY,	hshield_die6;
	DONE;
}

void () hshield_die7;
void() hshield_die6 = asm
{
	STATE		MOVETYPE_TOSS,	hshield_die7;
	DONE;
}

void () hshield_die8;
void() hshield_die7 = asm
{
	STATE		MOVETYPE_PUSH,	hshield_die8;
	DONE;
}

void () hshield_die9;
void() hshield_die8 = asm
{
	STATE		FL_CLIENT,	hshield_die9;
	DONE;
}

void () hshield_die10;
void() hshield_die9 = asm
{
	STATE		MOVETYPE_FLYMISSILE,	hshield_die10;
	DONE;
}

void () hshield_die11;
void() hshield_die10 = asm
{
	STATE		MOVETYPE_BOUNCE,	hshield_die11;
	DONE;
}

void() hshield_die11 = asm
{
	STATE		MOVETYPE_BOUNCEMISSILE,	BecomeExplosion;
	DONE;
}

void () hshield_th;
void() hshield_th = asm
{
local float pmod;
local float pdist;
local float mod;
local float dist;
local entity p;
local entity t;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	STATE		FALSE,	hshield_th;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_max,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	23;
	INDIRECT_F	self,	en_cur,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	20;
	ADDRESS	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_cur,	temp_3;
	INDIRECT_F	self,	sh_rate,	temp_4;
	MUL_F		temp_4,	FL_SWIM,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_3;
	INDIRECT_F	self,	sh_rate,	temp_4;
	DIV_F		temp_4,	FL_SWIM,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	flags,	parm0_x;
	STORE_F	FL_MONSTER,	parm1_x;
	CALL2		findchainflags;
	STORE_ENT	return_x,	t;
	IFNOT		t,	43;
	INDIRECT_F	t,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	37;
	NE_E		t,	self,	temp_1;
	IFNOT		temp_1,	35;
	INDIRECT_V	t,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	dist;
	LE		dist,	DAT_PRJ_ABT_VELOCITY,	temp_1;
	IFNOT		temp_1,	28;
	INDIRECT_F	self,	en_cur,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	25;
	INDIRECT_F	t,	sh_hit,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	22;
	INDIRECT_F	t,	sh_cur,	temp_1;
	INDIRECT_F	t,	sh_max,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	18;
	INDIRECT_F	self,	sh_rate,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	mod;
	ADDRESS	t,	sh_cur,	temp_1;
	INDIRECT_F	t,	sh_cur,	temp_3;
	ADD_F		temp_3,	mod,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_3;
	SUB_F		temp_3,	mod,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	t,	sh_cur,	temp_1;
	INDIRECT_F	t,	sh_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	t,	sh_cur,	temp_1;
	INDIRECT_F	t,	sh_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	t,	chain,	t;
	GOTO		-42;
	STORE_F	flags,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	CALL2		findchainflags;
	STORE_ENT	return_x,	p;
	IFNOT		p,	37;
	INDIRECT_F	p,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	31;
	INDIRECT_V	t,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	pdist;
	LE		pdist,	DAT_PRJ_ABT_VELOCITY,	temp_1;
	IFNOT		temp_1,	24;
	INDIRECT_F	self,	en_cur,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	21;
	INDIRECT_F	p,	sh_cur,	temp_1;
	INDIRECT_F	p,	sh_max,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	17;
	INDIRECT_F	self,	sh_rate,	pmod;
	ADDRESS	p,	sh_cur,	temp_1;
	INDIRECT_F	p,	sh_cur,	temp_3;
	ADD_F		temp_3,	pmod,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_3;
	SUB_F		temp_3,	pmod,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	p,	sh_cur,	temp_1;
	INDIRECT_F	p,	sh_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	p,	sh_cur,	temp_1;
	INDIRECT_F	p,	sh_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	p,	chain,	p;
	GOTO		-36;
	DONE;
}

void () building_shield;
void() building_shield = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	"Shield Generator",	temp_1;
	ADDRESS	self,	vec_size,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	FL_MONSTER,	temp_3;
	BITOR		temp_3,	FL_UNIT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	INDIRECT_F	self,	skin,	temp_1;
	STORE_F	DAT_BLD_H_SHIELDGEN_MODEL,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setCollider;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	parm0_x;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	parm1_x;
	STORE_F	TRUE,	parm2_x;
	STORE_F	STAT_PLR_ANG_X,	parm3_x;
	CALL4		util_setHealthArmor;
	STORE_F	self,	parm0_x;
	STORE_V	'-56.000000 -56.000000 0.000000',	parm1;
	STORE_V	'56.000000 56.000000 17.500000',	parm2;
	CALL3		setsize;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	DAT_PRJ_ABT_VELOCITY,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	DAT_HS_GEVL_RADAR_RANGE,	temp_1;
	ADDRESS	self,	scale,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_V	self,	angles_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_F	self,	mins_z,	temp_1;
	ADD_F		temp_1,	MOVETYPE_STEP,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	temp_1,	parm2_x;
	CALL3		util_dropToGround;
	STORE_F	self,	parm0_x;
	STORE_V	return,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	STORE_F	self,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_cornerSlopeCheck;
	IFNOT		return_x,	3;
	STORE_F	self,	parm0_x;
	CALL1		util_generateBuildingFoundation;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	hshield_die,	temp_1;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	multi_trigger,	temp_1;
	CALL0		hshield_th;
	DONE;
}

void () building_power_die;
void () hpower_die;
void () hpower_die1;
void() hpower_die = asm
{
local entity head;
local vector temp_0;
local float temp_1;
local float temp_3;
	STATE		FALSE,	hpower_die1;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	DAT_PRJ_MLGD_VELOCITY,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	head;
	IFNOT		head,	29;
	INDIRECT_F	head,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	head,	en_cur,	temp_1;
	INDIRECT_F	head,	en_cur,	temp_3;
	ADD_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	head,	en_cur,	temp_1;
	INDIRECT_F	head,	en_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	head,	en_cur,	temp_1;
	INDIRECT_F	head,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	head,	data_type,	temp_1;
	EQ_F		temp_1,	MOVETYPE_PUSH,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_F	head,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_F	head,	data_idx,	temp_1;
	NE_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	head,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_E	head,	chain,	head;
	GOTO		-28;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	takedamage,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	DONE;
}

void () hpower_die2;
void() hpower_die1 = asm
{
	STATE		TRUE,	hpower_die2;
	DONE;
}

void () hpower_die3;
void() hpower_die2 = asm
{
	STATE		FL_SWIM,	hpower_die3;
	DONE;
}

void () hpower_die4;
void() hpower_die3 = asm
{
	STATE		MOVETYPE_WALK,	hpower_die4;
	DONE;
}

void () hpower_die5;
void() hpower_die4 = asm
{
	STATE		MOVETYPE_STEP,	hpower_die5;
	DONE;
}

void () hpower_die6;
void() hpower_die5 = asm
{
	STATE		MOVETYPE_FLY,	hpower_die6;
	DONE;
}

void () hpower_die7;
void() hpower_die6 = asm
{
	STATE		MOVETYPE_TOSS,	hpower_die7;
	DONE;
}

void () hpower_die8;
void() hpower_die7 = asm
{
	STATE		MOVETYPE_PUSH,	hpower_die8;
	DONE;
}

void () hpower_die9;
void() hpower_die8 = asm
{
	STATE		FL_CLIENT,	hpower_die9;
	DONE;
}

void () hpower_die10;
void() hpower_die9 = asm
{
	STATE		MOVETYPE_FLYMISSILE,	hpower_die10;
	DONE;
}

void () hpower_die11;
void() hpower_die10 = asm
{
	STATE		MOVETYPE_BOUNCE,	hpower_die11;
	DONE;
}

void() hpower_die11 = asm
{
	STATE		MOVETYPE_BOUNCEMISSILE,	BecomeExplosion;
	DONE;
}

void () hpower_th;
void() hpower_th = asm
{
local entity t;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	STATE		FALSE,	hpower_th;
	INDIRECT_F	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	13;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	data_type,	parm0_x;
	STORE_F	MOVETYPE_PUSH,	parm1_x;
	CALL2		findchainfloat;
	STORE_ENT	return_x,	t;
	IFNOT		t,	18;
	INDIRECT_F	t,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	12;
	NE_E		t,	self,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_V	t,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	LE		return_x,	DAT_PRJ_MLGD_VELOCITY,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	t,	en_rate,	temp_1;
	INDIRECT_F	self,	en_rate,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	t,	chain,	t;
	GOTO		-17;
	DONE;
}

void () building_power;
void() building_power = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	"Power Generator",	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	FL_MONSTER,	temp_3;
	BITOR		temp_3,	FL_UNIT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	vec_size,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	INDIRECT_F	self,	skin,	temp_1;
	STORE_F	DAT_BLD_H_POWER_PLANT_MODEL,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setCollider;
	STORE_F	DAT_BLD_H_POWER_PLANT_HP,	parm0_x;
	STORE_F	DAT_BLD_H_POWER_PLANT_HP,	parm1_x;
	STORE_F	TRUE,	parm2_x;
	STORE_F	STAT_PLR_ANG_X,	parm3_x;
	CALL4		util_setHealthArmor;
	STORE_F	self,	parm0_x;
	STORE_V	'-75.000000 -75.000000 0.000000',	parm1;
	STORE_V	'75.000000 75.000000 26.000000',	parm2;
	CALL3		setsize;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	DAT_MTK_LTOR_HP,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	DAT_PRJ_ION_VELOCITY,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	scale,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_V	self,	angles_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_F	self,	mins_z,	temp_1;
	ADD_F		temp_1,	MOVETYPE_STEP,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	temp_1,	parm2_x;
	CALL3		util_dropToGround;
	STORE_F	self,	parm0_x;
	STORE_V	return,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	STORE_F	self,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_cornerSlopeCheck;
	IFNOT		return_x,	3;
	STORE_F	self,	parm0_x;
	CALL1		util_generateBuildingFoundation;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	hpower_die1,	temp_1;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	multi_trigger,	temp_1;
	CALL0		hpower_th;
	DONE;
}

void () building_human_hangar;
void() building_human_hangar = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	"Large Hangar",	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	FL_MONSTER,	temp_3;
	BITOR		temp_3,	FL_UNIT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	vec_size,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	takedamage,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	DAT_OTL_CTOR_HP,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	building_die,	temp_1;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	multi_trigger,	temp_1;
	STORE_F	DAT_HS_GEVL_RADAR_RANGE,	parm0_x;
	STORE_F	DAT_HS_GEVL_RADAR_RANGE,	parm1_x;
	STORE_F	TRUE,	parm2_x;
	STORE_F	STAT_PLR_ANG_X,	parm3_x;
	CALL4		util_setHealthArmor;
	INDIRECT_F	self,	skin,	temp_1;
	STORE_F	DAT_BLD_H_LG_HANGAR_MODEL,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	'-72.000000 -72.000000 0.000000',	parm1;
	STORE_V	'72.000000 72.000000 80.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	angles_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_F	self,	mins_z,	temp_1;
	ADD_F		temp_1,	MOVETYPE_STEP,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	temp_1,	parm2_x;
	CALL3		util_dropToGround;
	STORE_F	self,	parm0_x;
	STORE_V	return,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	STORE_F	self,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_cornerSlopeCheck;
	IFNOT		return_x,	3;
	STORE_F	self,	parm0_x;
	CALL1		util_generateBuildingFoundation;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	DONE;
}

void () hfuel_death1;
void () hfuel_death2;
void() hfuel_death1 = asm
{
local entity boom;
local vector exp;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	STATE		TRUE,	hfuel_death2;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	takedamage,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	CALL0		randomvec;
	STORE_V	return,	exp;
	INDIRECT_F	self,	mins_x,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_x,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_x,	temp_1,	temp_1;
	MUL_F		temp_1,	SHVBAL_EFFRAM_PERCENTAGE,	exp_x;
	INDIRECT_F	self,	mins_y,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_y,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_y,	temp_1,	temp_1;
	MUL_F		temp_1,	SHVBAL_EFFRAM_PERCENTAGE,	exp_y;
	INDIRECT_F	self,	mins_z,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_z,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_z,	temp_1,	temp_1;
	MUL_F		temp_1,	FL_SWIM,	exp_z;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_up,	exp_z,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_forward,	exp_y,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_right,	exp_x,	temp_2;
	ADD_V		temp_0,	temp_2,	exp;
	CALL0		spawn;
	STORE_ENT	return_x,	boom;
	ADDRESS	boom,	color_x,	temp_0_x;
	STOREP_V	DAT_PRJ_FLAK_COLORMOD_x,	temp_0;
	STORE_F	boom,	parm0_x;
	STORE_V	exp,	parm1;
	CALL2		setorigin;
	ADDRESS	boom,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	boom,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	DONE;
}

void () hfuel_death3;
void() hfuel_death2 = asm
{
	STATE		FL_SWIM,	hfuel_death3;
	DONE;
}

void () hfuel_death4;
void() hfuel_death3 = asm
{
	STATE		MOVETYPE_WALK,	hfuel_death4;
	DONE;
}

void () hfuel_death5;
void() hfuel_death4 = asm
{
local entity boom;
local vector exp;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	STATE		MOVETYPE_STEP,	hfuel_death5;
	CALL0		randomvec;
	STORE_V	return,	exp;
	INDIRECT_F	self,	mins_x,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_x,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_x,	temp_1,	temp_1;
	MUL_F		temp_1,	SHVBAL_EFFRAM_PERCENTAGE,	exp_x;
	INDIRECT_F	self,	mins_y,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_y,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_y,	temp_1,	temp_1;
	MUL_F		temp_1,	SHVBAL_EFFRAM_PERCENTAGE,	exp_y;
	INDIRECT_F	self,	mins_z,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_z,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_z,	temp_1,	temp_1;
	MUL_F		temp_1,	FL_SWIM,	exp_z;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_up,	exp_z,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_forward,	exp_y,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_right,	exp_x,	temp_2;
	ADD_V		temp_0,	temp_2,	exp;
	CALL0		spawn;
	STORE_ENT	return_x,	boom;
	ADDRESS	boom,	color_x,	temp_0_x;
	STOREP_V	DAT_PRJ_FLAK_COLORMOD_x,	temp_0;
	STORE_F	boom,	parm0_x;
	STORE_V	exp,	parm1;
	CALL2		setorigin;
	ADDRESS	boom,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	boom,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	DONE;
}

void () hfuel_death6;
void() hfuel_death5 = asm
{
	STATE		MOVETYPE_FLY,	hfuel_death6;
	DONE;
}

void () hfuel_death7;
void() hfuel_death6 = asm
{
	STATE		MOVETYPE_TOSS,	hfuel_death7;
	DONE;
}

void () hfuel_death8;
void() hfuel_death7 = asm
{
local entity boom;
local vector exp;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	STATE		MOVETYPE_PUSH,	hfuel_death8;
	CALL0		randomvec;
	STORE_V	return,	exp;
	INDIRECT_F	self,	mins_x,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_x,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_x,	temp_1,	temp_1;
	MUL_F		temp_1,	SHVBAL_EFFRAM_PERCENTAGE,	exp_x;
	INDIRECT_F	self,	mins_y,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_y,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_y,	temp_1,	temp_1;
	MUL_F		temp_1,	SHVBAL_EFFRAM_PERCENTAGE,	exp_y;
	INDIRECT_F	self,	mins_z,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_z,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_z,	temp_1,	temp_1;
	MUL_F		temp_1,	FL_SWIM,	exp_z;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_up,	exp_z,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_forward,	exp_y,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_right,	exp_x,	temp_2;
	ADD_V		temp_0,	temp_2,	exp;
	CALL0		spawn;
	STORE_ENT	return_x,	boom;
	ADDRESS	boom,	color_x,	temp_0_x;
	STOREP_V	DAT_PRJ_FLAK_COLORMOD_x,	temp_0;
	STORE_F	boom,	parm0_x;
	STORE_V	exp,	parm1;
	CALL2		setorigin;
	ADDRESS	boom,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	boom,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	DONE;
}

void () hfuel_death9;
void() hfuel_death8 = asm
{
	STATE		FL_CLIENT,	hfuel_death9;
	DONE;
}

void () hfuel_death10;
void() hfuel_death9 = asm
{
	STATE		MOVETYPE_FLYMISSILE,	hfuel_death10;
	DONE;
}

void () hfuel_death11;
void() hfuel_death10 = asm
{
local entity boom;
local vector exp;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	STATE		MOVETYPE_BOUNCE,	hfuel_death11;
	CALL0		randomvec;
	STORE_V	return,	exp;
	INDIRECT_F	self,	mins_x,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_x,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_x,	temp_1,	temp_1;
	MUL_F		temp_1,	SHVBAL_EFFRAM_PERCENTAGE,	exp_x;
	INDIRECT_F	self,	mins_y,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_y,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_y,	temp_1,	temp_1;
	MUL_F		temp_1,	SHVBAL_EFFRAM_PERCENTAGE,	exp_y;
	INDIRECT_F	self,	mins_z,	temp_1;
	SUB_F		FALSE,	temp_1,	temp_1;
	CALL0		random;
	INDIRECT_F	self,	maxs_z,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	MUL_F		exp_z,	temp_1,	temp_1;
	MUL_F		temp_1,	FL_SWIM,	exp_z;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_up,	exp_z,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_forward,	exp_y,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_right,	exp_x,	temp_2;
	ADD_V		temp_0,	temp_2,	exp;
	CALL0		spawn;
	STORE_ENT	return_x,	boom;
	ADDRESS	boom,	color_x,	temp_0_x;
	STOREP_V	DAT_PRJ_FLAK_COLORMOD_x,	temp_0;
	STORE_F	boom,	parm0_x;
	STORE_V	exp,	parm1;
	CALL2		setorigin;
	ADDRESS	boom,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	boom,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	DONE;
}

void () hfuel_death12;
void() hfuel_death11 = asm
{
	STATE		MOVETYPE_BOUNCEMISSILE,	hfuel_death12;
	DONE;
}

void() hfuel_death12 = asm
{
	STATE		MOVETYPE_FOLLOW,	BecomeExplosion;
	DONE;
}

void () building_fuel;
void() building_fuel = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	"Fuel Tank",	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	FL_MONSTER,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	vec_size,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	INDIRECT_F	self,	skin,	temp_1;
	STORE_F	DAT_BLD_H_FUELTANK_MODEL,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setCollider;
	STORE_F	DAT_PRJ_SFGA_RAD,	parm0_x;
	STORE_F	DAT_PRJ_SFGA_RAD,	parm1_x;
	STORE_F	TRUE,	parm2_x;
	STORE_F	STAT_PLR_ANG_X,	parm3_x;
	CALL4		util_setHealthArmor;
	STORE_F	self,	parm0_x;
	STORE_V	'-40.000000 -40.000000 0.000000',	parm1;
	STORE_V	'40.000000 40.000000 40.000000',	parm2;
	CALL3		setsize;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	scale,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_V	self,	angles_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_F	self,	mins_z,	temp_1;
	ADD_F		temp_1,	MOVETYPE_STEP,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	temp_1,	parm2_x;
	CALL3		util_dropToGround;
	STORE_F	self,	parm0_x;
	STORE_V	return,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	STORE_F	self,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_cornerSlopeCheck;
	IFNOT		return_x,	3;
	STORE_F	self,	parm0_x;
	CALL1		util_generateBuildingFoundation;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	hfuel_death1,	temp_1;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	multi_trigger,	temp_1;
	DONE;
}

void () building_repair_touch;
void () hrepair_th;
void() hrepair_th = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	STATE		FALSE,	hrepair_th;
	INDIRECT_E	self,	trigger_field,	temp_1;
	INDIRECT_F	temp_1,	takedamage,	temp_1;
	GE		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	5;
	INDIRECT_FU	self,	th_walk,	temp_1;
	CALL0		temp_1;
	RETURN	offset_0;
	GOTO		17;
	INDIRECT_F	self,	rl_cur,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	13;
	ADDRESS	self,	rl_cur,	temp_1;
	INDIRECT_F	self,	rl_cur,	temp_3;
	INDIRECT_F	self,	rl_rate,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	rl_cur,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	rl_cur,	temp_1;
	INDIRECT_F	self,	rl_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () hrepair_rep;
void() hrepair_rep = asm
{
local vector fx;
local float hp;
local float lowHP;
local entity part;
local entity fix;
local entity repairMe;
local float end_repair;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
local float temp_6;
	STATE		FALSE,	hrepair_rep;
	STORE_F	TRUE,	end_repair;
	INDIRECT_E	self,	trigger_field,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_0;
	INDIRECT_E	self,	e_cam,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	LE		return_x,	FL_INWATER,	temp_1;
	IFNOT		temp_1,	63;
	INDIRECT_E	self,	trigger_field,	repairMe;
	STORE_F	repairMe,	parm0_x;
	CALL1		csqc_updateCompStat;
	LT		return_x,	STAT_PLR_ANG_X,	temp_1;
	IFNOT		temp_1,	3;
	STORE_ENT	repairMe,	fix;
	GOTO		16;
	INDIRECT_E	repairMe,	c_part,	part;
	STORE_F	99.989998,	lowHP;
	IFNOT		part,	13;
	INDIRECT_F	part,	deadflag,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	8;
	STORE_F	part,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	return_x,	hp;
	LE		hp,	lowHP,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	hp,	lowHP;
	STORE_ENT	part,	fix;
	INDIRECT_E	part,	c_part,	part;
	GOTO		-12;
	IFNOT		fix,	40;
	STORE_F	FALSE,	end_repair;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_forward,	DAT_PRJ_FLAK_PROXYRAD,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_up,	STAT_PLR_ORG_X,	temp_2;
	ADD_V		temp_0,	temp_2,	fx;
	INDIRECT_V	fix,	origin_x,	temp_0;
	STORE_V	fx,	parm0;
	STORE_V	temp_0,	parm1;
	CALL2		te_beam_laser;
	ADDRESS	fix,	health,	temp_1;
	INDIRECT_F	fix,	health,	temp_3;
	INDIRECT_F	self,	rl_rate,	temp_4;
	MUL_F		temp_4,	FL_SWIM,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	INDIRECT_F	self,	rl_cur,	temp_3;
	INDIRECT_F	self,	rl_rate,	temp_4;
	INDIRECT_E	self,	trigger_field,	temp_6;
	INDIRECT_F	temp_6,	vec_size,	temp_6;
	MUL_F		temp_4,	temp_6,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	fix,	health,	temp_1;
	INDIRECT_F	fix,	max_health,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	fix,	health,	temp_1;
	INDIRECT_F	fix,	max_health,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	trigger_field,	temp_1;
	ADDRESS	temp_1,	stat_plr_rep,	temp_1;
	INDIRECT_F	self,	rl_cur,	temp_3;
	INDIRECT_F	self,	rl_max,	temp_4;
	DIV_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	IFNOT		end_repair,	19;
	INDIRECT_E	self,	trigger_field,	temp_1;
	INDIRECT_F	temp_1,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_E	self,	trigger_field,	parm0_x;
	STORE_F	"[Repairs complete]
",	parm1_x;
	CALL2		centerprint;
	INDIRECT_E	self,	trigger_field,	temp_1;
	ADDRESS	temp_1,	stat_plr_rep,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	INDIRECT_E	self,	trigger_field,	temp_1;
	ADDRESS	temp_1,	repair_request,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	trigger_field,	temp_1;
	STOREP_ENT	world,	temp_1;
	INDIRECT_FU	self,	th_stand,	temp_1;
	CALL0		temp_1;
	RETURN	offset_0;
	DONE;
}

void () hrepair_die;
void () hrepair_die1;
void() hrepair_die = asm
{
local entity head;
local vector temp_0;
local float temp_1;
local float temp_3;
	STATE		FALSE,	hrepair_die1;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	DAT_PRJ_MLGD_VELOCITY,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	head;
	IFNOT		head,	29;
	INDIRECT_F	head,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	head,	en_cur,	temp_1;
	INDIRECT_F	head,	en_cur,	temp_3;
	ADD_F		temp_3,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	head,	en_cur,	temp_1;
	INDIRECT_F	head,	en_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	head,	en_cur,	temp_1;
	INDIRECT_F	head,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	head,	data_type,	temp_1;
	EQ_F		temp_1,	MOVETYPE_PUSH,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_F	head,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_F	head,	data_idx,	temp_1;
	NE_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	head,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_E	head,	chain,	head;
	GOTO		-28;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	takedamage,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	DONE;
}

void () hrepair_die2;
void() hrepair_die1 = asm
{
	STATE		TRUE,	hrepair_die2;
	DONE;
}

void () hrepair_die3;
void() hrepair_die2 = asm
{
	STATE		FL_SWIM,	hrepair_die3;
	DONE;
}

void () hrepair_die4;
void() hrepair_die3 = asm
{
	STATE		MOVETYPE_WALK,	hrepair_die4;
	DONE;
}

void () hrepair_die5;
void() hrepair_die4 = asm
{
	STATE		MOVETYPE_STEP,	hrepair_die5;
	DONE;
}

void () hrepair_die6;
void() hrepair_die5 = asm
{
	STATE		MOVETYPE_FLY,	hrepair_die6;
	DONE;
}

void () hrepair_die7;
void() hrepair_die6 = asm
{
	STATE		MOVETYPE_TOSS,	hrepair_die7;
	DONE;
}

void () hrepair_die8;
void() hrepair_die7 = asm
{
	STATE		MOVETYPE_PUSH,	hrepair_die8;
	DONE;
}

void () hrepair_die9;
void() hrepair_die8 = asm
{
	STATE		FL_CLIENT,	hrepair_die9;
	DONE;
}

void () hrepair_die10;
void() hrepair_die9 = asm
{
	STATE		MOVETYPE_FLYMISSILE,	hrepair_die10;
	DONE;
}

void () hrepair_die11;
void() hrepair_die10 = asm
{
	STATE		MOVETYPE_BOUNCE,	hrepair_die11;
	DONE;
}

void() hrepair_die11 = asm
{
	STATE		MOVETYPE_BOUNCEMISSILE,	BecomeExplosion;
	DONE;
}

void () building_human_repair;
void() building_human_repair = asm
{
local entity this;
local entity nde;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local vector temp_5;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	"Repair Bay",	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	FL_MONSTER,	temp_3;
	BITOR		temp_3,	FL_UNIT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	vec_size,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	INDIRECT_F	self,	skin,	temp_1;
	STORE_F	DAT_BLD_H_REPAIR_MODEL,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	TRUE,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setCollider;
	STORE_F	DAT_MNT_RADAR_RANGE,	parm0_x;
	STORE_F	DAT_MNT_RADAR_RANGE,	parm1_x;
	STORE_F	TRUE,	parm2_x;
	STORE_F	STAT_PLR_ANG_X,	parm3_x;
	CALL4		util_setHealthArmor;
	STORE_F	self,	parm0_x;
	STORE_V	'-72.000000 -72.000000 0.000000',	parm1;
	STORE_V	'72.000000 72.000000 40.000000',	parm2;
	CALL3		setsize;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	DAT_BLD_H_REPAIR_SH_MAX,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	rl_cur,	temp_1;
	STOREP_F	DAT_HS_GEVL_RADAR_RANGE,	temp_1;
	ADDRESS	self,	rl_rate,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	rl_max,	temp_1;
	STOREP_F	DAT_HS_GEVL_RADAR_RANGE,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_V	self,	angles_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_F	self,	mins_z,	temp_1;
	ADD_F		temp_1,	MOVETYPE_STEP,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	temp_1,	parm2_x;
	CALL3		util_dropToGround;
	STORE_F	self,	parm0_x;
	STORE_V	return,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	multi_trigger,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_cornerSlopeCheck;
	IFNOT		return_x,	3;
	STORE_F	self,	parm0_x;
	CALL1		util_generateBuildingFoundation;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_2;
	MUL_VF	v_forward,	STAT_TARG_EID,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	INDIRECT_F	self,	maxs_y,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	temp_1;
	ADD_F		temp_1,	CONTENT_WATER,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	MUL_VF	v_right,	MOVETYPE_FLY,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	STORE_ENT	self,	this;
	CALL0		spawn;
	STORE_ENT	return_x,	nde;
	STORE_ENT	nde,	self;
	INDIRECT_F	self,	skin,	temp_1;
	STORE_F	"q3mdl/testball.md3",	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	FALSE,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setCollider;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	STORE_F	FALSE,	parm3_x;
	CALL4		util_setHealthArmor;
	STORE_F	self,	parm0_x;
	STORE_V	'-8.000000 -8.000000 -8.000000',	parm1;
	STORE_V	'8.000000 8.000000 8.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	this,	c_ofs_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	effects,	temp_1;
	INDIRECT_F	self,	effects,	temp_3;
	BITOR		temp_3,	FL_INWATER,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	building_repair_touch,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	trigger_field,	temp_1;
	STOREP_ENT	world,	temp_1;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	this,	temp_1;
	STORE_ENT	this,	self;
	ADDRESS	this,	e_cam,	temp_1;
	STOREP_ENT	nde,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	hrepair_die,	temp_1;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	hrepair_th,	temp_1;
	ADDRESS	self,	th_walk,	temp_1;
	STOREP_FNC	hrepair_rep,	temp_1;
	CALL0		hrepair_th;
	DONE;
}

void () building_repair_think;
void() building_repair_think = asm
{
	DONE;
}

void() building_repair_touch = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_V	other,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	LE		return_x,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	40;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	rl_cur,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	36;
	INDIRECT_F	other,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	33;
	INDIRECT_F	other,	i_faction,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	i_faction,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	28;
	STORE_F	other,	parm0_x;
	CALL1		util_getMechHpAverage;
	LT		return_x,	TRUE,	temp_1;
	IFNOT		temp_1,	24;
	INDIRECT_F	other,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	other,	parm0_x;
	STORE_F	"[Press 'E' to start REPAIR]
",	parm1_x;
	CALL2		centerprint;
	INDIRECT_F	other,	repair_request,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	trigger_field,	temp_1;
	STOREP_ENT	other,	temp_1;
	ADDRESS	other,	velocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	other,	avelocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	other,	v_angle_x,	temp_0_x;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_V	temp_1,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	other,	angles_x,	temp_0_x;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_V	temp_1,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	RETURN	offset_0;
	DONE;
}

void () building_repair_die;
void() building_repair_die = asm
{
local float temp_1;
	INDIRECT_E	self,	e_cam,	temp_1;
	ADDRESS	temp_1,	trigger_field,	temp_1;
	STOREP_ENT	world,	temp_1;
	INDIRECT_E	self,	e_cam,	parm0_x;
	CALL1		remove;
	CALL0		building_die;
	DONE;
}

void () data_tur_hlite_ini;
void () data_tur_hlite_ctor;
void () data_tur_hlite_cam;
void () data_tur_hlite_wep1;
void () data_tur_hlite_wep2;
void() data_tur_hlite_ini = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	unit_ctor,	temp_1;
	STOREP_FNC	data_tur_hlite_ctor,	temp_1;
	ADDRESS	self,	unit_wep1,	temp_1;
	STOREP_FNC	data_tur_hlite_wep1,	temp_1;
	ADDRESS	self,	unit_wep2,	temp_1;
	STOREP_FNC	data_tur_hlite_wep2,	temp_1;
	ADDRESS	self,	unit_cam,	temp_1;
	STOREP_FNC	data_tur_hlite_cam,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	vec_name,	temp_1;
	STOREP_S	DAT_TUR_HLITE_NAME,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	DAT_PRJ_ABT_VELOCITY,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	0.250000,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	0.250000,	temp_1;
	ADDRESS	self,	yaw_speed,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	mins_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_BBN_x,	temp_0;
	ADDRESS	self,	maxs_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_BBX_x,	temp_0;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_SPREAD_x,	temp_0;
	ADDRESS	self,	ai_pitch_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_PITCH_x,	temp_0;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_TUR_HLITE_BASE,	temp_1;
	DONE;
}

void() data_tur_hlite_ctor = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	comp_id,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_TUR_HLITE_TUR,	temp_1;
	ADDRESS	self,	yaw_speed,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	attack_state,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	'0.000000 8.000000 0.000000',	temp_0;
	DONE;
}

void() data_tur_hlite_wep1 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_OFFSET_ALT_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP1_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

void() data_tur_hlite_wep2 = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP2_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP2_OFFSET_ALT_x,	temp_0;
	ADDRESS	self,	w_adj_ang_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_WEP2_ADJ_ANG_x,	temp_0;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	DONE;
}

void() data_tur_hlite_cam = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	c_parent,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_CAM_OFFSET_x,	temp_0;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	DAT_TUR_HLITE_CAM_OFFSET_ALT_x,	temp_0;
	ADDRESS	self,	c_model,	temp_1;
	STOREP_S	DAT_TUR_HLITE_CAM,	temp_1;
	DONE;
}

void() ai_unit_ini_var = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_legs_hp,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_ctor_hp,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_ltor_hp,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_rtor_hp,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_larm_hp,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_rarm_hp,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	was_hit,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	hitdir_buffer,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_hit_dirs,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_rdr_mode,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	accuracy,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	accuracyMod,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_lck_stt,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	power_timer,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	ideal_yaw,	temp_1;
	INDIRECT_V	self,	angles_x,	temp_0;
	MUL_V		temp_0,	DAT_OTL_CAM_OFFSET_ALT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	maxpatience,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	patience,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	ai_viewcheck,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	ai_view,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	ai_action_mod,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	ai_viewtime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	ai_minrange,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	ai_hunt_total,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	DONE;
}

void(float rank) ai_pilot_ini_stats = asm
{
local float locked_2932;
local float locked_2939;
local float mod_yaw;
local float mod_sh;
local float mod_am;
local vector temp_2;
local float temp_3;
local float temp_4;
	ADDRESS	self,	ai_rank,	locked_2932;
	STOREP_F	skill,	locked_2932;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	FL_NOTARGET,	locked_2932;
	IFNOT		locked_2932,	10;
	ADDRESS	self,	ai_rank,	locked_2932;
	INDIRECT_F	self,	ai_rank,	temp_3;
	ADD_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	GT		locked_2932,	MOVETYPE_WALK,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	ai_rank,	locked_2932;
	STOREP_F	MOVETYPE_WALK,	locked_2932;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	FL_ITEM,	locked_2932;
	IFNOT		locked_2932,	10;
	ADDRESS	self,	ai_rank,	locked_2932;
	INDIRECT_F	self,	ai_rank,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LT		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	ai_rank,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	ADDRESS	self,	ai_fov,	locked_2932;
	STORE_F	rank,	parm0_x;
	CALL1		ai_pilot_optical_range;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_view,	locked_2932;
	STORE_F	rank,	parm0_x;
	CALL1		ai_pilot_view_range;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_viewcheck,	locked_2932;
	STORE_F	rank,	parm0_x;
	CALL1		ai_pilot_view_interval;
	STOREP_F	return_x,	locked_2932;
	CALL0		ai_wep_calcranges;
	CALL0		ai_pilot_armor_mod;
	STORE_F	return_x,	mod_am;
	ADDRESS	self,	max_health,	locked_2932;
	ADDRESS	self,	health,	temp_3;
	INDIRECT_F	self,	health,	temp_4;
	MUL_F		temp_4,	mod_am,	temp_4;
	STOREP_F	temp_4,	temp_3;
	STOREP_F	temp_4,	locked_2932;
	INDIRECT_E	self,	e_legs,	locked_2932;
	ADDRESS	locked_2932,	max_health,	locked_2932;
	INDIRECT_E	self,	e_legs,	temp_3;
	ADDRESS	temp_3,	health,	temp_3;
	INDIRECT_E	self,	e_legs,	temp_4;
	INDIRECT_F	temp_4,	health,	temp_4;
	MUL_F		temp_4,	mod_am,	temp_4;
	STOREP_F	temp_4,	temp_3;
	STOREP_F	temp_4,	locked_2932;
	INDIRECT_E	self,	e_tor_l,	locked_2932;
	ADDRESS	locked_2932,	max_health,	locked_2932;
	INDIRECT_E	self,	e_tor_l,	temp_3;
	ADDRESS	temp_3,	health,	temp_3;
	INDIRECT_E	self,	e_tor_l,	temp_4;
	INDIRECT_F	temp_4,	health,	temp_4;
	MUL_F		temp_4,	mod_am,	temp_4;
	STOREP_F	temp_4,	temp_3;
	STOREP_F	temp_4,	locked_2932;
	INDIRECT_E	self,	e_tor_r,	locked_2932;
	ADDRESS	locked_2932,	max_health,	locked_2932;
	INDIRECT_E	self,	e_tor_r,	temp_3;
	ADDRESS	temp_3,	health,	temp_3;
	INDIRECT_E	self,	e_tor_r,	temp_4;
	INDIRECT_F	temp_4,	health,	temp_4;
	MUL_F		temp_4,	mod_am,	temp_4;
	STOREP_F	temp_4,	temp_3;
	STOREP_F	temp_4,	locked_2932;
	INDIRECT_E	self,	e_arm_r,	locked_2932;
	ADDRESS	locked_2932,	max_health,	locked_2932;
	INDIRECT_E	self,	e_arm_r,	temp_3;
	ADDRESS	temp_3,	health,	temp_3;
	INDIRECT_E	self,	e_arm_r,	temp_4;
	INDIRECT_F	temp_4,	health,	temp_4;
	MUL_F		temp_4,	mod_am,	temp_4;
	STOREP_F	temp_4,	temp_3;
	STOREP_F	temp_4,	locked_2932;
	INDIRECT_E	self,	e_arm_l,	locked_2932;
	ADDRESS	locked_2932,	max_health,	locked_2932;
	INDIRECT_E	self,	e_arm_l,	temp_3;
	ADDRESS	temp_3,	health,	temp_3;
	INDIRECT_E	self,	e_arm_l,	temp_4;
	INDIRECT_F	temp_4,	health,	temp_4;
	MUL_F		temp_4,	mod_am,	temp_4;
	STOREP_F	temp_4,	temp_3;
	STOREP_F	temp_4,	locked_2932;
	CALL0		ai_pilot_shield_mod;
	STORE_F	return_x,	mod_sh;
	ADDRESS	self,	sh_max,	locked_2932;
	ADDRESS	self,	sh_cur,	temp_3;
	INDIRECT_F	self,	sh_cur,	temp_4;
	MUL_F		temp_4,	mod_sh,	temp_4;
	STOREP_F	temp_4,	temp_3;
	STOREP_F	temp_4,	locked_2932;
	INDIRECT_F	self,	yaw_speed,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	9;
	CALL0		ai_pilot_yaw_mod;
	STORE_F	return_x,	mod_yaw;
	ADDRESS	self,	yaw_speed,	locked_2932;
	INDIRECT_F	self,	m_rot_speed,	temp_3;
	INDIRECT_F	self,	m_rot_speed,	temp_4;
	MUL_F		temp_4,	mod_yaw,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	ai_leading,	locked_2932;
	CALL0		ai_pilot_rating_leading;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	spreadDefault_x,	locked_2939;
	INDIRECT_V	self,	spreadDefault_x,	temp_2;
	STORE_F	skill,	parm0_x;
	STORE_V	temp_2,	parm1;
	CALL2		ai_pilot_accuracy;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	accuracy,	locked_2932;
	INDIRECT_F	self,	spreadDefault_y,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	stat_rdr_mode,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	ADDRESS	self,	maxpatience,	locked_2932;
	CALL0		ai_pilot_rating_patience;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_action_mod,	locked_2932;
	STORE_F	rank,	parm0_x;
	CALL1		ai_pilot_action_mod;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_attack_chance,	locked_2932;
	STORE_F	rank,	parm0_x;
	CALL1		ai_pilot_attack_interval;
	STOREP_F	return_x,	locked_2932;
	DONE;
}

float(float rank) ai_pilot_optical_range = asm
{
local float diff;
local float temp_1;
	STORE_F	"skill",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	diff;
	DIV_F		diff,	MOVETYPE_BOUNCE,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	diff;
	GOTO		9;
	ADD_F		diff,	0.500000,	diff;
	GOTO		15;
	ADD_F		diff,	AI_DMG_SKILL_VET,	diff;
	GOTO		13;
	ADD_F		diff,	DAT_EQP_LSAR_EN_RATE,	diff;
	GOTO		11;
	ADD_F		diff,	DAT_LATC_RL_RATE,	diff;
	GOTO		9;
	NE_F		rank,	FALSE,	temp_1;
	IFNOT		temp_1,	-9;
	EQ_F		rank,	TRUE,	temp_1;
	IF		temp_1,	-9;
	EQ_F		rank,	FL_SWIM,	temp_1;
	IF		temp_1,	-9;
	EQ_F		rank,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-9;
	RETURN	diff;
	DONE;
}

float(float rank) ai_pilot_view_range = asm
{
local float skl;
local float val;
local float temp_1;
	STORE_F	"skill",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	skl;
	GOTO		9;
	STORE_F	DAT_MNT_CTOR_HP,	val;
	GOTO		15;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	val;
	GOTO		13;
	STORE_F	DAT_PRJ_MLGD_VELOCITY,	val;
	GOTO		11;
	STORE_F	DAT_SFGA_DMG,	val;
	GOTO		9;
	NE_F		rank,	FALSE,	temp_1;
	IFNOT		temp_1,	-9;
	EQ_F		rank,	TRUE,	temp_1;
	IF		temp_1,	-9;
	EQ_F		rank,	FL_SWIM,	temp_1;
	IF		temp_1,	-9;
	EQ_F		rank,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-9;
	GT		skl,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADD_F		skl,	TRUE,	temp_1;
	MUL_F		val,	temp_1,	val;
	RETURN	val;
	DONE;
}

float(float rank, float damg) ai_pilot_mod_damage = asm
{
local float percent;
local float temp_1;
	GOTO		9;
	STORE_F	0.225000,	percent;
	GOTO		15;
	STORE_F	0.350000,	percent;
	GOTO		13;
	STORE_F	0.475000,	percent;
	GOTO		11;
	STORE_F	DAT_LAS_RL_RATE,	percent;
	GOTO		9;
	NE_F		rank,	FALSE,	temp_1;
	IFNOT		temp_1,	-9;
	EQ_F		rank,	TRUE,	temp_1;
	IF		temp_1,	-9;
	EQ_F		rank,	FL_SWIM,	temp_1;
	IF		temp_1,	-9;
	EQ_F		rank,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-9;
	MUL_F		damg,	percent,	percent;
	LT		percent,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	MOVETYPE_WALK,	percent;
	RETURN	percent;
	DONE;
}

float(float rank) ai_pilot_view_interval = asm
{
local float mod;
local float temp_1;
	MUL_F		rank,	FL_SWIM,	mod;
	GOTO		9;
	SUB_F		FL_SWIM,	mod,	mod;
	GOTO		15;
	SUB_F		MOVETYPE_STEP,	mod,	mod;
	GOTO		13;
	SUB_F		MOVETYPE_TOSS,	mod,	mod;
	GOTO		11;
	SUB_F		FL_CLIENT,	mod,	mod;
	GOTO		9;
	NE_F		rank,	FALSE,	temp_1;
	IFNOT		temp_1,	-9;
	EQ_F		rank,	TRUE,	temp_1;
	IF		temp_1,	-9;
	EQ_F		rank,	FL_SWIM,	temp_1;
	IF		temp_1,	-9;
	EQ_F		rank,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-9;
	RETURN	mod;
	DONE;
}

float(float rank) ai_pilot_action_mod = asm
{
local float mod;
local float temp_1;
	DIV_F		rank,	FL_SWIM,	mod;
	GOTO		9;
	ADD_F		0.250000,	mod,	mod;
	GOTO		15;
	ADD_F		DAT_LATC_RL_RATE,	mod,	mod;
	GOTO		13;
	ADD_F		ARM_HV_MOD,	mod,	mod;
	GOTO		11;
	ADD_F		0.100000,	mod,	mod;
	GOTO		9;
	NE_F		rank,	FALSE,	temp_1;
	IFNOT		temp_1,	-9;
	EQ_F		rank,	TRUE,	temp_1;
	IF		temp_1,	-9;
	EQ_F		rank,	FL_SWIM,	temp_1;
	IF		temp_1,	-9;
	EQ_F		rank,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-9;
	LT		mod,	0.100000,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	0.100000,	mod;
	RETURN	mod;
	DONE;
}

float() ai_pilot_yaw_mod = asm
{
local float temp_1;
	INDIRECT_F	self,	ai_rank,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	0.100000;
	GOTO		17;
	INDIRECT_F	self,	ai_rank,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	DAT_LATC_RL_RATE;
	GOTO		12;
	INDIRECT_F	self,	ai_rank,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	DAT_EQP_LSAR_EN_RATE;
	GOTO		7;
	INDIRECT_F	self,	ai_rank,	temp_1;
	EQ_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	AI_DMG_SKILL_VET;
	GOTO		2;
	RETURN	TRUE;
	DONE;
}

float() ai_pilot_armor_mod = asm
{
local float temp_1;
	EQ_F		skill,	TRUE,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	AI_DMG_SKILL_VET;
	GOTO		10;
	EQ_F		skill,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	0.500000;
	GOTO		6;
	EQ_F		skill,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	DAT_LAS_RL_RATE;
	GOTO		2;
	RETURN	DAT_EQP_LSAR_EN_RATE;
	DONE;
}

float() ai_pilot_shield_mod = asm
{
local float temp_1;
	EQ_F		skill,	TRUE,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	DAT_LAS_RL_RATE;
	GOTO		10;
	EQ_F		skill,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	AI_SHIELD_HARD;
	GOTO		6;
	EQ_F		skill,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	TRUE;
	GOTO		2;
	RETURN	AI_DMG_SKILL_VET;
	DONE;
}

float() ai_pilot_rating_leading = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	ai_rank,	temp_1;
	GOTO		5;
	RETURN	AI_LEAD_ACE;
	RETURN	AI_LEAD_VET;
	RETURN	0.100000;
	RETURN	DAT_ION_RL_RATE;
	NE_F		temp_1,	FALSE,	temp_3;
	IFNOT		temp_3,	-5;
	EQ_F		temp_1,	TRUE,	temp_3;
	IF		temp_3,	-6;
	EQ_F		temp_1,	FL_SWIM,	temp_3;
	IF		temp_3,	-7;
	GOTO		-7;
	DONE;
}

float() ai_pilot_rating_patience = asm
{
local float ePatience;
local float temp_1;
	INDIRECT_F	self,	ai_rank,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	STAT_PLR_ORG_X,	ePatience;
	GOTO		17;
	INDIRECT_F	self,	ai_rank,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	SVC_INTERMISSION,	ePatience;
	GOTO		12;
	INDIRECT_F	self,	ai_rank,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	20.000000,	ePatience;
	GOTO		7;
	INDIRECT_F	self,	ai_rank,	temp_1;
	EQ_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	MOVETYPE_BOUNCE,	ePatience;
	GOTO		2;
	STORE_F	MOVETYPE_BOUNCE,	ePatience;
	DIV_F		skill,	STAT_PLR_ANG_X,	temp_1;
	MUL_F		ePatience,	temp_1,	temp_1;
	ADD_F		ePatience,	temp_1,	ePatience;
	RETURN	ePatience;
	DONE;
}

float(float rank) ai_pilot_attack_interval = asm
{
local float interval;
local float temp_1;
	GOTO		9;
	STORE_F	DAT_EQP_LSAR_EN_RATE,	interval;
	GOTO		15;
	STORE_F	0.500000,	interval;
	GOTO		13;
	STORE_F	0.700000,	interval;
	GOTO		11;
	STORE_F	0.900000,	interval;
	GOTO		9;
	NE_F		skill,	FALSE,	temp_1;
	IFNOT		temp_1,	-9;
	EQ_F		skill,	TRUE,	temp_1;
	IF		temp_1,	-9;
	EQ_F		skill,	FL_SWIM,	temp_1;
	IF		temp_1,	-9;
	EQ_F		skill,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-9;
	RETURN	interval;
	DONE;
}

vector(float rank, vector spread) ai_pilot_accuracy = asm
{
local float modRate;
local float modMax;
local float modMin;
local vector accuracy;
local vector temp_0;
local float temp_1;
	STORE_F	accuracy_x,	modMin;
	STORE_F	accuracy_y,	modMax;
	STORE_F	accuracy_z,	modRate;
	GOTO		17;
	MUL_F		modMin,	0.250000,	modMin;
	MUL_F		modMax,	0.500000,	modMax;
	MUL_F		modRate,	0.500000,	modRate;
	GOTO		21;
	MUL_F		modMin,	ARM_HV_MOD,	modMin;
	MUL_F		modMax,	AI_DMG_SKILL_VET,	modMax;
	MUL_F		modRate,	0.250000,	modRate;
	GOTO		17;
	MUL_F		modMin,	0.250000,	modMin;
	MUL_F		modMax,	0.500000,	modMax;
	MUL_F		modRate,	ARM_HV_MOD,	modRate;
	GOTO		13;
	MUL_F		modMin,	ARM_LT_MOD,	modMin;
	MUL_F		modMax,	0.100000,	modMax;
	MUL_F		modRate,	ARM_LT_MOD,	modRate;
	GOTO		9;
	NE_F		rank,	FALSE,	temp_1;
	IFNOT		temp_1,	-17;
	EQ_F		rank,	TRUE,	temp_1;
	IF		temp_1,	-15;
	EQ_F		rank,	FL_SWIM,	temp_1;
	IF		temp_1,	-13;
	EQ_F		rank,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-11;
	MUL_F		modRate,	CONTENT_EMPTY,	modRate;
	ADD_F		accuracy_x,	modMin,	accuracy_x;
	ADD_F		accuracy_y,	modMax,	accuracy_y;
	ADD_F		accuracy_z,	modRate,	accuracy_z;
	ADD_V		accuracy,	spread,	accuracy;
	RETURN	accuracy_x;
	DONE;
}

float() ai_can_spawn = asm
{
local float gameMode;
local float yesWecan;
local float temp_1;
local float temp_3;
	STORE_F	FALSE,	yesWecan;
	STORE_F	"gamemode",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	gameMode;
	INDIRECT_F	self,	nextVecChoice,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	10;
	NOT_F		coop,	temp_1;
	IFNOT		temp_1,	2;
	NOT_F		deathmatch,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	NOT_F		teamplay,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	yesWecan;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	6;
	IFNOT		coop,	2;
	NOT_F		deathmatch,	temp_1;
	AND		coop,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	yesWecan;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	6;
	NOT_F		coop,	temp_1;
	IFNOT		temp_1,	1;
	AND		temp_1,	deathmatch,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	yesWecan;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	5;
	IFNOT		deathmatch,	1;
	AND		deathmatch,	teamplay,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	yesWecan;
	GOTO		21;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_ONGROUND,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	FALSE,	yesWecan;
	GOTO		24;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_PARTIALGROUND,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	FALSE,	yesWecan;
	GOTO		19;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_WATERJUMP,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	FALSE,	yesWecan;
	GOTO		14;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_JUMPRELEASED,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	FALSE,	yesWecan;
	GOTO		9;
	NE_F		skill,	FALSE,	temp_1;
	IFNOT		temp_1,	-21;
	EQ_F		skill,	TRUE,	temp_1;
	IF		temp_1,	-18;
	EQ_F		skill,	FL_SWIM,	temp_1;
	IF		temp_1,	-15;
	EQ_F		skill,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-12;
	RETURN	yesWecan;
	DONE;
}

float(entity t) ai_valid_target = asm
{
local float temp_1;
local float temp_3;
	IFNOT		t,	19;
	INDIRECT_F	t,	flags,	temp_1;
	BITAND	temp_1,	FL_NOTARGET,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	INDIRECT_F	t,	deadflag,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_F	t,	data_type,	temp_1;
	GOTO		4;
	RETURN	TRUE;
	RETURN	TRUE;
	RETURN	TRUE;
	EQ_F		temp_1,	MOVETYPE_WALK,	temp_3;
	IF		temp_3,	-4;
	EQ_F		temp_1,	MOVETYPE_PUSH,	temp_3;
	IF		temp_3,	-5;
	EQ_F		temp_1,	FL_SWIM,	temp_3;
	IF		temp_3,	-6;
	RETURN	FALSE;
	DONE;
}

entity(float radiius) ai_find_friend = asm
{
local float rad;
local float dist;
local entity friend;
local entity this;
local entity ally;
local vector temp_0;
local float temp_1;
local vector temp_2;
	STORE_ENT	self,	this;
	STORE_F	radiius,	rad;
	INDIRECT_F	self,	i_faction,	temp_1;
	STORE_F	i_faction,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		findchainfloat;
	STORE_ENT	return_x,	ally;
	IFNOT		ally,	18;
	INDIRECT_V	ally,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	dist;
	LE		dist,	rad,	temp_1;
	IFNOT		temp_1,	9;
	STORE_F	dist,	rad;
	STORE_F	ally,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	5;
	INDIRECT_E	ally,	w_slot,	temp_1;
	NE_E		temp_1,	world,	temp_1;
	IFNOT		temp_1,	2;
	STORE_ENT	ally,	friend;
	INDIRECT_E	ally,	chain,	ally;
	GOTO		-17;
	RETURN	friend;
	DONE;
}

float() ai_find_target_visual = asm
{
local float ndist;
local float rng;
local float dist;
local entity found;
local entity targ;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_E	self,	enemy,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_F	self,	ai_view,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_1,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	targ;
	INDIRECT_F	self,	ai_view,	dist;
	STORE_F	dist,	rng;
	IFNOT		targ,	32;
	STORE_F	targ,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	27;
	INDIRECT_F	targ,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	NE_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	23;
	INDIRECT_F	self,	ai_fov,	temp_1;
	STORE_F	targ,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	18;
	STORE_F	targ,	parm0_x;
	CALL1		ai_check_vis;
	IFNOT		return_x,	15;
	INDIRECT_V	targ,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	ndist;
	INDIRECT_F	targ,	fog_alpha,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_F	targ,	fog_alpha,	temp_1;
	MUL_F		temp_1,	rng,	temp_1;
	SUB_F		rng,	temp_1,	rng;
	LT		ndist,	rng,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	ndist,	rng;
	STORE_ENT	targ,	found;
	INDIRECT_E	targ,	chain,	targ;
	GOTO		-31;
	IFNOT		found,	9;
	INDIRECT_E	self,	enemy,	temp_1;
	EQ_E		found,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	found,	temp_1;
	CALL0		ai_found_target;
	RETURN	TRUE;
	RETURN	FALSE;
	DONE;
}

float() ai_find_target_radar = asm
{
local float nrng;
local float ndist;
local float rng;
local float dist;
local entity found;
local entity targ;
local vector temp_0;
local float temp_1;
local vector temp_2;
	STORE_F	flags,	parm0_x;
	STORE_F	FL_UNIT,	parm1_x;
	CALL2		findchainflags;
	STORE_ENT	return_x,	targ;
	INDIRECT_F	self,	radar_range,	dist;
	STORE_F	dist,	rng;
	INDIRECT_F	self,	stat_rdr_mode,	temp_1;
	IFNOT		temp_1,	2;
	MUL_F		rng,	FL_SWIM,	rng;
	IFNOT		targ,	30;
	STORE_F	targ,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	25;
	STORE_F	rng,	nrng;
	INDIRECT_V	targ,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	ndist;
	LE		ndist,	rng,	temp_1;
	IFNOT		temp_1,	17;
	INDIRECT_F	targ,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_F	targ,	stat_rdr_mode,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	6;
	DIV_F		nrng,	FL_SWIM,	temp_1;
	LE		ndist,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	ndist,	nrng;
	STORE_ENT	targ,	found;
	GOTO		5;
	LT		ndist,	nrng,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	ndist,	nrng;
	STORE_ENT	targ,	found;
	INDIRECT_E	targ,	chain,	targ;
	GOTO		-29;
	IFNOT		found,	9;
	INDIRECT_E	self,	enemy,	temp_1;
	EQ_E		found,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	found,	temp_1;
	CALL0		ai_found_target;
	RETURN	TRUE;
	RETURN	FALSE;
	DONE;
}

void(entity ally, entity targ, float override) ai_give_target = asm
{
local entity this;
local float temp_1;
local float temp_3;
	STORE_ENT	self,	this;
	INDIRECT_E	ally,	enemy,	temp_1;
	NOT_ENT	temp_1,	temp_1;
	IF		temp_1,	1;
	OR		temp_1,	override,	temp_1;
	IFNOT		temp_1,	7;
	STORE_ENT	ally,	self;
	ADDRESS	self,	enemy,	temp_1;
	INDIRECT_E	this,	enemy,	temp_3;
	STOREP_ENT	temp_3,	temp_1;
	CALL0		ai_found_target;
	STORE_ENT	this,	self;
	DONE;
}

float() ai_panic_time = asm
{
local float panic;
local float temp_1;
	SUB_F		MOVETYPE_STEP,	skill,	panic;
	INDIRECT_F	self,	ai_rank,	temp_1;
	SUB_F		MOVETYPE_WALK,	temp_1,	temp_1;
	ADD_F		panic,	temp_1,	panic;
	CALL0		random;
	MUL_F		FL_SWIM,	return_x,	temp_1;
	ADD_F		panic,	temp_1,	panic;
	RETURN	panic;
	DONE;
}

vector(entity wep) ai_attack_trace = asm
{
local vector cam_ofs;
local vector lead;
local entity cam;
local vector temp_0;
local float temp_1;
local vector temp_2;
local vector temp_5;
	STORE_V	'1.000000 1.000000 1.000000',	lead;
	INDIRECT_E	self,	enemy,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_0;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_V	temp_1,	velocity_x,	temp_2;
	INDIRECT_F	self,	ai_leading,	temp_1;
	MUL_VF	temp_2,	temp_1,	temp_2;
	SUB_V		temp_0,	temp_2,	lead;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		lead,	temp_0,	parm0;
	CALL1		normalize;
	STORE_V	return,	lead;
	INDIRECT_E	self,	e_cam,	cam;
	INDIRECT_V	self,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	cam,	origin_x,	temp_0;
	MUL_VF	v_forward,	TRUE,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_F	wep,	w_range,	temp_1;
	MUL_VF	lead,	temp_1,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	RETURN	trace_endpos_x;
	DONE;
}

void() ai_ranged_attack = asm
{
local float locked_2939;
local float fired;
local entity this;
local entity wep_chain;
local float temp_1;
local vector temp_2;
local float temp_3;
	STORE_ENT	self,	this;
	INDIRECT_E	self,	w_slot,	wep_chain;
	ADDRESS	self,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_TURRET,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	v_angle_x,	locked_2939;
	INDIRECT_E	self,	e_tor_c,	temp_1;
	INDIRECT_V	temp_1,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	IFNOT		wep_chain,	55;
	INDIRECT_F	self,	button0,	temp_1;
	IFNOT		temp_1,	41;
	INDIRECT_F	wep_chain,	w_state,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	37;
	INDIRECT_F	self,	currentWeaponGroup,	temp_1;
	INDIRECT_F	wep_chain,	w_group,	temp_3;
	BITAND	temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	33;
	INDIRECT_F	self,	stat_trg_dist,	temp_1;
	INDIRECT_F	wep_chain,	w_range,	temp_3;
	LE		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	29;
	ADDRESS	self,	w_fire_ofs_x,	locked_2939;
	STORE_F	wep_chain,	parm0_x;
	CALL1		ai_attack_trace;
	STOREP_V	return_x,	locked_2939;
	STORE_F	wep_chain,	parm0_x;
	CALL1		ai_attack_blockcheck;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	21;
	STORE_F	wep_chain,	parm0_x;
	CALL1		ai_attack_checkEne;
	IFNOT		return_x,	18;
	STORE_ENT	wep_chain,	self;
	INDIRECT_F	self,	p_dmgtype,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_E	this,	enemy,	temp_1;
	INDIRECT_F	temp_1,	sh_cur,	temp_1;
	INDIRECT_F	self,	p_damage,	temp_3;
	GE		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADD_F		fired,	TRUE,	fired;
	INDIRECT_FU	self,	w_attack,	temp_1;
	CALL0		temp_1;
	GOTO		4;
	ADD_F		fired,	TRUE,	fired;
	INDIRECT_FU	self,	w_attack,	temp_1;
	CALL0		temp_1;
	STORE_ENT	this,	self;
	GOTO		11;
	INDIRECT_F	wep_chain,	w_isburst,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	8;
	INDIRECT_F	wep_chain,	w_state,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	STORE_ENT	wep_chain,	self;
	INDIRECT_FU	self,	w_attack,	temp_1;
	CALL0		temp_1;
	STORE_ENT	this,	self;
	INDIRECT_E	wep_chain,	w_slot,	wep_chain;
	GOTO		-54;
	DONE;
}

void(entity bot, entity attacker) ai_damage_react = asm
{
local float locked_916;
local float locked_2932;
local float dst2;
local float dst1;
local float odds;
local float panic;
local float howAmIDoing;
local float change;
local entity friend;
local entity this;
local vector temp_0;
local vector temp_2;
	INDIRECT_F	bot,	attack_state,	locked_2932;
	EQ_F		locked_2932,	IMP_SWEAPON1,	locked_2932;
	IFNOT		locked_2932,	2;
	RETURN	offset_0;
	STORE_F	bot,	parm0_x;
	STORE_F	trigOnDamage,	parm1_x;
	CALL2		trigger_event;
	STORE_ENT	self,	this;
	STORE_ENT	bot,	self;
	STORE_F	FALSE,	panic;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_NOSHOOT,	locked_2932;
	IFNOT		locked_2932,	2;
	STORE_F	TRUE,	panic;
	STORE_F	bot,	parm0_x;
	CALL1		util_getMechHpAverage;
	STORE_F	return_x,	howAmIDoing;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	GOTO		9;
	STORE_F	0.650000,	odds;
	GOTO		15;
	STORE_F	0.450000,	odds;
	GOTO		13;
	STORE_F	0.250000,	odds;
	GOTO		11;
	STORE_F	POWERUP_DEBUG,	odds;
	GOTO		9;
	NE_F		locked_2932,	FALSE,	locked_916;
	IFNOT		locked_916,	-9;
	EQ_F		locked_2932,	TRUE,	locked_916;
	IF		locked_916,	-9;
	EQ_F		locked_2932,	FL_SWIM,	locked_916;
	IF		locked_916,	-9;
	EQ_F		locked_2932,	MOVETYPE_WALK,	locked_916;
	IF		locked_916,	-9;
	LE		howAmIDoing,	odds,	locked_2932;
	IFNOT		locked_2932,	2;
	STORE_F	TRUE,	panic;
	IFNOT		panic,	10;
	STORE_F	IMP_SWEAPON1,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_panic_time;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	STORE_ENT	this,	self;
	RETURN	offset_0;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	6;
	STORE_F	attacker,	parm0_x;
	STORE_F	return_x,	locked_2932;
	CALL1		ai_valid_target;
	STORE_F	return_x,	locked_916;
	STORE_F	locked_2932,	return_x;
	AND		return_x,	locked_916,	locked_2932;
	IFNOT		locked_2932,	84;
	INDIRECT_E	self,	enemy,	locked_2932;
	NE_E		locked_2932,	attacker,	locked_2932;
	IFNOT		locked_2932,	77;
	INDIRECT_F	self,	data_type,	locked_2932;
	EQ_F		locked_2932,	MOVETYPE_WALK,	locked_2932;
	IFNOT		locked_2932,	3;
	INDIRECT_F	attacker,	data_type,	locked_916;
	EQ_F		locked_916,	FL_SWIM,	locked_916;
	AND		locked_2932,	locked_916,	locked_2932;
	IFNOT		locked_2932,	2;
	STORE_F	DAT_LATC_RL_RATE,	change;
	INDIRECT_F	attacker,	vec_size,	locked_2932;
	INDIRECT_E	self,	enemy,	locked_916;
	INDIRECT_F	locked_916,	vec_size,	locked_916;
	SUB_F		locked_2932,	locked_916,	change;
	STORE_F	attacker,	parm0_x;
	CALL1		util_getMechHpAverage;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	return_x,	locked_2932;
	CALL1		util_getMechHpAverage;
	STORE_F	return_x,	locked_916;
	STORE_F	locked_2932,	return_x;
	SUB_F		return_x,	locked_916,	locked_2932;
	ADD_F		change,	locked_2932,	change;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_V	locked_2932,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	INDIRECT_F	self,	radar_range,	locked_2932;
	DIV_F		return_x,	locked_2932,	dst1;
	INDIRECT_V	attacker,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	INDIRECT_F	self,	radar_range,	locked_2932;
	DIV_F		return_x,	locked_2932,	dst2;
	SUB_F		dst1,	dst2,	locked_2932;
	ADD_F		change,	locked_2932,	change;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	GOTO		20;
	IFNOT		change,	3;
	ADDRESS	self,	enemy,	locked_916;
	STOREP_ENT	attacker,	locked_916;
	GOTO		24;
	GE		change,	DAT_MNT_SHIELD_RATE,	locked_916;
	IFNOT		locked_916,	3;
	ADDRESS	self,	enemy,	locked_916;
	STOREP_ENT	attacker,	locked_916;
	GOTO		19;
	GT		change,	0.500000,	locked_916;
	IFNOT		locked_916,	3;
	ADDRESS	self,	enemy,	locked_916;
	STOREP_ENT	attacker,	locked_916;
	GOTO		14;
	GE		change,	0.250000,	locked_916;
	IFNOT		locked_916,	3;
	ADDRESS	self,	enemy,	locked_916;
	STOREP_ENT	attacker,	locked_916;
	GOTO		9;
	EQ_F		locked_2932,	MOVETYPE_WALK,	locked_916;
	IF		locked_916,	-20;
	EQ_F		locked_2932,	FL_SWIM,	locked_916;
	IF		locked_916,	-18;
	EQ_F		locked_2932,	TRUE,	locked_916;
	IF		locked_916,	-15;
	NE_F		locked_2932,	FALSE,	locked_916;
	IFNOT		locked_916,	-12;
	INDIRECT_E	self,	enemy,	locked_2932;
	EQ_E		locked_2932,	attacker,	locked_2932;
	IFNOT		locked_2932,	8;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LT		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	3;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	GOTO		5;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	attacker,	locked_2932;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	STORE_ENT	this,	self;
	DONE;
}

float(entity wep) ai_attack_blockcheck = asm
{
local vector vang;
local vector viewpont;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local vector temp_5;
	INDIRECT_V	self,	angles_x,	vang;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_TURRET,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	self,	e_tor_c,	temp_1;
	INDIRECT_V	temp_1,	angles_x,	vang;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_0;
	INDIRECT_E	self,	e_cam,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		normalize;
	STORE_V	return,	viewpont;
	STORE_V	vang,	parm0;
	CALL1		makevectors;
	INDIRECT_E	self,	e_cam,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_0;
	MUL_VF	v_forward,	TRUE,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_E	self,	e_cam,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_2;
	INDIRECT_F	wep,	w_range,	temp_1;
	MUL_VF	viewpont,	temp_1,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	EQ_E		trace_ent,	world,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	INDIRECT_F	trace_ent,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	INDIRECT_F	wep,	p_dmgtype,	temp_1;
	BITAND	temp_1,	FL_ONGROUND,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	RETURN	FALSE;
	DONE;
}

void () ArraySet*AI_NODES;
void () ArrayGet*AI_NODES;
void(string nodename) ai_node_pick_rand = asm
{
local float py;
local float px;
local float angl;
local vector org;
local string grpid;
local string name;
local float pick;
local float total;
local float clr;
local entity spot;
local entity anode;
local float temp_1;
local float temp_3;
local float temp_4;
	IFNOT		nodename,	78;
	STORE_F	world,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	nodename,	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	anode;
	IFNOT		anode,	2;
	INDIRECT_S	anode,	group,	temp_1;
	AND		anode,	temp_1,	temp_1;
	IFNOT		temp_1,	62;
	INDIRECT_S	anode,	group,	grpid;
	STORE_F	FALSE,	total;
	STORE_F	FALSE,	clr;
	LE		clr,	FL_NOTARGET,	temp_1;
	IFNOT		temp_1,	6;
	STORE_F	clr,	parm0_x;
	STORE_F	world,	parm1_x;
	CALL2		ArraySet*AI_NODES;
	ADD_F		clr,	TRUE,	clr;
	GOTO		-6;
	STORE_F	group,	parm0_x;
	STORE_F	grpid,	parm1_x;
	CALL2		findchain;
	STORE_ENT	return_x,	anode;
	IFNOT		anode,	3;
	INDIRECT_F	anode,	flags,	temp_1;
	BITAND	temp_1,	FL_NODE,	temp_1;
	AND		anode,	temp_1,	temp_1;
	IFNOT		temp_1,	42;
	IFNOT		anode,	7;
	STORE_F	total,	parm0_x;
	STORE_F	anode,	parm1_x;
	CALL2		ArraySet*AI_NODES;
	ADD_F		total,	TRUE,	total;
	INDIRECT_E	anode,	chain,	anode;
	GOTO		-6;
	CALL0		random;
	MUL_F		return_x,	total,	parm0_x;
	CALL1		rint;
	STORE_F	return_x,	pick;
	STORE_F	pick,	parm0_x;
	CALL1		ArrayGet*AI_NODES;
	STORE_ENT	return_x,	spot;
	IFNOT		spot,	27;
	INDIRECT_F	self,	angles_y,	temp_1;
	MUL_F		temp_1,	DEG2RAD,	angl;
	STORE_F	angl,	parm0_x;
	CALL1		cos;
	STORE_F	return_x,	px;
	STORE_F	angl,	parm0_x;
	CALL1		sin;
	STORE_F	return_x,	py;
	INDIRECT_F	self,	origin_z,	temp_1;
	ADD_F		temp_1,	TRUE,	org_z;
	INDIRECT_F	spot,	origin_x,	temp_1;
	INDIRECT_F	self,	maxs_x,	temp_3;
	MUL_F		px,	temp_3,	temp_3;
	MUL_F		temp_3,	MOVETYPE_WALK,	temp_3;
	SUB_F		temp_1,	temp_3,	org_x;
	INDIRECT_F	spot,	origin_y,	temp_1;
	INDIRECT_F	self,	maxs_y,	temp_3;
	MUL_F		py,	temp_3,	temp_3;
	MUL_F		temp_3,	MOVETYPE_WALK,	temp_3;
	SUB_F		temp_1,	temp_3,	org_y;
	STORE_F	self,	parm0_x;
	STORE_V	org,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	target,	temp_1;
	INDIRECT_S	spot,	targetname,	temp_3;
	STOREP_S	temp_3,	temp_1;
	GOTO		8;
	ADDRESS	self,	spawnflags,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_4;
	BITAND	temp_4,	FL_MONSTER,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	DONE;
}

void(float dst, float grp, float bracket) ai_wep_group_track = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	LE		dst,	bracket,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	INDIRECT_F	self,	currentWeaponGroup,	temp_3;
	BITOR		temp_3,	grp,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		7;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	INDIRECT_F	self,	currentWeaponGroup,	temp_3;
	INDIRECT_F	self,	currentWeaponGroup,	temp_4;
	BITAND	temp_4,	grp,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_wep_calcranges = asm
{
local float damg;
local float l;
local float m;
local float sh;
local entity w;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	w_slot,	w;
	IFNOT		w,	39;
	INDIRECT_F	w,	deadflag,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	34;
	INDIRECT_F	w,	p_damage,	temp_1;
	INDIRECT_F	w,	w_clipsize,	temp_3;
	MUL_F		temp_1,	temp_3,	damg;
	INDIRECT_F	w,	w_range,	temp_1;
	LE		temp_1,	DAT_PRJ_ABT_VELOCITY,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	w_group1,	temp_1;
	INDIRECT_F	self,	w_group1,	temp_3;
	INDIRECT_F	w,	w_group,	temp_4;
	BITOR		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADD_F		sh,	damg,	sh;
	INDIRECT_F	w,	w_range,	temp_1;
	GT		temp_1,	DAT_PRJ_ABT_VELOCITY,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_F	w,	w_range,	temp_1;
	LE		temp_1,	DAT_RPLAS_RANGE,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	w_group2,	temp_1;
	INDIRECT_F	self,	w_group2,	temp_3;
	INDIRECT_F	w,	w_group,	temp_4;
	BITOR		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADD_F		m,	damg,	m;
	INDIRECT_F	w,	w_range,	temp_1;
	GT		temp_1,	DAT_RPLAS_RANGE,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	w_group3,	temp_1;
	INDIRECT_F	self,	w_group3,	temp_3;
	INDIRECT_F	w,	w_group,	temp_4;
	BITOR		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADD_F		l,	damg,	l;
	INDIRECT_E	w,	w_slot,	w;
	GOTO		-38;
	GT		sh,	m,	temp_1;
	IFNOT		temp_1,	2;
	GT		sh,	l,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	ai_minrange,	temp_1;
	STOREP_F	DAT_PRJ_ABT_VELOCITY,	temp_1;
	GT		m,	sh,	temp_1;
	IFNOT		temp_1,	2;
	GT		m,	l,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	ai_minrange,	temp_1;
	STOREP_F	DAT_RPLAS_RANGE,	temp_1;
	GT		l,	sh,	temp_1;
	IFNOT		temp_1,	2;
	GT		l,	m,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	ai_minrange,	temp_1;
	STOREP_F	DAT_PRJ_ION_VELOCITY,	temp_1;
	INDIRECT_F	self,	ai_minrange,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	FL_NOSHOOT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

float(void () action) ai_hunt_dropnode = asm
{
local float locked_916;
local float locked_2932;
local entity e;
local string tname;
local float update;
local vector eorg;
local float t;
local vector torg;
local float it;
local vector temp_0;
local vector temp_2;
local float temp_4;
local float temp_6;
	INDIRECT_F	self,	ai_hunt_total,	locked_2932;
	LT		locked_2932,	MOVETYPE_WALK,	locked_2932;
	IFNOT		locked_2932,	112;
	INDIRECT_F	self,	ai_hunt_total,	locked_2932;
	LT		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	31;
	ADDRESS	self,	ai_hunt_total,	locked_2932;
	INDIRECT_F	self,	ai_hunt_total,	locked_916;
	ADD_F		locked_916,	TRUE,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	INDIRECT_F	self,	m_fspeed,	locked_2932;
	MUL_F		locked_2932,	AI_WALK_SPD,	parm0_x;
	STORE_F	DAT_PAC_DMG,	parm1_x;
	STORE_F	0.100000,	parm2_x;
	CALL3		ai_move_time;
	STORE_F	return_x,	it;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_F	self,	maxs_x,	locked_2932;
	MUL_F		locked_2932,	FL_SWIM,	locked_2932;
	ADD_F		locked_2932,	FL_SWIM,	locked_2932;
	MUL_VF	v_forward,	locked_2932,	temp_2;
	SUB_V		temp_0,	temp_2,	torg;
	INDIRECT_S	self,	targetname,	locked_2932;
	INDIRECT_F	self,	ai_hunt_total,	locked_916;
	STORE_V	torg,	parm0;
	STORE_F	locked_2932,	parm1_x;
	STORE_F	locked_916,	parm2_x;
	STORE_F	it,	parm3_x;
	STORE_F	action,	parm4_x;
	CALL5		ai_node_hunt;
	ADDRESS	self,	ai_hunt_total,	locked_2932;
	INDIRECT_F	self,	ai_hunt_total,	locked_916;
	ADD_F		locked_916,	TRUE,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	INDIRECT_F	self,	m_fspeed,	locked_2932;
	MUL_F		locked_2932,	AI_WALK_SPD,	locked_2932;
	INDIRECT_E	self,	enemy,	locked_916;
	INDIRECT_V	locked_916,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	0.100000,	parm2_x;
	CALL3		ai_move_time;
	STORE_F	return_x,	t;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_V	locked_2932,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_V	locked_2932,	origin_x,	temp_0;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_F	locked_2932,	maxs_z,	locked_2932;
	DIV_F		locked_2932,	SHVBAL_EFFRAM_PERCENTAGE,	locked_2932;
	MUL_VF	v_up,	locked_2932,	temp_2;
	ADD_V		temp_0,	temp_2,	eorg;
	ADDRESS	self,	goalentity,	locked_2932;
	ADDRESS	self,	ai_hunt_node,	locked_916;
	INDIRECT_S	self,	targetname,	temp_4;
	INDIRECT_F	self,	ai_hunt_total,	temp_6;
	STORE_V	eorg,	parm0;
	STORE_F	temp_4,	parm1_x;
	STORE_F	temp_6,	parm2_x;
	STORE_F	t,	parm3_x;
	STORE_F	action,	parm4_x;
	CALL5		ai_node_hunt;
	STOREP_ENT	return_x,	locked_916;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_E	self,	goalentity,	locked_916;
	INDIRECT_V	locked_916,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_viewtime,	locked_2932;
	INDIRECT_F	self,	ai_viewcheck,	locked_916;
	ADD_F		time,	locked_916,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_hunt_total,	locked_2932;
	INDIRECT_F	self,	ai_hunt_total,	locked_916;
	ADD_F		locked_916,	TRUE,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	INDIRECT_F	self,	ai_hunt_total,	update;
	GT		update,	CONTENT_EMPTY,	locked_2932;
	IFNOT		locked_2932,	26;
	INDIRECT_S	self,	targetname,	locked_2932;
	STORE_F	update,	parm0_x;
	CALL1		ftos;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	"_",	parm1_x;
	STORE_F	return_x,	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	tname;
	STORE_F	world,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	tname,	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	e;
	IFNOT		e,	3;
	INDIRECT_E	self,	goalentity,	locked_2932;
	NE_E		e,	locked_2932,	locked_2932;
	AND		e,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	6;
	ADDRESS	e,	pausetime,	locked_2932;
	INDIRECT_F	e,	pausetime,	locked_916;
	MUL_F		t,	FL_SWIM,	temp_4;
	ADD_F		locked_916,	temp_4,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	SUB_F		update,	TRUE,	update;
	GOTO		-26;
	RETURN	TRUE;
	RETURN	FALSE;
	DONE;
}

float (entity) ai_range;
float(entity targ) ai_range = asm
{
local vector temp_0;
local vector temp_2;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	targ,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	RETURN	return_x;
	DONE;
}

float(float movespeed, float distance, float ticrate) ai_move_time = asm
{
local float t;
local float temp_1;
	DIV_F		TRUE,	ticrate,	temp_1;
	MUL_F		movespeed,	temp_1,	t;
	DIV_F		distance,	t,	t;
	RETURN	t;
	DONE;
}

float(float yawspeed, float angmin, float angmax, float tim) ai_randyaw_time = asm
{
local float locked_2932;
local float turn;
local float temp_3;
local float temp_4;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	CALL0		crandom;
	MUL_F		return_x,	angmax,	temp_3;
	ADD_F		angmin,	temp_3,	temp_3;
	INDIRECT_F	self,	angles_y,	temp_4;
	SUB_F		temp_3,	temp_4,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_2932;
	INDIRECT_F	self,	angles_y,	temp_3;
	SUB_F		locked_2932,	temp_3,	parm0_x;
	CALL1		anglemod;
	STORE_F	return_x,	turn;
	DIV_F		turn,	yawspeed,	turn;
	DIV_F		turn,	tim,	turn;
	RETURN	turn;
	DONE;
}

float(entity wep) ai_attack_checkEne = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	en_cur,	temp_1;
	INDIRECT_F	wep,	en_rate,	temp_3;
	GE		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	RETURN	FALSE;
	DONE;
}

float(float bestAccuracy) ai_wait_for_shot = asm
{
local float temp_1;
	INDIRECT_F	self,	accuracy,	temp_1;
	LE		temp_1,	bestAccuracy,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	RETURN	FALSE;
	DONE;
}

float(void () ai_to_make) ai_unit_setup = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_F	self,	nextVecChoice,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	TRUE,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_UNIT,	temp_1;
	IFNOT		temp_1,	2;
	INDIRECT_S	self,	targetname,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	ai_unit_make_trigger,	temp_1;
	ADDRESS	self,	unit_ini,	temp_1;
	STOREP_FNC	ai_to_make,	temp_1;
	ADDRESS	self,	spawnflags,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_4;
	BITAND	temp_4,	FL_UNIT,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	TRUE;
	INDIRECT_F	self,	delay,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	count,	temp_3;
	NOT_F		temp_3,	temp_3;
	IF		temp_3,	3;
	INDIRECT_F	self,	count,	temp_4;
	LT		temp_4,	TRUE,	temp_4;
	OR		temp_3,	temp_4,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	10;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	multi_trigger,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	delay,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_to_make,	temp_1;
	RETURN	TRUE;
	INDIRECT_F	self,	count,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	multi_trigger,	temp_1;
	ADDRESS	self,	unit_ini,	temp_1;
	STOREP_FNC	ai_to_make,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	count1,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_unit_make_multi,	temp_1;
	RETURN	TRUE;
	RETURN	TRUE;
	DONE;
}

void() ai_unit_make_trigger = asm
{
local float temp_1;
local float temp_3;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	multi_trigger,	temp_1;
	ADDRESS	self,	think,	temp_1;
	INDIRECT_FU	self,	unit_ini,	temp_3;
	STOREP_FNC	temp_3,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	delay,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_unit_make_multi = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	count,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	27;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_F	self,	parm0_x;
	STORE_F	newmis,	parm1_x;
	CALL2		copyentity;
	ADDRESS	newmis,	unit_ini,	temp_1;
	INDIRECT_FU	self,	unit_ini,	temp_3;
	STOREP_FNC	temp_3,	temp_1;
	STORE_ENT	self,	stemp;
	STORE_ENT	newmis,	self;
	INDIRECT_FU	self,	unit_ini,	temp_1;
	CALL0		temp_1;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	multi_trigger,	temp_1;
	STORE_ENT	stemp,	self;
	ADDRESS	self,	count,	temp_1;
	INDIRECT_F	self,	count,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	count1,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_unit_make_multi,	temp_1;
	RETURN	offset_0;
	DONE;
}

void(float startState) ai_initialize_system = asm
{
	CALL0		ai_pilot_validate_states;
	STORE_F	startState,	parm0_x;
	CALL1		ai_next_state;
	DONE;
}

void() ai_pilot_validate_states = asm
{
local float temp_1;
	INDIRECT_FU	self,	th_stand,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	INDIRECT_FU	self,	th_walk,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	th_walk,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	INDIRECT_FU	self,	th_fly,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	th_fly,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	INDIRECT_FU	self,	th_run,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	th_run,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	INDIRECT_FU	self,	th_run_strafe,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	th_run_strafe,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	INDIRECT_FU	self,	th_run_charge,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	th_run_charge,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	INDIRECT_FU	self,	th_missile,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	th_missile,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	INDIRECT_FU	self,	th_melee,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	th_melee,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	INDIRECT_FU	self,	th_missile_strafe,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	th_missile_strafe,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	INDIRECT_FU	self,	th_hunt,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	th_hunt,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	INDIRECT_FU	self,	th_pain,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	th_pain,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	DONE;
}

void(float dist) q1_ai_forward = asm
{
local float temp_1;
	INDIRECT_F	self,	angles_y,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	DONE;
}

void(float dist) q1_ai_back = asm
{
local float temp_1;
	INDIRECT_F	self,	angles_y,	temp_1;
	ADD_F		temp_1,	180.000000,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	DONE;
}

void (float) q1_ai_pain;
void(float dist) q1_ai_pain = asm
{
	STORE_F	dist,	parm0_x;
	CALL1		q1_ai_back;
	DONE;
}

void (float) q1_ai_painforward;
void(float dist) q1_ai_painforward = asm
{
local float temp_1;
	INDIRECT_F	self,	ideal_yaw,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	DONE;
}

void(float dist) q1_ai_walk = asm
{
local vector mtemp;
local float temp_1;
	STORE_F	dist,	movedist;
	INDIRECT_S	self,	classname,	temp_1;
	EQ_S		temp_1,	"monster_dragon",	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	dist,	parm0_x;
	CALL1		movetogoal;
	RETURN	offset_0;
	STORE_F	dist,	parm0_x;
	CALL1		movetogoal;
	DONE;
}

void() q1_ai_stand = asm
{
local float temp_1;
	INDIRECT_F	self,	pausetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_FU	self,	th_walk,	temp_1;
	CALL0		temp_1;
	RETURN	offset_0;
	DONE;
}

void() q1_ai_turn = asm
{
	CALL0		ChangeYaw;
	DONE;
}

void () q1_ai_run_missile;
void() q1_ai_run_missile = asm
{
local float temp_1;
	ADDRESS	self,	ideal_yaw,	temp_1;
	STOREP_F	enemy_yaw,	temp_1;
	CALL0		ChangeYaw;
	DONE;
}

void() q1_ai_run_slide = asm
{
local float ofs;
local float temp_1;
local float temp_3;
	ADDRESS	self,	ideal_yaw,	temp_1;
	STOREP_F	enemy_yaw,	temp_1;
	CALL0		ChangeYaw;
	INDIRECT_F	self,	lefty,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	STAT_TRG_ORGZ,	ofs;
	GOTO		2;
	STORE_F	-90.000000,	ofs;
	INDIRECT_F	self,	ideal_yaw,	temp_1;
	ADD_F		temp_1,	ofs,	parm0_x;
	STORE_F	movedist,	parm1_x;
	CALL2		walkmove;
	IFNOT		return_x,	2;
	RETURN	offset_0;
	ADDRESS	self,	lefty,	temp_1;
	INDIRECT_F	self,	lefty,	temp_3;
	SUB_F		TRUE,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	ideal_yaw,	temp_1;
	SUB_F		temp_1,	ofs,	parm0_x;
	STORE_F	movedist,	parm1_x;
	CALL2		walkmove;
	DONE;
}

void(float dist) q1_ai_run = asm
{
local float ang_ceil;
local float ang_floor;
local float ang_rint;
local float direct;
local float axis;
local vector delta;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	STORE_F	dist,	movedist;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	temp_1,	health,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	20;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	world,	temp_1;
	INDIRECT_E	self,	oldenemy,	temp_1;
	INDIRECT_F	temp_1,	health,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	enemy,	temp_1;
	INDIRECT_E	self,	oldenemy,	temp_3;
	STOREP_ENT	temp_3,	temp_1;
	CALL0		ai_hunt_target;
	GOTO		9;
	INDIRECT_E	self,	movetarget,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_FU	self,	th_walk,	temp_1;
	CALL0		temp_1;
	GOTO		3;
	INDIRECT_FU	self,	th_stand,	temp_1;
	CALL0		temp_1;
	RETURN	offset_0;
	IFNOT		enemy_vis,	5;
	ADDRESS	self,	search_time,	temp_1;
	INDIRECT_F	self,	maxpatience,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	IFNOT		coop,	3;
	INDIRECT_F	self,	search_time,	temp_1;
	LT		temp_1,	time,	temp_1;
	AND		coop,	temp_1,	temp_1;
	IFNOT		temp_1,	10;
	CALL0		ai_find_target_visual;
	IFNOT		return_x,	3;
	RETURN	offset_0;
	GOTO		3;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	world,	temp_1;
	CALL0		ai_find_target_visual;
	IFNOT		return_x,	2;
	RETURN	offset_0;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STORE_F	return_x,	enemy_yaw;
	INDIRECT_F	self,	attack_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	3;
	CALL0		q1_ai_run_missile;
	RETURN	offset_0;
	INDIRECT_F	self,	attack_state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	attack_state,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	3;
	CALL0		q1_ai_run_slide;
	RETURN	offset_0;
	STORE_F	dist,	parm0_x;
	CALL1		movetogoal;
	DONE;
}

void(float estate) ai_next_state = asm
{
local float temp_1;
local float temp_3;
	ADDRESS	self,	attack_state,	temp_1;
	STOREP_F	estate,	temp_1;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_mod,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void(float estate) ai_turret_set_state = asm
{
local float temp_1;
	INDIRECT_E	self,	e_tor_c,	temp_1;
	ADDRESS	temp_1,	attack_state,	temp_1;
	STOREP_F	estate,	temp_1;
	DONE;
}

void(float estate) ai_state_control = asm
{
local float temp_1;
	GOTO		34;
	INDIRECT_FU	self,	th_stand,	temp_1;
	CALL0		temp_1;
	GOTO		53;
	INDIRECT_FU	self,	th_walk,	temp_1;
	CALL0		temp_1;
	GOTO		50;
	INDIRECT_FU	self,	th_fly,	temp_1;
	CALL0		temp_1;
	GOTO		47;
	INDIRECT_FU	self,	th_run,	temp_1;
	CALL0		temp_1;
	GOTO		44;
	INDIRECT_FU	self,	th_run_strafe,	temp_1;
	CALL0		temp_1;
	GOTO		41;
	INDIRECT_FU	self,	th_run_charge,	temp_1;
	CALL0		temp_1;
	GOTO		38;
	INDIRECT_FU	self,	th_missile,	temp_1;
	CALL0		temp_1;
	GOTO		35;
	INDIRECT_FU	self,	th_melee,	temp_1;
	CALL0		temp_1;
	GOTO		32;
	INDIRECT_FU	self,	th_missile_strafe,	temp_1;
	CALL0		temp_1;
	GOTO		29;
	INDIRECT_FU	self,	th_hunt,	temp_1;
	CALL0		temp_1;
	GOTO		26;
	INDIRECT_FU	self,	th_pain,	temp_1;
	CALL0		temp_1;
	GOTO		23;
	EQ_F		estate,	TRUE,	temp_1;
	IF		temp_1,	-34;
	EQ_F		estate,	FL_SWIM,	temp_1;
	IF		temp_1,	-33;
	EQ_F		estate,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-32;
	EQ_F		estate,	MOVETYPE_STEP,	temp_1;
	IF		temp_1,	-31;
	EQ_F		estate,	MOVETYPE_FLY,	temp_1;
	IF		temp_1,	-30;
	EQ_F		estate,	MOVETYPE_TOSS,	temp_1;
	IF		temp_1,	-29;
	EQ_F		estate,	MOVETYPE_PUSH,	temp_1;
	IF		temp_1,	-28;
	EQ_F		estate,	FL_CLIENT,	temp_1;
	IF		temp_1,	-27;
	EQ_F		estate,	MOVETYPE_FLYMISSILE,	temp_1;
	IF		temp_1,	-26;
	EQ_F		estate,	MOVETYPE_BOUNCE,	temp_1;
	IF		temp_1,	-25;
	EQ_F		estate,	IMP_SWEAPON1,	temp_1;
	IF		temp_1,	-24;
	DONE;
}

void() ai_turret_control = asm
{
local float locked_916;
local float locked_2932;
local vector am;
local entity this;
local vector temp_0;
local vector temp_2;
local float temp_4;
	STORE_ENT	self,	this;
	INDIRECT_E	self,	e_tor_c,	locked_2932;
	IFNOT		locked_2932,	43;
	INDIRECT_E	self,	e_tor_c,	self;
	INDIRECT_V	self,	c_ofs_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_F	this,	parm1_x;
	STORE_V	temp_0,	parm2;
	CALL3		util_setOffsetOrigin;
	INDIRECT_F	self,	attack_state,	locked_2932;
	GOTO		22;
	ADDRESS	self,	ideal_yaw,	locked_916;
	INDIRECT_F	this,	angles_y,	temp_4;
	STOREP_F	temp_4,	locked_916;
	GOTO		26;
	ADDRESS	self,	ideal_yaw,	locked_916;
	INDIRECT_E	this,	enemy,	temp_4;
	INDIRECT_V	temp_4,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STOREP_F	return_x,	locked_916;
	GOTO		18;
	ADDRESS	self,	ideal_yaw,	locked_916;
	INDIRECT_E	this,	goalentity,	temp_4;
	INDIRECT_V	temp_4,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STOREP_F	return_x,	locked_916;
	GOTO		10;
	GOTO		9;
	NE_F		locked_2932,	FALSE,	locked_916;
	IFNOT		locked_916,	-22;
	EQ_F		locked_2932,	TRUE,	locked_916;
	IF		locked_916,	-20;
	EQ_F		locked_2932,	MOVETYPE_WALK,	locked_916;
	IF		locked_916,	-14;
	EQ_F		locked_2932,	MOVETYPE_STEP,	locked_916;
	IF		locked_916,	-8;
	CALL0		ChangeYaw;
	ADDRESS	self,	v_angle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	STORE_ENT	this,	self;
	DONE;
}

void() ai_generic_stand = asm
{
local float temp_1;
	INDIRECT_F	self,	stat_rdr_mode,	parm0_x;
	CALL1		ai_check_scan;
	IFNOT		return_x,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	9;
	INDIRECT_E	self,	movetarget,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_generic_walk = asm
{
local float temp_1;
	INDIRECT_F	self,	stat_rdr_mode,	parm0_x;
	CALL1		ai_check_scan;
	IFNOT		return_x,	2;
	RETURN	offset_0;
	STORE_F	AI_WALK_SPD,	parm0_x;
	CALL1		ai_walkgoal;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	19;
	INDIRECT_E	self,	movetarget,	temp_1;
	IFNOT		temp_1,	9;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	leg_walk1,	parm0_x;
	CALL1		ai_leg_frame;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	RETURN	offset_0;
	DONE;
}

void() ai_generic_fly = asm
{
local float bspd;
local float sspd;
local float fspd;
local vector flydir;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_E	self,	enemy,	temp_1;
	IFNOT		temp_1,	2;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	fspd;
	INDIRECT_F	self,	m_sspeed,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	sspd;
	INDIRECT_F	self,	m_bspeed,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	temp_1;
	INDIRECT_F	self,	attack_finished,	temp_3;
	MUL_F		temp_1,	temp_3,	bspd;
	CALL0		ChangeYaw;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_up,	bspd,	temp_2;
	ADD_V		temp_0,	temp_2,	flydir;
	MUL_VF	v_right,	sspd,	temp_0;
	ADD_V		flydir,	temp_0,	flydir;
	MUL_VF	v_forward,	fspd,	temp_0;
	ADD_V		flydir,	temp_0,	flydir;
	STORE_F	self,	parm0_x;
	STORE_V	flydir,	parm1;
	CALL2		setorigin;
	DONE;
}

void() ai_generic_run = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	42;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_vis;
	STORE_F	return_x,	enemy_vis;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	enemy_range;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	STORE_F	return_x,	enemy_infront;
	IFNOT		enemy_vis,	29;
	LT		enemy_range,	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	IFNOT		temp_1,	14;
	IFNOT		enemy_infront,	11;
	INDIRECT_F	self,	ai_rank,	temp_1;
	LE		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	CALL0		ai_face_targ;
	STORE_F	MOVETYPE_TOSS,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	CALL0		ai_face_targ;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_minrange,	temp_1;
	LE		enemy_range,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	IFNOT		enemy_infront,	1;
	INDIRECT_F	self,	ai_minrange,	temp_1;
	GT		enemy_range,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	IFNOT		enemy_infront,	1;
	INDIRECT_F	self,	ai_minrange,	temp_1;
	MUL_F		temp_1,	FL_SWIM,	temp_1;
	GT		enemy_range,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	IFNOT		enemy_infront,	1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_generic_run_strafe = asm
{
local float moved;
local float temp_1;
	INDIRECT_F	self,	m_sspeed,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	parm0_x;
	CALL1		ai_walk_left;
	STORE_F	return_x,	moved;
	NE_F		moved,	FALSE,	temp_1;
	IF		temp_1,	5;
	INDIRECT_F	self,	m_sspeed,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	parm0_x;
	CALL1		ai_walk_right;
	STORE_F	return_x,	moved;
	NE_F		moved,	FALSE,	temp_1;
	IF		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_generic_run_charge = asm
{
local float moved;
local float temp_1;
	CALL0		ai_move_turn;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	DAT_MNT_SHIELD_RATE,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	21;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	temp_1;
	STORE_F	TE_PLASMABURN,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		ai_yaw_move;
	STORE_F	return_x,	moved;
	NE_F		moved,	FALSE,	temp_1;
	IF		temp_1,	7;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	temp_1;
	STORE_F	-75.000000,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		ai_yaw_move;
	STORE_F	return_x,	moved;
	NE_F		moved,	FALSE,	temp_1;
	IF		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_generic_missile = asm
{
local float temp_1;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.970000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	6;
	CALL0		ai_attack;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_generic_melee = asm
{
	CALL0		ai_face_targ;
	DONE;
}

void() ai_generic_missile_strafe = asm
{
local float ang;
local float temp_1;
local float temp_3;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	angles_y,	temp_1;
	INDIRECT_F	self,	lefty,	temp_3;
	MUL_F		temp_3,	STAT_TRG_ORGZ,	temp_3;
	ADD_F		temp_1,	temp_3,	parm0_x;
	CALL1		anglemod;
	STORE_F	return_x,	ang;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	MUL_F		temp_1,	AI_WALK_SPD,	temp_1;
	STORE_F	ang,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		ai_move;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.970000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	6;
	CALL0		ai_attack;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_generic_hunt = asm
{
	DONE;
}

void() ai_generic_pain = asm
{
	DONE;
}

float(float scan_mode) ai_check_scan = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	ai_viewtime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	8;
	ADDRESS	self,	ai_viewtime,	temp_1;
	INDIRECT_F	self,	ai_viewcheck,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	IFNOT		scan_mode,	1;
	CALL0		ai_find_target_visual;
	RETURN	return_x;
	RETURN	FALSE;
	DONE;
}

void(float speed) ai_walkgoal = asm
{
local float temp_1;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	MUL_F		temp_1,	speed,	parm0_x;
	CALL1		movetogoal;
	DONE;
}

void() ai_move_turn = asm
{
	CALL0		ChangeYaw;
	DONE;
}

void() ai_face_targ = asm
{
local float locked_2932;
local vector temp_0;
local vector temp_2;
local float temp_3;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STOREP_F	return_x,	locked_2932;
	CALL0		ChangeYaw;
	DONE;
}

float(float dist) ai_walk_back = asm
{
local float temp_1;
	INDIRECT_F	self,	angles_y,	temp_1;
	ADD_F		temp_1,	180.000000,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		ai_move;
	RETURN	return_x;
	DONE;
}

float(float dist) ai_walk_left = asm
{
local float temp_1;
	INDIRECT_F	self,	angles_y,	temp_1;
	ADD_F		temp_1,	STAT_TRG_ORGZ,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		ai_move;
	RETURN	return_x;
	DONE;
}

float(float dist) ai_walk_right = asm
{
local float temp_1;
	INDIRECT_F	self,	angles_y,	temp_1;
	SUB_F		temp_1,	STAT_TRG_ORGZ,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		ai_move;
	RETURN	return_x;
	DONE;
}

float(float angmod, float dist) ai_move = asm
{
	STORE_F	angmod,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	RETURN	return_x;
	DONE;
}

float(float dist) ai_yaw_back = asm
{
local float temp_1;
	INDIRECT_F	self,	ideal_yaw,	temp_1;
	ADD_F		temp_1,	180.000000,	parm0_x;
	CALL1		anglemod;
	STORE_F	return_x,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	RETURN	return_x;
	DONE;
}

float(float dist) ai_yaw_left = asm
{
local float temp_1;
	INDIRECT_F	self,	ideal_yaw,	temp_1;
	ADD_F		temp_1,	STAT_TRG_ORGZ,	parm0_x;
	CALL1		anglemod;
	STORE_F	return_x,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	RETURN	return_x;
	DONE;
}

float(float dist) ai_yaw_right = asm
{
local float temp_1;
	INDIRECT_F	self,	ideal_yaw,	temp_1;
	SUB_F		temp_1,	STAT_TRG_ORGZ,	parm0_x;
	CALL1		anglemod;
	STORE_F	return_x,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	RETURN	return_x;
	DONE;
}

float(float angmod, float dist) ai_yaw_move = asm
{
local float temp_1;
	INDIRECT_F	self,	ideal_yaw,	temp_1;
	ADD_F		temp_1,	angmod,	parm0_x;
	CALL1		anglemod;
	STORE_F	return_x,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	RETURN	return_x;
	DONE;
}

void(float alt_low, float alt_max) ai_fly_update = asm
{
local float bspd;
local float sspd;
local float fspd;
local float fdir;
local float dist;
local vector flydir;
local vector delta;
local vector temp_0;
local float temp_1;
local vector temp_2;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_up,	-10000.000000,	temp_2;
	ADD_V		temp_0,	temp_2,	delta;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_V	delta,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		trace_endpos,	temp_0,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	dist;
	LE		dist,	alt_low,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	fdir;
	EQ_F		fdir,	FALSE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_up,	DAT_BLD_H_SM_RADAR_RADAR_RANGE,	temp_2;
	ADD_V		temp_0,	temp_2,	delta;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_V	delta,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		trace_endpos,	temp_0,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	dist;
	LE		dist,	alt_max,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	CONTENT_EMPTY,	fdir;
	NE_F		fdir,	FALSE,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	fspd;
	INDIRECT_F	self,	m_sspeed,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	sspd;
	INDIRECT_F	self,	m_bspeed,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	temp_1;
	MUL_F		temp_1,	fdir,	bspd;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_up,	bspd,	temp_2;
	ADD_V		temp_0,	temp_2,	flydir;
	MUL_VF	v_right,	sspd,	temp_0;
	ADD_V		flydir,	temp_0,	flydir;
	MUL_VF	v_forward,	fspd,	temp_0;
	ADD_V		flydir,	temp_0,	flydir;
	STORE_F	self,	parm0_x;
	STORE_V	flydir,	parm1;
	CALL2		setorigin;
	DONE;
}

void(float move) ai_update_accuracy = asm
{
local float rate;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	spreadDefault_z,	rate;
	IFNOT		move,	17;
	INDIRECT_F	self,	stat_rdr_mode,	temp_1;
	IFNOT		temp_1,	3;
	MUL_F		rate,	0.250000,	temp_1;
	SUB_F		rate,	temp_1,	rate;
	ADDRESS	self,	accuracy,	temp_1;
	INDIRECT_F	self,	accuracy,	temp_3;
	ADD_F		temp_3,	rate,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	accuracy,	temp_1;
	INDIRECT_F	self,	spreadDefault_y,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	accuracy,	temp_1;
	INDIRECT_F	self,	spreadDefault_y,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		16;
	INDIRECT_F	self,	stat_rdr_mode,	temp_1;
	IFNOT		temp_1,	3;
	MUL_F		rate,	AI_DMG_SKILL_VET,	temp_1;
	SUB_F		rate,	temp_1,	rate;
	ADDRESS	self,	accuracy,	temp_1;
	INDIRECT_F	self,	accuracy,	temp_3;
	SUB_F		temp_3,	rate,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	accuracy,	temp_1;
	INDIRECT_F	self,	spreadDefault_x,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	accuracy,	temp_1;
	INDIRECT_F	self,	spreadDefault_x,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

float(entity t, float ang) ai_check_face = asm
{
local float dot;
local vector vec;
local vector vang;
local vector temp_0;
local float temp_1;
local vector temp_2;
	INDIRECT_V	self,	angles_x,	vang;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_TURRET,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	self,	e_tor_c,	temp_1;
	INDIRECT_V	temp_1,	angles_x,	vang;
	STORE_V	vang,	parm0;
	CALL1		makevectors;
	INDIRECT_V	t,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		normalize;
	STORE_V	return,	vec;
	MUL_V		vec,	v_forward,	dot;
	GE		dot,	ang,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	RETURN	FALSE;
	DONE;
}

float(entity t) ai_check_range = asm
{
local vector temp_0;
local vector temp_2;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	t,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	RETURN	return_x;
	DONE;
}

float(entity targ) ai_check_vis = asm
{
local vector spot2;
local vector spot1;
local vector temp_0;
local float temp_1;
local float temp_3;
	INDIRECT_V	self,	origin_x,	spot1;
	INDIRECT_V	targ,	origin_x,	spot2;
	STORE_V	spot1,	parm0;
	STORE_V	spot2,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	IFNOT		trace_inopen,	1;
	AND		trace_inopen,	trace_inwater,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	EQ_F		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	NE_E		trace_ent,	targ,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_F	trace_ent,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	MOVETYPE_WALK;
	RETURN	FALSE;
	DONE;
}

float() ai_attack = asm
{
local float temp_1;
	INDIRECT_E	self,	enemy,	temp_1;
	IFNOT		temp_1,	11;
	INDIRECT_F	self,	currentWeaponGroup,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	8;
	CALL0		random;
	INDIRECT_F	self,	ai_attack_chance,	temp_1;
	LE		return_x,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	button0,	temp_1;
	STOREP_F	TRUE,	temp_1;
	RETURN	TRUE;
	RETURN	FALSE;
	DONE;
}

void() ai_hunt_target = asm
{
local float locked_2932;
local vector temp_0;
local vector temp_2;
local float temp_3;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	goalentity,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	DONE;
}

void(float ifaction, float datatype) ai_sfx_spotted = asm
{
	STORE_F	"Bot says",	parm0_x;
	STORE_F	"I'VE SEEN YOU!",	parm1_x;
	CALL2		cons_logAString;
	DONE;
}

void() ai_found_target = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	i_faction,	temp_1;
	INDIRECT_F	self,	data_type,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_sfx_spotted;
	CALL0		ai_hunt_target;
	DONE;
}

void() ai_walk_setup = asm
{
local float locked_916;
local float locked_2932;
local vector temp_0;
local vector temp_2;
local float temp_4;
	INDIRECT_S	self,	target,	locked_2932;
	IFNOT		locked_2932,	42;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	FL_MONSTER,	locked_2932;
	IFNOT		locked_2932,	3;
	INDIRECT_S	self,	target,	parm0_x;
	CALL1		ai_node_pick_rand;
	ADDRESS	self,	goalentity,	locked_2932;
	ADDRESS	self,	movetarget,	locked_916;
	INDIRECT_S	self,	target,	temp_4;
	STORE_F	world,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	temp_4,	parm2_x;
	CALL3		find;
	STOREP_ENT	return_x,	locked_916;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_E	self,	goalentity,	locked_2932;
	INDIRECT_S	locked_2932,	targetname,	parm0_x;
	STORE_F	"
",	parm1_x;
	CALL2		strcat;
	STORE_F	return_x,	parm0_x;
	CALL1		dprint;
	INDIRECT_E	self,	movetarget,	locked_2932;
	IF		locked_2932,	9;
	STORE_F	"Monster can't find target at ",	parm0_x;
	CALL1		dprint;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		vtos;
	STORE_F	return_x,	parm0_x;
	CALL1		dprint;
	STORE_F	"
",	parm0_x;
	CALL1		dprint;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_E	self,	goalentity,	locked_916;
	INDIRECT_V	locked_916,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STOREP_F	return_x,	locked_2932;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		6;
	ADDRESS	self,	pausetime,	locked_2932;
	STOREP_F	100000000.000000,	locked_2932;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void(void () macro) ai_leg_frame = asm
{
local entity this;
local float temp_1;
	INDIRECT_E	self,	e_legs,	temp_1;
	IFNOT		temp_1,	5;
	STORE_ENT	self,	this;
	INDIRECT_E	this,	e_legs,	self;
	CALL0		macro;
	STORE_ENT	this,	self;
	DONE;
}

void () ai_stand;
void() ai_stand = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	patience,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	self,	enemy,	temp_3;
	NOT_ENT	temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	13;
	ADDRESS	self,	patience,	temp_1;
	ADD_F		time,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	"Bot Here",	parm0_x;
	STORE_F	"Having a look around",	parm1_x;
	CALL2		cons_logAString;
	CALL0		ai_find_target_visual;
	IFNOT		return_x,	5;
	STORE_F	"Bot Here",	parm0_x;
	STORE_F	"found target!",	parm1_x;
	CALL2		cons_logAString;
	RETURN	offset_0;
	INDIRECT_F	self,	pausetime,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_FU	self,	th_walk,	temp_1;
	CALL0		temp_1;
	DONE;
}

void () ai_charge_side;
void() ai_charge_side = asm
{
local float locked_2932;
local float t;
local float heading;
local vector dtemp;
local vector temp_0;
local vector temp_2;
local float temp_3;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STOREP_F	return_x,	locked_2932;
	CALL0		ChangeYaw;
	INDIRECT_F	self,	lefty,	locked_2932;
	MUL_F		locked_2932,	TE_PARTICLERAIN,	t;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_V	locked_2932,	origin_x,	temp_0;
	MUL_FV	t,	v_right,	temp_2;
	SUB_V		temp_0,	temp_2,	dtemp;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		dtemp,	temp_0,	parm0;
	CALL1		vectoyaw;
	STORE_F	return_x,	heading;
	INDIRECT_F	self,	m_fspeed,	locked_2932;
	MUL_F		locked_2932,	AI_RUN_SPD,	locked_2932;
	STORE_F	heading,	parm0_x;
	STORE_F	locked_2932,	parm1_x;
	CALL2		walkmove;
	DONE;
}

void (float, float) ai_move_forward;
void(float angl, float dist) ai_move_forward = asm
{
	STORE_F	angl,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	DONE;
}

void (float, float) ai_move_backward;
void(float angl, float dist) ai_move_backward = asm
{
local float temp_1;
	ADD_F		angl,	180.000000,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	DONE;
}

void (float, float) ai_move_left;
void(float angl, float dist) ai_move_left = asm
{
local float temp_1;
	ADD_F		angl,	STAT_TRG_ORGZ,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	DONE;
}

void (float, float) ai_move_right;
void(float angl, float dist) ai_move_right = asm
{
local float temp_1;
	SUB_F		angl,	STAT_TRG_ORGZ,	parm0_x;
	STORE_F	dist,	parm1_x;
	CALL2		walkmove;
	DONE;
}

void () ai_turret_stand;
void () ai_turret_walk;
void () ai_turret_run;
void () ai_turret_missile;
void () ai_turret_run_strafe;
void () ai_turret_die;
void () ai_turret_die_burn;
void () ai_turret_th;
void () temp_chunk_burn;
void() ai_turret_stand = asm
{
local float locked_2932;
local entity this;
local float temp_3;
	INDIRECT_F	self,	stat_rdr_mode,	parm0_x;
	CALL1		ai_check_scan;
	IFNOT		return_x,	4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_turret_set_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	17;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_turret_set_state;
	STORE_ENT	self,	this;
	INDIRECT_E	self,	e_tor_c,	self;
	ADDRESS	this,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	yaw_speed,	parm0_x;
	STORE_F	DAT_PRJ_FLAK_PROXYRAD,	parm1_x;
	STORE_F	120.000000,	parm2_x;
	STORE_F	0.100000,	parm3_x;
	CALL4		ai_randyaw_time;
	ADD_F		time,	return_x,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	STORE_ENT	this,	self;
	RETURN	offset_0;
	DONE;
}

void() ai_turret_walk = asm
{
local float temp_1;
	INDIRECT_F	self,	stat_rdr_mode,	parm0_x;
	CALL1		ai_check_scan;
	IFNOT		return_x,	4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_turret_set_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_turret_run = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	31;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_turret_set_state;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_vis;
	STORE_F	return_x,	enemy_vis;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	enemy_range;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	STORE_F	return_x,	enemy_infront;
	IFNOT		enemy_vis,	13;
	INDIRECT_F	self,	ai_minrange,	temp_1;
	LE		enemy_range,	temp_1,	temp_1;
	IFNOT		temp_1,	9;
	IFNOT		enemy_infront,	5;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		4;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_turret_run_strafe = asm
{
local float temp_1;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	11;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_turret_set_state;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.980000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		6;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_turret_set_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_turret_missile = asm
{
local float temp_1;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	7;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.970000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	2;
	CALL0		ai_attack;
	GOTO		4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_turret_set_state;
	RETURN	offset_0;
	DONE;
}

void() temp_chunk_burn = asm
{
local vector sm;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_F	self,	delay,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	GOTO		21;
	INDIRECT_V	world,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	world,	v_angle_x,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	sm;
	INDIRECT_V	self,	origin_x,	temp_0;
	ADD_V		sm,	'0.000000 0.000000 15.000000',	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	MOVETYPE_WALK,	parm2_x;
	CALL3		te_smoke_test;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	temp_chunk_burn,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_turret_die = asm
{
local entity w_chain;
local string cmdl;
local string nmdl;
local vector vfx_org;
local vector new_org;
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	'0.250000 0.250000 0.250000',	temp_0;
	INDIRECT_E	self,	w_slot,	w_chain;
	IFNOT		w_chain,	5;
	STORE_F	w_chain,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	w_chain,	w_slot,	w_chain;
	GOTO		-4;
	INDIRECT_E	self,	e_cam,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_tor_c,	parm0_x;
	CALL1		mech_player_compdie;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_turret_die_burn,	temp_1;
	ADDRESS	self,	ai_action_time,	temp_1;
	ADD_F		time,	360.000000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_turret_die_burn = asm
{
local vector sm;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_V	world,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	world,	v_angle_x,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	sm;
	INDIRECT_V	self,	origin_x,	temp_0;
	ADD_V		sm,	'0.000000 0.000000 10.000000',	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	TRUE,	parm2_x;
	CALL3		te_smoke_test;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_turret_die_burn,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_turret_th = asm
{
local float locked_2932;
local entity wep;
local vector temp_0;
local vector temp_2;
local float temp_3;
	CALL0		ctrl_updateCenterTorso;
	INDIRECT_E	self,	w_slot,	wep;
	IFNOT		wep,	5;
	STORE_F	wep,	parm0_x;
	CALL1		ctrl_wpn_think;
	INDIRECT_E	wep,	w_slot,	wep;
	GOTO		-4;
	INDIRECT_F	self,	deadflag,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	43;
	INDIRECT_E	self,	enemy,	locked_2932;
	IFNOT		locked_2932,	32;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	27;
	ADDRESS	self,	stat_trg_dist,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group1,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group2,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_RPLAS_RANGE,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group3,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ION_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	GOTO		3;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	world,	locked_2932;
	CALL0		ai_ranged_attack;
	ADDRESS	self,	button0,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_F	self,	attack_state,	parm0_x;
	CALL1		ai_state_control;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_TURRET,	locked_2932;
	IFNOT		locked_2932,	2;
	CALL0		ai_turret_control;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	ai_turret_th,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	DONE;
}

void () ai_turret;
void() ai_turret = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	CALL0		ai_unit_ini_var;
	INDIRECT_F	self,	nextVecChoice,	parm0_x;
	CALL1		data_iniTurret;
	INDIRECT_F	self,	ai_rank,	parm0_x;
	CALL1		ai_pilot_ini_stats;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	ACCURACY_LOWTECH_x,	temp_0;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	ai_turret_stand,	temp_1;
	ADDRESS	self,	th_walk,	temp_1;
	STOREP_FNC	ai_turret_walk,	temp_1;
	ADDRESS	self,	th_run,	temp_1;
	STOREP_FNC	ai_turret_run,	temp_1;
	ADDRESS	self,	th_run_strafe,	temp_1;
	STOREP_FNC	ai_turret_run_strafe,	temp_1;
	ADDRESS	self,	th_missile,	temp_1;
	STOREP_FNC	ai_turret_missile,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	ai_turret_die,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_initialize_system;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_turret_th,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	MUL_F		return_x,	0.500000,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () ai_mech_sk_stand;
void () ai_mech_sk_run;
void () ai_mech_sk_run_strafe;
void () ai_mech_sk_run_charge;
void () ai_mech_sk_melee;
void () ai_mech_sk_missile;
void () ai_mech_sk_missile_strafe;
void () ai_mech_sk_hunt;
void () ai_mech_sk_pain;
void () ai_mech_sk_die;
void () ai_mech_sk_die1;
void () ai_mech_sk_die2;
void () ai_mech_sk_turn;
void () ai_mech_sk_turn_back;
void() ai_mech_sk_stand = asm
{
local float temp_1;
local float temp_3;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	12;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		2;
	CALL0		ai_generic_stand;
	DONE;
}

void() ai_mech_sk_run = asm
{
local float locked_2932;
local float tyaw;
local vector temp_0;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	180;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_V	locked_2932,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STORE_F	return_x,	tyaw;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_turret_set_state;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_vis;
	STORE_F	return_x,	enemy_vis;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	enemy_range;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	STORE_F	return_x,	enemy_infront;
	IFNOT		enemy_vis,	158;
	LT		enemy_range,	DAT_SFGA_DMG,	locked_2932;
	IFNOT		locked_2932,	70;
	IFNOT		enemy_infront,	54;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LT		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	26;
	STORE_F	MOVETYPE_TOSS,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	leg_walk1,	parm0_x;
	CALL1		ai_leg_frame;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_STEP,	temp_3;
	CALL0		random;
	MUL_F		return_x,	MOVETYPE_STEP,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	lefty,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	CALL0		random;
	LT		return_x,	DAT_LAS_RL_RATE,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	lefty,	locked_2932;
	STOREP_F	CONTENT_EMPTY,	locked_2932;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_F	self,	lefty,	temp_3;
	MUL_F		temp_3,	60.000000,	temp_3;
	ADD_F		tyaw,	temp_3,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	leg_walk1,	parm0_x;
	CALL1		ai_leg_frame;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_SWIM,	temp_3;
	CALL0		random;
	MUL_F		return_x,	MOVETYPE_STEP,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	lefty,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	CALL0		random;
	LT		return_x,	DAT_LAS_RL_RATE,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	lefty,	locked_2932;
	STOREP_F	CONTENT_EMPTY,	locked_2932;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_F	self,	lefty,	temp_3;
	MUL_F		temp_3,	STAT_TRG_ORGZ,	temp_3;
	ADD_F		tyaw,	temp_3,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LT		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	8;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	EQ_F		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	3;
	CALL0		ai_mech_sk_turn_back;
	RETURN	offset_0;
	CALL0		ai_mech_sk_turn;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_minrange,	locked_2932;
	LE		enemy_range,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	50;
	IFNOT		enemy_infront,	19;
	STORE_F	FL_CLIENT,	parm0_x;
	CALL1		ai_next_state;
	CALL0		random;
	MUL_F		return_x,	360.000000,	locked_2932;
	ADD_F		tyaw,	locked_2932,	parm0_x;
	CALL1		anglemod;
	STORE_F	return_x,	tyaw;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	STOREP_F	tyaw,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_WALK,	temp_3;
	CALL0		random;
	INDIRECT_F	self,	ai_rank,	temp_4;
	MUL_F		return_x,	temp_4,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LT		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	26;
	STORE_F	MOVETYPE_TOSS,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	leg_walk1,	parm0_x;
	CALL1		ai_leg_frame;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_STEP,	temp_3;
	CALL0		random;
	MUL_F		return_x,	MOVETYPE_STEP,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	lefty,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	CALL0		random;
	LT		return_x,	DAT_LAS_RL_RATE,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	lefty,	locked_2932;
	STOREP_F	CONTENT_EMPTY,	locked_2932;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_F	self,	lefty,	temp_3;
	MUL_F		temp_3,	60.000000,	temp_3;
	ADD_F		tyaw,	temp_3,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	RETURN	offset_0;
	CALL0		ai_mech_sk_turn_back;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_minrange,	locked_2932;
	MUL_F		locked_2932,	FL_SWIM,	locked_2932;
	LE		enemy_range,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	25;
	IFNOT		enemy_infront,	11;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LT		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	8;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_FLY,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LT		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	6;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	leg_walk1,	parm0_x;
	CALL1		ai_leg_frame;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	RETURN	offset_0;
	INDIRECT_F	self,	m_fspeed,	locked_2932;
	MUL_F		locked_2932,	AI_RUN_SPD,	parm0_x;
	CALL1		movetogoal;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_turret_set_state;
	RETURN	offset_0;
	GOTO		8;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_turret_set_state;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sk_turn = asm
{
local float temp_1;
local float temp_3;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	9;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	angles_y,	temp_1;
	INDIRECT_F	self,	m_fspeed,	temp_3;
	MUL_F		temp_3,	AI_RUN_SPD,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	GOTO		5;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sk_turn_back = asm
{
local float temp_1;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	6;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	parm0_x;
	CALL1		ai_walk_back;
	GOTO		5;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sk_run_strafe = asm
{
local float speed;
local float temp_1;
local float temp_3;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	19;
	INDIRECT_F	self,	angles_y,	temp_1;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	IMP_SHOWOBJ,	parm2_x;
	CALL3		util_checkAngNotIdeal;
	IFNOT		return_x,	3;
	CALL0		ai_move_turn;
	GOTO		9;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	DIV_F		temp_1,	MOVETYPE_WALK,	speed;
	INDIRECT_F	self,	m_sspeed,	temp_1;
	ADD_F		speed,	temp_1,	speed;
	MUL_F		speed,	AI_RUN_SPD,	speed;
	INDIRECT_F	self,	angles_y,	parm0_x;
	STORE_F	speed,	parm1_x;
	CALL2		ai_move;
	GOTO		12;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_turret_set_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sk_run_charge = asm
{
local float speed;
local float temp_1;
local float temp_3;
local float temp_4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	31;
	INDIRECT_F	self,	angles_y,	temp_1;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	IMP_SHOWOBJ,	parm2_x;
	CALL3		util_checkAngNotIdeal;
	IFNOT		return_x,	3;
	CALL0		ai_move_turn;
	GOTO		9;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	DIV_F		temp_1,	MOVETYPE_WALK,	speed;
	INDIRECT_F	self,	m_sspeed,	temp_1;
	ADD_F		speed,	temp_1,	speed;
	MUL_F		speed,	AI_RUN_SPD,	speed;
	INDIRECT_F	self,	angles_y,	parm0_x;
	STORE_F	speed,	parm1_x;
	CALL2		ai_move;
	CALL0		ai_attack;
	IFNOT		return_x,	11;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_SWIM,	temp_3;
	CALL0		random;
	MUL_F		return_x,	FL_SWIM,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	GOTO		18;
	INDIRECT_F	self,	ai_rank,	temp_1;
	LT		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	8;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_turret_set_state;
	STORE_F	leg_walk1,	parm0_x;
	CALL1		ai_leg_frame;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_turret_set_state;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sk_melee = asm
{
local float speed;
local float temp_1;
local float temp_3;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	37;
	INDIRECT_F	self,	angles_y,	temp_1;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	STAT_TARG_EID,	parm2_x;
	CALL3		util_checkAngNotIdeal;
	IFNOT		return_x,	3;
	CALL0		ai_move_turn;
	GOTO		9;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	DIV_F		temp_1,	MOVETYPE_WALK,	speed;
	INDIRECT_F	self,	m_sspeed,	temp_1;
	ADD_F		speed,	temp_1,	speed;
	MUL_F		speed,	AI_WALK_SPD,	speed;
	INDIRECT_F	self,	angles_y,	parm0_x;
	STORE_F	speed,	parm1_x;
	CALL2		ai_move;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.970000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	15;
	INDIRECT_F	self,	ai_rank,	temp_1;
	LT		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	9;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	skill,	temp_3;
	ADD_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		8;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_turret_set_state;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sk_missile = asm
{
local float temp_1;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	13;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.970000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	8;
	CALL0		ai_attack;
	IFNOT		return_x,	6;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	leg_walk1,	parm0_x;
	CALL1		ai_leg_frame;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sk_missile_strafe = asm
{
local float temp_1;
local float temp_3;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	15;
	GT		skill,	FL_SWIM,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	self,	ai_rank,	temp_3;
	LT		temp_3,	FL_SWIM,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	angles_y,	temp_1;
	INDIRECT_F	self,	m_sspeed,	temp_3;
	MUL_F		temp_3,	AI_WALK_SPD,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	GOTO		18;
	INDIRECT_F	self,	ai_rank,	temp_1;
	LT		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	8;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_turret_set_state;
	STORE_F	leg_walk1,	parm0_x;
	CALL1		ai_leg_frame;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_turret_set_state;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sk_hunt = asm
{
local float temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sk_pain = asm
{
	DONE;
}

void() ai_mech_sk_die = asm
{
local entity w_chain;
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	'0.050000 0.050000 0.050000',	temp_0;
	ADDRESS	self,	attack_state,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	CALL0		droptofloor;
	INDIRECT_E	self,	w_slot,	w_chain;
	IFNOT		w_chain,	5;
	STORE_F	w_chain,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	w_chain,	w_slot,	w_chain;
	GOTO		-4;
	INDIRECT_E	self,	e_tor_l,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_tor_r,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_arm_l,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_arm_r,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_cam,	parm0_x;
	CALL1		mech_player_compdie;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_mech_sk_die1,	temp_1;
	ADDRESS	self,	ai_action_time,	temp_1;
	ADD_F		time,	DAT_PRJ_ABT_CLST_VELOCITY,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	health,	temp_1;
	INDIRECT_F	self,	max_health,	temp_3;
	DIV_F		temp_3,	SHVBAL_EFFRAM_PERCENTAGE,	temp_3;
	MUL_F		temp_3,	CONTENT_EMPTY,	temp_3;
	LE		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_mech_sk_die2,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_mech_sk_die1 = asm
{
local vector sm;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_V	world,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	world,	v_angle_x,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	sm;
	INDIRECT_V	self,	origin_x,	temp_0;
	ADD_V		sm,	'0.000000 0.000000 5.000000',	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	MOVETYPE_WALK,	parm2_x;
	CALL3		te_smoke_test;
	INDIRECT_E	self,	e_tor_l,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_0;
	ADD_V		sm,	'0.000000 0.000000 5.000000',	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	TRUE,	parm2_x;
	CALL3		te_smoke_test;
	INDIRECT_E	self,	e_tor_r,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_0;
	ADD_V		sm,	'0.000000 0.000000 5.000000',	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	TRUE,	parm2_x;
	CALL3		te_smoke_test;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_mech_sk_die1,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_mech_sk_die2,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_mech_sk_die2 = asm
{
local float temp_1;
local float temp_3;
	CALL0		mech_cleanupMech;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	DONE;
}

void () ai_mech_sk_th;
void() ai_mech_sk_th = asm
{
local float locked_2932;
local entity wep;
local vector temp_0;
local vector temp_2;
local float temp_3;
local float temp_4;
	CALL0		ctrl_updateCenterTorso;
	INDIRECT_E	self,	w_slot,	wep;
	IFNOT		wep,	5;
	STORE_F	wep,	parm0_x;
	CALL1		ctrl_wpn_think;
	INDIRECT_E	wep,	w_slot,	wep;
	GOTO		-4;
	INDIRECT_F	self,	deadflag,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	50;
	INDIRECT_E	self,	enemy,	locked_2932;
	IFNOT		locked_2932,	32;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	27;
	ADDRESS	self,	stat_trg_dist,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group1,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group2,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_RPLAS_RANGE,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group3,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ION_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	GOTO		3;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	world,	locked_2932;
	CALL0		ai_ranged_attack;
	ADDRESS	self,	button0,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_F	self,	attack_state,	parm0_x;
	CALL1		ai_state_control;
	ADDRESS	self,	v_angle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_TURRET,	locked_2932;
	IFNOT		locked_2932,	2;
	CALL0		ai_turret_control;
	INDIRECT_E	self,	e_legs,	locked_2932;
	ADDRESS	locked_2932,	angles_y,	locked_2932;
	INDIRECT_F	self,	angles_y,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_SKIPTHINK,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	12;
	ADDRESS	self,	flags,	locked_2932;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	FL_SKIPTHINK,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	ai_mech_sk_th,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	DONE;
}

void () ai_mech_skirmish;
void() ai_mech_skirmish = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	CALL0		ai_unit_ini_var;
	INDIRECT_F	self,	nextVecChoice,	parm0_x;
	CALL1		data_iniMech;
	INDIRECT_F	self,	ai_rank,	parm0_x;
	CALL1		ai_pilot_ini_stats;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_S	self,	target,	parm0_x;
	CALL1		ai_node_pick_rand;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	ai_mech_sk_stand,	temp_1;
	ADDRESS	self,	th_walk,	temp_1;
	STOREP_FNC	ai_generic_walk,	temp_1;
	ADDRESS	self,	th_run,	temp_1;
	STOREP_FNC	ai_mech_sk_run,	temp_1;
	ADDRESS	self,	th_run_strafe,	temp_1;
	STOREP_FNC	ai_mech_sk_run_strafe,	temp_1;
	ADDRESS	self,	th_run_charge,	temp_1;
	STOREP_FNC	ai_mech_sk_run_charge,	temp_1;
	ADDRESS	self,	th_missile,	temp_1;
	STOREP_FNC	ai_mech_sk_missile,	temp_1;
	ADDRESS	self,	th_melee,	temp_1;
	STOREP_FNC	ai_mech_sk_melee,	temp_1;
	ADDRESS	self,	th_missile_strafe,	temp_1;
	STOREP_FNC	ai_mech_sk_missile_strafe,	temp_1;
	ADDRESS	self,	th_hunt,	temp_1;
	STOREP_FNC	ai_mech_sk_hunt,	temp_1;
	ADDRESS	self,	th_pain,	temp_1;
	STOREP_FNC	ai_mech_sk_pain,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	ai_mech_sk_die,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_initialize_system;
	CALL0		droptofloor;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_TURRET,	temp_1;
	IFNOT		temp_1,	8;
	INDIRECT_E	self,	e_tor_c,	temp_1;
	INDIRECT_E	self,	e_tor_c,	temp_3;
	INDIRECT_V	temp_3,	c_ofs_x,	temp_0;
	STORE_F	temp_1,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_V	temp_0,	parm2;
	CALL3		util_setOffsetOrigin;
	CALL0		ai_walk_setup;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_mech_sk_th,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_INWATER,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	ADD_F		MOVETYPE_PUSH,	return_x,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		6;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	MUL_F		return_x,	0.900000,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

float () ai_mech_sniper_setDuration;
float() ai_mech_sniper_setDuration = asm
{
local float vel;
local float duration;
local float temp_1;
	SUB_F		MOVETYPE_STEP,	skill,	temp_1;
	ADD_F		duration,	temp_1,	duration;
	INDIRECT_F	self,	vec_size,	temp_1;
	SUB_F		temp_1,	TRUE,	temp_1;
	ADD_F		duration,	temp_1,	duration;
	DIV_F		duration,	MOVETYPE_BOUNCE,	duration;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	MUL_F		temp_1,	AI_WALK_SPD,	vel;
	MUL_F		vel,	20.000000,	temp_1;
	DIV_F		temp_1,	DAT_OTL_CTOR_HP,	vel;
	ADD_F		duration,	vel,	duration;
	CALL0		random;
	MUL_F		duration,	return_x,	duration;
	RETURN	duration;
	DONE;
}

void () ai_mech_sniper_stand;
void () ai_mech_sniper_walk;
void () ai_mech_sniper_run;
void () ai_mech_sniper_run_strafe;
void () ai_mech_sniper_run_charge;
void () ai_mech_sniper_melee;
void () ai_mech_sniper_missile;
void () ai_mech_sniper_missile_strafe;
void () ai_mech_sniper_hunt;
void () ai_mech_sniper_pain;
void () ai_mech_sniper_die;
void () ai_mech_sniper_die1;
void () ai_mech_sniper_die2;
void () ai_mech_sniper_turn;
void () ai_mech_sniper_turn_back;
void() ai_mech_sniper_stand = asm
{
local float temp_1;
local float temp_3;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	12;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		2;
	CALL0		ai_generic_stand;
	DONE;
}

void() ai_mech_sniper_walk = asm
{
local float temp_1;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	1;
	DONE;
}

void() ai_mech_sniper_run = asm
{
local float locked_916;
local float locked_2932;
local float angl;
local float temp_4;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	123;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_turret_set_state;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_vis;
	STORE_F	return_x,	enemy_vis;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	enemy_range;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_F	self,	ai_fov,	locked_916;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	CALL2		ai_check_face;
	STORE_F	return_x,	enemy_infront;
	IFNOT		enemy_vis,	102;
	LE		enemy_range,	DAT_SFGA_DMG,	locked_2932;
	IFNOT		locked_2932,	18;
	IFNOT		enemy_infront,	17;
	STORE_F	FL_CLIENT,	parm0_x;
	CALL1		ai_next_state;
	CALL0		random;
	MUL_F		return_x,	STAT_PLR_ANG_X,	locked_2932;
	ADD_F		STAT_PLR_ANG_X,	locked_2932,	angl;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_mech_sniper_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	SUB_F		locked_916,	angl,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	RETURN	offset_0;
	LE		enemy_range,	DAT_PRJ_MLGD_VELOCITY,	locked_2932;
	IFNOT		locked_2932,	37;
	IFNOT		enemy_infront,	17;
	STORE_F	FL_CLIENT,	parm0_x;
	CALL1		ai_next_state;
	CALL0		random;
	MUL_F		return_x,	STAT_PLR_ANG_X,	locked_2932;
	ADD_F		STAT_PLR_ANG_X,	locked_2932,	angl;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_mech_sniper_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	SUB_F		locked_916,	angl,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	locked_916;
	SUB_F		FALSE,	locked_916,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	INDIRECT_F	self,	lefty,	temp_4;
	MUL_F		STAT_WEP_REL,	temp_4,	temp_4;
	SUB_F		locked_916,	temp_4,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_mech_sniper_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_minrange,	locked_2932;
	LE		enemy_range,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	29;
	IFNOT		enemy_infront,	9;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_mech_sniper_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	locked_916;
	SUB_F		FALSE,	locked_916,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	INDIRECT_F	self,	lefty,	temp_4;
	MUL_F		STAT_WEP_REL,	temp_4,	temp_4;
	SUB_F		locked_916,	temp_4,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_mech_sniper_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_TOSS,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_mech_sniper_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	GOTO		6;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	world,	locked_2932;
	RETURN	offset_0;
	GOTO		4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sniper_run_strafe = asm
{
local float locked_916;
local float locked_2932;
local float temp_4;
local float temp_6;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_F	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	m_sspeed,	locked_916;
	MUL_F		locked_916,	AI_RUN_SPD,	locked_916;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	CALL2		ai_move;
	NE_F		return_x,	FALSE,	locked_2932;
	IF		locked_2932,	13;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	locked_916;
	SUB_F		FALSE,	locked_916,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	INDIRECT_F	self,	ai_dir,	temp_4;
	INDIRECT_F	self,	lefty,	temp_6;
	MUL_F		temp_4,	temp_6,	temp_4;
	SUB_F		locked_916,	temp_4,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	27;
	GT		skill,	TRUE,	locked_2932;
	IF		locked_2932,	3;
	INDIRECT_F	self,	ai_rank,	locked_916;
	LT		locked_916,	FL_SWIM,	locked_916;
	OR		locked_2932,	locked_916,	locked_2932;
	IFNOT		locked_2932,	18;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	locked_916;
	SUB_F		FALSE,	locked_916,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ai_dir,	locked_916;
	INDIRECT_F	self,	lefty,	temp_4;
	MUL_F		locked_916,	temp_4,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_mech_sniper_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sniper_run_charge = asm
{
local float locked_916;
local float locked_2932;
local float angl;
local float temp_4;
local float temp_6;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_F	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	m_sspeed,	locked_916;
	MUL_F		locked_916,	AI_RUN_SPD,	locked_916;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	CALL2		ai_move;
	NE_F		return_x,	FALSE,	locked_2932;
	IF		locked_2932,	16;
	CALL0		random;
	MUL_F		return_x,	STAT_TRG_ORGZ,	locked_2932;
	ADD_F		DAT_PRJ_FLAK_PROXYRAD,	locked_2932,	angl;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	locked_916;
	SUB_F		FALSE,	locked_916,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	INDIRECT_F	self,	ai_dir,	temp_4;
	INDIRECT_F	self,	lefty,	temp_6;
	MUL_F		temp_4,	temp_6,	temp_4;
	SUB_F		locked_916,	temp_4,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	18;
	GT		skill,	TRUE,	locked_2932;
	IF		locked_2932,	3;
	INDIRECT_F	self,	ai_rank,	locked_916;
	LT		locked_916,	FL_SWIM,	locked_916;
	OR		locked_2932,	locked_916,	locked_2932;
	IFNOT		locked_2932,	9;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_mech_sniper_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sniper_melee = asm
{
local float locked_916;
local float locked_2932;
local float temp_4;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	34;
	CALL0		ai_move_turn;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.960000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	2;
	CALL0		ai_attack;
	INDIRECT_F	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	m_bspeed,	locked_916;
	MUL_F		locked_916,	AI_WALK_SPD,	locked_916;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	CALL2		ai_move;
	NE_F		return_x,	FALSE,	locked_2932;
	IF		locked_2932,	20;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	locked_916;
	SUB_F		FALSE,	locked_916,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	INDIRECT_F	self,	lefty,	temp_4;
	MUL_F		STAT_WEP_REL,	temp_4,	temp_4;
	SUB_F		locked_916,	temp_4,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_mech_sniper_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sniper_missile = asm
{
local float locked_916;
local float locked_2932;
local float angl;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	36;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	enemy_range;
	LE		enemy_range,	DAT_MTK_LTOR_HP,	locked_2932;
	IFNOT		locked_2932,	17;
	STORE_F	FL_CLIENT,	parm0_x;
	CALL1		ai_next_state;
	CALL0		random;
	MUL_F		return_x,	STAT_PLR_ANG_X,	locked_2932;
	ADD_F		STAT_PLR_ANG_X,	locked_2932,	angl;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_mech_sniper_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	SUB_F		locked_916,	angl,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	RETURN	offset_0;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.960000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	10;
	INDIRECT_F	self,	spreadDefault_x,	locked_2932;
	ADD_F		locked_2932,	DAT_LATC_RL_RATE,	parm0_x;
	CALL1		ai_wait_for_shot;
	IFNOT		return_x,	6;
	CALL0		ai_attack;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sniper_missile_strafe = asm
{
local float locked_916;
local float locked_2932;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	23;
	INDIRECT_F	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	m_fspeed,	locked_916;
	MUL_F		locked_916,	AI_WALK_SPD,	locked_916;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	CALL2		ai_move;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.960000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	12;
	CALL0		ai_attack;
	NE_F		return_x,	FALSE,	locked_2932;
	IF		locked_2932,	9;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_mech_sniper_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	GOTO		4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_mech_sniper_hunt = asm
{
	DONE;
}

void() ai_mech_sniper_pain = asm
{
local float temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void () ai_mech_sniper_th;
void() ai_mech_sniper_th = asm
{
local float locked_2932;
local entity wep;
local vector temp_0;
local vector temp_2;
local float temp_3;
local float temp_4;
	CALL0		ctrl_updateCenterTorso;
	INDIRECT_E	self,	w_slot,	wep;
	IFNOT		wep,	5;
	STORE_F	wep,	parm0_x;
	CALL1		ctrl_wpn_think;
	INDIRECT_E	wep,	w_slot,	wep;
	GOTO		-4;
	INDIRECT_F	self,	deadflag,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	50;
	INDIRECT_E	self,	enemy,	locked_2932;
	IFNOT		locked_2932,	32;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	27;
	ADDRESS	self,	stat_trg_dist,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group1,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group2,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_RPLAS_RANGE,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group3,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ION_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	GOTO		3;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	world,	locked_2932;
	CALL0		ai_ranged_attack;
	ADDRESS	self,	button0,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_F	self,	attack_state,	parm0_x;
	CALL1		ai_state_control;
	ADDRESS	self,	v_angle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_TURRET,	locked_2932;
	IFNOT		locked_2932,	2;
	CALL0		ai_turret_control;
	INDIRECT_E	self,	e_legs,	locked_2932;
	ADDRESS	locked_2932,	angles_y,	locked_2932;
	INDIRECT_F	self,	angles_y,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_SKIPTHINK,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	12;
	ADDRESS	self,	flags,	locked_2932;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	FL_SKIPTHINK,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	ai_mech_sniper_th,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	DONE;
}

void () ai_mech_sniper;
void() ai_mech_sniper = asm
{
local float temp_1;
local float temp_3;
	CALL0		ai_unit_ini_var;
	INDIRECT_F	self,	nextVecChoice,	parm0_x;
	CALL1		data_iniMech;
	INDIRECT_F	self,	ai_rank,	parm0_x;
	CALL1		ai_pilot_ini_stats;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	ai_mech_sniper_stand,	temp_1;
	ADDRESS	self,	th_walk,	temp_1;
	STOREP_FNC	ai_generic_walk,	temp_1;
	ADDRESS	self,	th_run,	temp_1;
	STOREP_FNC	ai_mech_sniper_run,	temp_1;
	ADDRESS	self,	th_run_strafe,	temp_1;
	STOREP_FNC	ai_mech_sniper_run_strafe,	temp_1;
	ADDRESS	self,	th_run_charge,	temp_1;
	STOREP_FNC	ai_mech_sniper_run_charge,	temp_1;
	ADDRESS	self,	th_missile,	temp_1;
	STOREP_FNC	ai_mech_sniper_missile,	temp_1;
	ADDRESS	self,	th_melee,	temp_1;
	STOREP_FNC	ai_mech_sniper_melee,	temp_1;
	ADDRESS	self,	th_missile_strafe,	temp_1;
	STOREP_FNC	ai_mech_sniper_missile_strafe,	temp_1;
	ADDRESS	self,	th_hunt,	temp_1;
	STOREP_FNC	ai_mech_sniper_hunt,	temp_1;
	ADDRESS	self,	th_pain,	temp_1;
	STOREP_FNC	ai_mech_sniper_pain,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	ai_mech_sniper_die,	temp_1;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_initialize_system;
	CALL0		ai_walk_setup;
	CALL0		droptofloor;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_mech_sniper_th,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_INWATER,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	ADD_F		MOVETYPE_PUSH,	return_x,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		6;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	MUL_F		return_x,	0.900000,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () ai_dest_stand;
void () ai_dest_run;
void () ai_dest_run_strafe;
void () ai_dest_melee;
void () ai_dest_missile;
void () ai_vec_dest_die;
void () ai_vec_dest_die1;
void () ai_vec_dest_die1a;
void () ai_vec_dest_die2;
void() ai_dest_stand = asm
{
local float temp_1;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_F	self,	stat_rdr_mode,	parm0_x;
	CALL1		ai_check_scan;
	IFNOT		return_x,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	9;
	INDIRECT_E	self,	movetarget,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_dest_run = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	29;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_vis;
	STORE_F	return_x,	enemy_vis;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	enemy_range;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	STORE_F	return_x,	enemy_infront;
	IFNOT		enemy_vis,	16;
	LE		enemy_range,	DAT_PRJ_QRFL_VELOCITY,	temp_1;
	IFNOT		temp_1,	5;
	IFNOT		enemy_infront,	4;
	STORE_F	FL_CLIENT,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_minrange,	temp_1;
	LE		enemy_range,	temp_1,	temp_1;
	IFNOT		temp_1,	5;
	IFNOT		enemy_infront,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	AI_RUN_SPD,	parm0_x;
	CALL1		ai_walkgoal;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_dest_run_strafe = asm
{
	DONE;
}

void() ai_dest_melee = asm
{
local float temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	15;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.990000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	2;
	CALL0		ai_attack;
	INDIRECT_F	self,	m_bspeed,	temp_1;
	MUL_F		temp_1,	AI_WALK_SPD,	parm0_x;
	CALL1		ai_yaw_back;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_dest_missile = asm
{
local float temp_1;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	7;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.990000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	2;
	CALL0		ai_attack;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void () ai_dest_th;
void() ai_dest_th = asm
{
local float locked_2932;
local entity wep;
local vector temp_0;
local vector temp_2;
local float temp_3;
local float temp_4;
	CALL0		ctrl_updateCenterTorso;
	INDIRECT_E	self,	w_slot,	wep;
	IFNOT		wep,	5;
	STORE_F	wep,	parm0_x;
	CALL1		ctrl_wpn_think;
	INDIRECT_E	wep,	w_slot,	wep;
	GOTO		-4;
	INDIRECT_F	self,	deadflag,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	37;
	INDIRECT_E	self,	enemy,	locked_2932;
	IFNOT		locked_2932,	32;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	27;
	ADDRESS	self,	stat_trg_dist,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group1,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group2,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_RPLAS_RANGE,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group3,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ION_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	GOTO		3;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	world,	locked_2932;
	CALL0		ai_ranged_attack;
	ADDRESS	self,	button0,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_F	self,	attack_state,	parm0_x;
	CALL1		ai_state_control;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_SKIPTHINK,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	12;
	ADDRESS	self,	flags,	locked_2932;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	FL_SKIPTHINK,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	ai_dest_th,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	DONE;
}

void() ai_vec_dest_die = asm
{
local entity w_chain;
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	'0.250000 0.250000 0.250000',	temp_0;
	ADDRESS	self,	attack_state,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	INDIRECT_E	self,	w_slot,	w_chain;
	IFNOT		w_chain,	5;
	STORE_F	w_chain,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	w_chain,	w_slot,	w_chain;
	GOTO		-4;
	INDIRECT_E	self,	e_cam,	parm0_x;
	CALL1		mech_player_compdie;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_vec_dest_die1,	temp_1;
	ADDRESS	self,	ai_action_time,	temp_1;
	ADD_F		time,	120.000000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	health,	temp_1;
	INDIRECT_F	self,	max_health,	temp_3;
	DIV_F		temp_3,	SHVBAL_EFFRAM_PERCENTAGE,	temp_3;
	MUL_F		temp_3,	CONTENT_EMPTY,	temp_3;
	LE		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_vec_dest_die2,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_vec_dest_die1 = asm
{
local vector sm;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_V	world,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	world,	v_angle_x,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	sm;
	INDIRECT_V	self,	origin_x,	temp_0;
	ADD_V		sm,	'0.000000 0.000000 10.000000',	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	FL_SWIM,	parm2_x;
	CALL3		te_smoke_test;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_vec_dest_die1,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_vec_dest_die1a,	temp_1;
	ADDRESS	self,	ai_action_time,	temp_1;
	ADD_F		time,	120.000000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_vec_dest_die1a = asm
{
local float temp_1;
local float temp_3;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_vec_dest_die1a,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_vec_dest_die2,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_vec_dest_die2 = asm
{
local float temp_1;
local float temp_3;
	CALL0		mech_cleanupMech;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	DONE;
}

void () ai_vec_dest;
void() ai_vec_dest = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	CALL0		ai_unit_ini_var;
	INDIRECT_F	self,	nextVecChoice,	parm0_x;
	CALL1		data_iniVehc;
	INDIRECT_F	self,	ai_rank,	parm0_x;
	CALL1		ai_pilot_ini_stats;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_S	self,	target,	parm0_x;
	CALL1		ai_node_pick_rand;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	ai_dest_stand,	temp_1;
	ADDRESS	self,	th_walk,	temp_1;
	STOREP_FNC	ai_generic_walk,	temp_1;
	ADDRESS	self,	th_run,	temp_1;
	STOREP_FNC	ai_dest_run,	temp_1;
	ADDRESS	self,	th_run_strafe,	temp_1;
	STOREP_FNC	ai_dest_run_strafe,	temp_1;
	ADDRESS	self,	th_missile,	temp_1;
	STOREP_FNC	ai_dest_missile,	temp_1;
	ADDRESS	self,	th_melee,	temp_1;
	STOREP_FNC	ai_dest_melee,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	ai_vec_dest_die,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_initialize_system;
	CALL0		ai_walk_setup;
	CALL0		droptofloor;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	'0.000000 0.750000 1.000000',	temp_0;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_dest_th,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_INWATER,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	MOVETYPE_PUSH,	temp_3;
	CALL0		random;
	ADD_F		temp_3,	return_x,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		5;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	ADD_F		time,	return_x,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () ai_tank_sk_stand;
void () ai_tank_sk_run;
void () ai_tank_sk_melee;
void () ai_tank_sk_missile;
void () ai_tank_sk_missile_strafe;
void () ai_tank_sk_hunt;
void () ai_tank_sk_pain;
void () ai_tank_sk_die;
void () ai_tank_sk_die1;
void () ai_tank_sk_die2;
void() ai_tank_sk_stand = asm
{
local float temp_1;
local float temp_3;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	19;
	INDIRECT_F	self,	angles_y,	temp_1;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	IMP_SHOWOBJ,	parm2_x;
	CALL3		util_checkAngNotIdeal;
	IFNOT		return_x,	2;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		2;
	CALL0		ai_generic_stand;
	DONE;
}

void() ai_tank_sk_run = asm
{
local float locked_2932;
local float temp_3;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	115;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_turret_set_state;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_vis;
	STORE_F	return_x,	enemy_vis;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	enemy_range;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	STORE_F	return_x,	enemy_infront;
	IFNOT		enemy_vis,	93;
	LT		enemy_range,	DAT_SFGA_DMG,	locked_2932;
	IFNOT		locked_2932,	47;
	IFNOT		enemy_infront,	37;
	INDIRECT_F	self,	angles_y,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	IMP_SWEAPON3,	parm2_x;
	CALL3		util_checkAngNotIdeal;
	IFNOT		return_x,	3;
	CALL0		ai_face_targ;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	GT		locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	13;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_TOSS,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	angles_y,	temp_3;
	SUB_F		temp_3,	180.000000,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	STORE_F	FL_CLIENT,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_STEP,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	angles_y,	temp_3;
	ADD_F		temp_3,	DAT_PRJ_FLAK_PROXYRAD,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	STORE_F	FL_CLIENT,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LT		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	4;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_minrange,	locked_2932;
	LE		enemy_range,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	23;
	IFNOT		enemy_infront,	19;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LE		locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	13;
	INDIRECT_F	self,	angles_y,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_FLAK_PROXYRAD,	parm2_x;
	CALL3		util_checkAngNotIdeal;
	IFNOT		return_x,	3;
	CALL0		ai_face_targ;
	RETURN	offset_0;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_minrange,	locked_2932;
	MUL_F		locked_2932,	SHVBAL_EFFRAM_PERCENTAGE,	locked_2932;
	LE		enemy_range,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	12;
	IFNOT		enemy_infront,	8;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_FLY,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	m_fspeed,	locked_2932;
	MUL_F		locked_2932,	AI_RUN_SPD,	parm0_x;
	CALL1		movetogoal;
	GOTO		7;
	ADDRESS	self,	goalentity,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	STORE_F	MOVETYPE_BOUNCE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		6;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_turret_set_state;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_tank_sk_melee = asm
{
local float avg;
local float moved;
local float temp_1;
local float temp_3;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	DAT_LAS_RL_RATE,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	16;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	INDIRECT_F	self,	m_sspeed,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	avg;
	INDIRECT_F	self,	ai_dir,	temp_1;
	MUL_F		avg,	AI_RUN_SPD,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	STORE_F	return_x,	moved;
	NE_F		moved,	FALSE,	temp_1;
	IF		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_tank_sk_missile = asm
{
local float temp_1;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.920000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	6;
	CALL0		ai_attack;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_tank_sk_missile_strafe = asm
{
local float moved;
local float temp_1;
local float temp_3;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_turret_set_state;
	INDIRECT_F	self,	m_sspeed,	temp_1;
	MUL_F		temp_1,	AI_WALK_SPD,	parm0_x;
	CALL1		ai_walk_right;
	STORE_F	return_x,	moved;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.920000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	2;
	CALL0		ai_attack;
	NE_F		moved,	FALSE,	temp_1;
	IF		temp_1,	14;
	ADDRESS	self,	lefty,	temp_1;
	INDIRECT_F	self,	lefty,	temp_3;
	MUL_F		temp_3,	CONTENT_EMPTY,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	m_sspeed,	temp_1;
	MUL_F		temp_1,	AI_WALK_SPD,	parm0_x;
	CALL1		ai_walk_left;
	STORE_F	return_x,	moved;
	NE_F		moved,	FALSE,	temp_1;
	IF		temp_1,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_tank_sk_hunt = asm
{
local float temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	STORE_F	AI_RUN_SPD,	parm0_x;
	CALL1		ai_walkgoal;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_tank_sk_pain = asm
{
	DONE;
}

void() ai_tank_sk_die = asm
{
local entity w_chain;
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	'0.250000 0.250000 0.250000',	temp_0;
	ADDRESS	self,	attack_state,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	INDIRECT_E	self,	w_slot,	w_chain;
	IFNOT		w_chain,	5;
	STORE_F	w_chain,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	w_chain,	w_slot,	w_chain;
	GOTO		-4;
	INDIRECT_E	self,	e_cam,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_tor_l,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_tor_r,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_tor_c,	parm0_x;
	CALL1		mech_player_compdie;
	STORE_F	self,	parm0_x;
	STORE_V	'-8.000000 -8.000000 -3.000000',	parm1;
	STORE_V	'8.000000 8.000000 3.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_tank_sk_die1,	temp_1;
	ADDRESS	self,	ai_action_time,	temp_1;
	ADD_F		time,	120.000000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	health,	temp_1;
	INDIRECT_F	self,	max_health,	temp_3;
	DIV_F		temp_3,	SHVBAL_EFFNON_PERCENTAGE,	temp_3;
	MUL_F		temp_3,	CONTENT_EMPTY,	temp_3;
	LE		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_tank_sk_die2,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () ai_tank_sk_die1a;
void() ai_tank_sk_die1a = asm
{
local float temp_1;
local float temp_3;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_tank_sk_die1a,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_tank_sk_die2,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_tank_sk_die1 = asm
{
local vector sm;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_V	world,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	world,	v_angle_x,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	world,	m_fspeed,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	sm;
	INDIRECT_V	self,	origin_x,	temp_0;
	ADD_V		sm,	'0.000000 0.000000 10.000000',	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	FL_SWIM,	parm2_x;
	CALL3		te_smoke_test;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_tank_sk_die1,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_tank_sk_die1,	temp_1;
	ADDRESS	self,	ai_action_time,	temp_1;
	ADD_F		time,	120.000000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_tank_sk_die2 = asm
{
local float temp_1;
local float temp_3;
	CALL0		mech_cleanupMech;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	DONE;
}

void () ai_tank_sk_th;
void() ai_tank_sk_th = asm
{
local float locked_2932;
local entity wep;
local vector temp_0;
local vector temp_2;
local float temp_3;
local float temp_4;
	CALL0		ctrl_updateCenterTorso;
	INDIRECT_E	self,	w_slot,	wep;
	IFNOT		wep,	5;
	STORE_F	wep,	parm0_x;
	CALL1		ctrl_wpn_think;
	INDIRECT_E	wep,	w_slot,	wep;
	GOTO		-4;
	INDIRECT_F	self,	deadflag,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	43;
	INDIRECT_E	self,	enemy,	locked_2932;
	IFNOT		locked_2932,	32;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	27;
	ADDRESS	self,	stat_trg_dist,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group1,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group2,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_RPLAS_RANGE,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group3,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ION_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	GOTO		3;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	world,	locked_2932;
	CALL0		ai_ranged_attack;
	ADDRESS	self,	button0,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_F	self,	attack_state,	parm0_x;
	CALL1		ai_state_control;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_TURRET,	locked_2932;
	IFNOT		locked_2932,	2;
	CALL0		ai_turret_control;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_SKIPTHINK,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	12;
	ADDRESS	self,	flags,	locked_2932;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	FL_SKIPTHINK,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	ai_tank_sk_th,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	DONE;
}

void () ai_tank_skirmish;
void() ai_tank_skirmish = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	CALL0		ai_unit_ini_var;
	INDIRECT_F	self,	nextVecChoice,	parm0_x;
	CALL1		data_iniVehc;
	INDIRECT_F	self,	ai_rank,	parm0_x;
	CALL1		ai_pilot_ini_stats;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_S	self,	target,	parm0_x;
	CALL1		ai_node_pick_rand;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	ai_tank_sk_stand,	temp_1;
	ADDRESS	self,	th_walk,	temp_1;
	STOREP_FNC	ai_generic_walk,	temp_1;
	ADDRESS	self,	th_run,	temp_1;
	STOREP_FNC	ai_tank_sk_run,	temp_1;
	ADDRESS	self,	th_run_strafe,	temp_1;
	STOREP_FNC	ai_generic_run_strafe,	temp_1;
	ADDRESS	self,	th_missile,	temp_1;
	STOREP_FNC	ai_generic_missile,	temp_1;
	ADDRESS	self,	th_melee,	temp_1;
	STOREP_FNC	ai_tank_sk_melee,	temp_1;
	ADDRESS	self,	th_missile_strafe,	temp_1;
	STOREP_FNC	ai_tank_sk_missile_strafe,	temp_1;
	ADDRESS	self,	th_hunt,	temp_1;
	STOREP_FNC	ai_tank_sk_hunt,	temp_1;
	ADDRESS	self,	th_pain,	temp_1;
	STOREP_FNC	ai_tank_sk_pain,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	ai_tank_sk_die,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_initialize_system;
	CALL0		ai_walk_setup;
	CALL0		droptofloor;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	'1.000000 0.000000 0.000000',	temp_0;
	INDIRECT_E	self,	e_tor_c,	temp_1;
	ADDRESS	temp_1,	colormod_x,	temp_0_x;
	STOREP_V	'1.000000 0.000000 0.000000',	temp_0;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_tank_sk_th,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_INWATER,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	ADD_F		MOVETYPE_PUSH,	return_x,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		6;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	MUL_F		return_x,	0.900000,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () ai_noncom_stand;
void () ai_noncom_walk;
void () ai_noncom_run;
void () ai_noncom_run_strafe;
void () ai_noncom_run_charge;
void () ai_noncom_melee;
void () ai_noncom_missile;
void () ai_noncom_missile_strafe;
void () ai_noncom_hunt;
void () ai_noncom_pain;
void () ai_noncom_die;
void () ai_noncom_th;
void() ai_noncom_stand = asm
{
local float temp_1;
	INDIRECT_F	self,	stat_rdr_mode,	parm0_x;
	CALL1		ai_check_scan;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	9;
	INDIRECT_E	self,	movetarget,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_noncom_walk = asm
{
local float temp_1;
	STORE_F	AI_WALK_SPD,	parm0_x;
	CALL1		ai_walkgoal;
	INDIRECT_F	self,	stat_rdr_mode,	parm0_x;
	CALL1		ai_check_scan;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	9;
	INDIRECT_E	self,	movetarget,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_noncom_run = asm
{
local entity friend;
local float friend_range;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	82;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_vis;
	STORE_F	return_x,	enemy_vis;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	enemy_range;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	STORE_F	return_x,	enemy_infront;
	STORE_F	DAT_PRJ_ION_VELOCITY,	parm0_x;
	CALL1		ai_find_friend;
	STORE_ENT	return_x,	friend;
	STORE_F	CONTENT_EMPTY,	friend_range;
	IFNOT		friend,	4;
	STORE_F	friend,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	friend_range;
	IFNOT		enemy_vis,	52;
	LT		enemy_range,	DAT_SFGA_DMG,	temp_1;
	IFNOT		temp_1,	20;
	LT		friend_range,	DAT_RPLAS_RANGE,	temp_1;
	IFNOT		temp_1,	10;
	ADDRESS	self,	goalentity,	temp_1;
	STOREP_ENT	friend,	temp_1;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_STEP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	IFNOT		enemy_infront,	8;
	STORE_F	MOVETYPE_TOSS,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_TOSS,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	LE		enemy_range,	DAT_RPLAS_RANGE,	temp_1;
	IFNOT		temp_1,	10;
	LE		friend_range,	DAT_RPLAS_RANGE,	temp_1;
	IFNOT		temp_1,	8;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_CLIENT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	GT		enemy_range,	DAT_PRJ_ION_VELOCITY,	temp_1;
	IFNOT		temp_1,	10;
	LE		friend_range,	DAT_RPLAS_RANGE,	temp_1;
	IFNOT		temp_1,	8;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_CLIENT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	STORE_F	FL_CLIENT,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_CLIENT,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	GOTO		10;
	STORE_F	FL_CLIENT,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	INDIRECT_F	self,	ai_rank,	temp_4;
	MUL_F		temp_4,	FL_SWIM,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_noncom_run_strafe = asm
{
local float rng;
local vector temp_0;
local float temp_1;
local vector temp_2;
	INDIRECT_E	self,	goalentity,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	rng;
	GT		rng,	STAT_PLR_ANG_X,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	AI_RUN_SPD,	parm0_x;
	CALL1		ai_walkgoal;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	10;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	RETURN	offset_0;
	DONE;
}

void() ai_noncom_run_charge = asm
{
	DONE;
}

void() ai_noncom_melee = asm
{
local float temp_1;
	STORE_F	AI_RUN_SPD,	parm0_x;
	CALL1		ai_walkgoal;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	9;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	3;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_noncom_missile = asm
{
local entity friend;
local float temp_1;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	15;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	parm0_x;
	CALL1		ai_find_friend;
	STORE_ENT	return_x,	friend;
	INDIRECT_F	friend,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_E	self,	enemy,	temp_1;
	STORE_F	friend,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	TRUE,	parm2_x;
	CALL3		ai_give_target;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_noncom_missile_strafe = asm
{
	DONE;
}

void() ai_noncom_hunt = asm
{
local entity friend;
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	16;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	parm0_x;
	CALL1		ai_find_friend;
	STORE_ENT	return_x,	friend;
	IFNOT		friend,	9;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_F	temp_3,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	STORE_F	friend,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	CALL3		ai_give_target;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_noncom_pain = asm
{
	DONE;
}

void() ai_noncom_die = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	'0.250000 0.250000 0.250000',	temp_0;
	ADDRESS	self,	attack_state,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_noncom_th = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_F	self,	attack_state,	parm0_x;
	CALL1		ai_state_control;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_SKIPTHINK,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	12;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	FL_SKIPTHINK,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_noncom_th,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () ai_noncom_tank;
void() ai_noncom_tank = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	CALL0		ai_unit_ini_var;
	INDIRECT_F	self,	nextVecChoice,	parm0_x;
	CALL1		data_iniVehc;
	INDIRECT_F	self,	ai_rank,	parm0_x;
	CALL1		ai_pilot_ini_stats;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_S	self,	target,	parm0_x;
	CALL1		ai_node_pick_rand;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	CALL0		droptofloor;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	ai_noncom_stand,	temp_1;
	ADDRESS	self,	th_walk,	temp_1;
	STOREP_FNC	ai_noncom_walk,	temp_1;
	ADDRESS	self,	th_run,	temp_1;
	STOREP_FNC	ai_noncom_run,	temp_1;
	ADDRESS	self,	th_run_strafe,	temp_1;
	STOREP_FNC	ai_noncom_run_strafe,	temp_1;
	ADDRESS	self,	th_run_charge,	temp_1;
	STOREP_FNC	ai_noncom_run_charge,	temp_1;
	ADDRESS	self,	th_missile,	temp_1;
	STOREP_FNC	ai_noncom_missile,	temp_1;
	ADDRESS	self,	th_melee,	temp_1;
	STOREP_FNC	ai_noncom_melee,	temp_1;
	ADDRESS	self,	th_missile_strafe,	temp_1;
	STOREP_FNC	ai_noncom_missile_strafe,	temp_1;
	ADDRESS	self,	th_hunt,	temp_1;
	STOREP_FNC	ai_noncom_hunt,	temp_1;
	ADDRESS	self,	th_pain,	temp_1;
	STOREP_FNC	ai_noncom_hunt,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	ai_noncom_die,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_initialize_system;
	CALL0		ai_walk_setup;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	'0.550000 1.000000 0.000000',	temp_0;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_noncom_th,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_INWATER,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	ADD_F		MOVETYPE_PUSH,	return_x,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		6;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	MUL_F		return_x,	0.900000,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () ai_vtol_crash;
void () ai_vtol_stand;
void () ai_vtol_walk;
void () ai_vtol_run;
void () ai_vtol_run_strafe;
void () ai_vtol_run_charge;
void () ai_vtol_melee;
void () ai_vtol_missile;
void () ai_vtol_missile_strafe;
void () ai_vtol_hunt;
void () ai_vtol_pain;
void () ai_vtol_die;
void () ai_vtol_th;
void() ai_vtol_stand = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	12;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		5;
	CALL0		ai_generic_stand;
	STORE_F	DAT_OTL_LARM_HP,	parm0_x;
	STORE_F	DAT_MTK_LTOR_HP,	parm1_x;
	CALL2		ai_fly_update;
	DONE;
}

void() ai_vtol_walk = asm
{
local float locked_2932;
local vector temp_0;
local vector temp_2;
local float temp_3;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	9;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	ideal_yaw,	locked_2932;
	INDIRECT_F	self,	m_fspeed,	temp_3;
	MUL_F		temp_3,	AI_RUN_SPD,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	GOTO		15;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_E	self,	movetarget,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STOREP_F	return_x,	locked_2932;
	CALL0		ai_move_turn;
	INDIRECT_F	self,	angles_y,	locked_2932;
	INDIRECT_F	self,	m_fspeed,	temp_3;
	MUL_F		temp_3,	AI_RUN_SPD,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	STORE_F	DAT_OTL_LARM_HP,	parm0_x;
	STORE_F	DAT_MTK_LTOR_HP,	parm1_x;
	CALL2		ai_fly_update;
	DONE;
}

void() ai_vtol_run = asm
{
local float locked_2932;
local float temp_3;
local float temp_4;
	ADDRESS	self,	attack_finished,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	164;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_vis;
	STORE_F	return_x,	enemy_vis;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	enemy_range;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	STORE_F	return_x,	enemy_infront;
	IFNOT		enemy_vis,	150;
	LE		enemy_range,	DAT_SFGA_DMG,	locked_2932;
	IFNOT		locked_2932,	42;
	IFNOT		enemy_infront,	41;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LT		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	31;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_dir,	locked_2932;
	CALL0		random;
	MUL_F		return_x,	STAT_TRG_LA_HP,	temp_3;
	ADD_F		IMP_SHOWOBJ,	temp_3,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	lefty,	locked_2932;
	GT		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	temp_3;
	MUL_F		temp_3,	CONTENT_EMPTY,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ai_dir,	temp_3;
	INDIRECT_F	self,	lefty,	temp_4;
	MUL_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	INDIRECT_F	self,	ai_dir,	temp_4;
	ADD_F		temp_3,	temp_4,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_STEP,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	STORE_F	FL_CLIENT,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_minrange,	locked_2932;
	LE		enemy_range,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	61;
	IFNOT		enemy_infront,	37;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LT		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	31;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_dir,	locked_2932;
	CALL0		random;
	MUL_F		return_x,	STAT_TRG_LA_HP,	temp_3;
	ADD_F		IMP_SHOWOBJ,	temp_3,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	lefty,	locked_2932;
	GT		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	temp_3;
	MUL_F		temp_3,	CONTENT_EMPTY,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ai_dir,	temp_3;
	INDIRECT_F	self,	lefty,	temp_4;
	MUL_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	INDIRECT_F	self,	ai_dir,	temp_4;
	ADD_F		temp_3,	temp_4,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_STEP,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	GT		locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	temp_3;
	MUL_F		temp_3,	-45.000000,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	INDIRECT_F	self,	lefty,	temp_4;
	ADD_F		temp_3,	temp_4,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_minrange,	locked_2932;
	MUL_F		locked_2932,	FL_SWIM,	locked_2932;
	LE		enemy_range,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	32;
	IFNOT		enemy_infront,	18;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	temp_3;
	MUL_F		temp_3,	-45.000000,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	INDIRECT_F	self,	lefty,	temp_4;
	ADD_F		temp_3,	temp_4,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_BOUNCE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	goalentity,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	MUL_F		skill,	FL_SWIM,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	INDIRECT_F	self,	ai_rank,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	ideal_yaw,	locked_2932;
	INDIRECT_F	self,	m_fspeed,	temp_3;
	MUL_F		temp_3,	AI_RUN_SPD,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	RETURN	offset_0;
	GOTO		4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_vtol_run_strafe = asm
{
local float locked_2932;
local float speeed;
local float temp_3;
local float temp_4;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	m_fspeed,	locked_2932;
	INDIRECT_F	self,	m_sspeed,	temp_3;
	ADD_F		locked_2932,	temp_3,	locked_2932;
	DIV_F		locked_2932,	FL_SWIM,	speeed;
	INDIRECT_F	self,	ai_dir,	locked_2932;
	MUL_F		speeed,	AI_RUN_SPD,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	STORE_F	DAT_OTL_LARM_HP,	parm0_x;
	STORE_F	DAT_MTK_LTOR_HP,	parm1_x;
	CALL2		ai_fly_update;
	INDIRECT_F	self,	ai_action_time,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	42;
	INDIRECT_F	self,	ai_rank,	locked_2932;
	LT		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	31;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_dir,	locked_2932;
	CALL0		random;
	MUL_F		return_x,	STAT_TRG_LA_HP,	temp_3;
	ADD_F		IMP_SHOWOBJ,	temp_3,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	lefty,	locked_2932;
	GT		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	temp_3;
	MUL_F		temp_3,	CONTENT_EMPTY,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ai_dir,	temp_3;
	INDIRECT_F	self,	lefty,	temp_4;
	MUL_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	INDIRECT_F	self,	ai_dir,	temp_4;
	ADD_F		temp_3,	temp_4,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	MOVETYPE_STEP,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	GT		skill,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_vtol_run_charge = asm
{
local float temp_1;
local float temp_3;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	ai_dir,	temp_1;
	INDIRECT_F	self,	m_fspeed,	temp_3;
	MUL_F		temp_3,	AI_RUN_SPD,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	STORE_F	DAT_OTL_LARM_HP,	parm0_x;
	STORE_F	DAT_MTK_LTOR_HP,	parm1_x;
	CALL2		ai_fly_update;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_F	self,	ai_rank,	temp_1;
	GT		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_vtol_melee = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	angles_y,	temp_1;
	INDIRECT_F	self,	ideal_yaw,	temp_3;
	NE_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	angles_y,	temp_1;
	INDIRECT_F	self,	m_fspeed,	temp_3;
	MUL_F		temp_3,	AI_WALK_SPD,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	STORE_F	DAT_OTL_LARM_HP,	parm0_x;
	STORE_F	DAT_MTK_LTOR_HP,	parm1_x;
	CALL2		ai_fly_update;
	INDIRECT_F	self,	ai_rank,	temp_1;
	LT		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.970000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	2;
	CALL0		ai_attack;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_F	self,	ai_rank,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_rank,	temp_1;
	EQ_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	8;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_vtol_missile = asm
{
local float temp_1;
	CALL0		ai_face_targ;
	STORE_F	DAT_OTL_LARM_HP,	parm0_x;
	STORE_F	DAT_MTK_LTOR_HP,	parm1_x;
	CALL2		ai_fly_update;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.970000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	12;
	CALL0		ai_attack;
	IFNOT		return_x,	10;
	INDIRECT_F	self,	ai_rank,	temp_1;
	LT		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_vtol_missile_strafe = asm
{
local float speeed;
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	28;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	INDIRECT_F	self,	m_sspeed,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	speeed;
	INDIRECT_F	self,	ai_dir,	temp_1;
	MUL_F		speeed,	AI_RUN_SPD,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	STORE_F	DAT_PAC_DMG,	parm0_x;
	STORE_F	DAT_MTK_LTOR_HP,	parm1_x;
	CALL2		ai_fly_update;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.970000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	10;
	CALL0		ai_attack;
	IFNOT		return_x,	8;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	GOTO		14;
	INDIRECT_F	self,	ai_rank,	temp_1;
	LT		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_vtol_hunt = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	10;
	STORE_F	AI_RUN_SPD,	parm0_x;
	CALL1		ai_walkgoal;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_vis;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		7;
	ADDRESS	self,	goalentity,	temp_1;
	INDIRECT_E	self,	movetarget,	temp_3;
	STOREP_ENT	temp_3,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	11;
	ADDRESS	self,	goalentity,	temp_1;
	INDIRECT_E	self,	movetarget,	temp_3;
	STOREP_ENT	temp_3,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_3;
	ADD_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	DONE;
}

void() ai_vtol_pain = asm
{
	DONE;
}

void() ai_vtol_crash = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	INDIRECT_F	other,	takedamage,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_F	self,	health,	temp_1;
	MUL_F		temp_1,	CONTENT_EMPTY,	temp_1;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	MOVETYPE_BOUNCE,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_vtol_die = asm
{
local entity w_chain;
local vector temp_0;
local float temp_1;
local float temp_3;
local float temp_4;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	TRUE,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	colormod_x,	temp_0_x;
	STOREP_V	'0.250000 0.250000 0.250000',	temp_0;
	ADDRESS	self,	attack_state,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	INDIRECT_E	self,	w_slot,	w_chain;
	IFNOT		w_chain,	5;
	STORE_F	w_chain,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	w_chain,	w_slot,	w_chain;
	GOTO		-4;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	ai_vtol_crash,	temp_1;
	DONE;
}

void() ai_vtol_th = asm
{
local float locked_2932;
local entity wep;
local vector temp_0;
local vector temp_2;
local float temp_3;
local float temp_4;
	CALL0		ctrl_updateCenterTorso;
	INDIRECT_E	self,	w_slot,	wep;
	IFNOT		wep,	5;
	STORE_F	wep,	parm0_x;
	CALL1		ctrl_wpn_think;
	INDIRECT_E	wep,	w_slot,	wep;
	GOTO		-4;
	INDIRECT_F	self,	deadflag,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	39;
	INDIRECT_E	self,	enemy,	locked_2932;
	IFNOT		locked_2932,	32;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	27;
	ADDRESS	self,	stat_trg_dist,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group1,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group2,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_RPLAS_RANGE,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group3,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ION_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	GOTO		3;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	world,	locked_2932;
	CALL0		ai_ranged_attack;
	ADDRESS	self,	button0,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_F	self,	attack_state,	parm0_x;
	CALL1		ai_state_control;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_SKIPTHINK,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	12;
	ADDRESS	self,	flags,	locked_2932;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	FL_SKIPTHINK,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	ai_vtol_th,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	DONE;
}

void () ai_vtol;
void() ai_vtol = asm
{
local float temp_1;
local float temp_3;
	CALL0		ai_unit_ini_var;
	INDIRECT_F	self,	nextVecChoice,	parm0_x;
	CALL1		data_iniVehc;
	INDIRECT_F	self,	ai_rank,	parm0_x;
	CALL1		ai_pilot_ini_stats;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_S	self,	target,	parm0_x;
	CALL1		ai_node_pick_rand;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	ai_vtol_stand,	temp_1;
	ADDRESS	self,	th_walk,	temp_1;
	STOREP_FNC	ai_vtol_walk,	temp_1;
	ADDRESS	self,	th_run,	temp_1;
	STOREP_FNC	ai_vtol_run,	temp_1;
	ADDRESS	self,	th_run_strafe,	temp_1;
	STOREP_FNC	ai_vtol_run_strafe,	temp_1;
	ADDRESS	self,	th_run_charge,	temp_1;
	STOREP_FNC	ai_vtol_run_charge,	temp_1;
	ADDRESS	self,	th_missile,	temp_1;
	STOREP_FNC	ai_vtol_missile,	temp_1;
	ADDRESS	self,	th_melee,	temp_1;
	STOREP_FNC	ai_vtol_melee,	temp_1;
	ADDRESS	self,	th_missile_strafe,	temp_1;
	STOREP_FNC	ai_vtol_missile_strafe,	temp_1;
	ADDRESS	self,	th_hunt,	temp_1;
	STOREP_FNC	ai_vtol_hunt,	temp_1;
	ADDRESS	self,	th_pain,	temp_1;
	STOREP_FNC	ai_vtol_pain,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	ai_vtol_die,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_initialize_system;
	CALL0		ai_walk_setup;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_vtol_th,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_INWATER,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	ADD_F		MOVETYPE_PUSH,	return_x,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		6;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	MUL_F		return_x,	0.900000,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

float () ai_gev_setDuration;
float() ai_gev_setDuration = asm
{
local float vel;
local float duration;
local float temp_1;
	SUB_F		3.100000,	skill,	duration;
	INDIRECT_F	self,	ai_rank,	temp_1;
	SUB_F		MOVETYPE_STEP,	temp_1,	temp_1;
	ADD_F		duration,	temp_1,	duration;
	INDIRECT_F	self,	vec_size,	temp_1;
	SUB_F		temp_1,	TRUE,	temp_1;
	ADD_F		duration,	temp_1,	duration;
	DIV_F		duration,	MOVETYPE_BOUNCE,	duration;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	vel;
	MUL_F		vel,	20.000000,	temp_1;
	DIV_F		temp_1,	DAT_OTL_CTOR_HP,	vel;
	ADD_F		duration,	vel,	duration;
	CALL0		random;
	MUL_F		duration,	return_x,	duration;
	RETURN	duration;
	DONE;
}

void () ai_gev_setStrafe;
void() ai_gev_setStrafe = asm
{
	DONE;
}

float () ai_gev_lefty;
float() ai_gev_lefty = asm
{
local float temp_1;
local float temp_3;
	CALL0		random;
	GT		return_x,	0.490000,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	lefty,	temp_1;
	INDIRECT_F	self,	lefty,	temp_3;
	SUB_F		TRUE,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	temp_3;
	INDIRECT_F	self,	lefty,	temp_1;
	RETURN	temp_1;
	DONE;
}

void () ai_gev_crash;
void () ai_gev_stand;
void () ai_gev_walk;
void () ai_gev_run;
void () ai_gev_run_strafe;
void () ai_gev_run_charge;
void () ai_gev_melee;
void () ai_gev_missile;
void () ai_gev_missile_strafe;
void () ai_gev_hunt;
void () ai_gev_pain;
void () ai_gev_die;
void () ai_gev_th;
void() ai_gev_stand = asm
{
local float temp_1;
local float temp_3;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	12;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	self,	ai_fov,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	GOTO		2;
	CALL0		ai_generic_stand;
	DONE;
}

void() ai_gev_walk = asm
{
local float temp_1;
local float temp_3;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	9;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	angles_y,	temp_1;
	INDIRECT_F	self,	m_fspeed,	temp_3;
	MUL_F		temp_3,	AI_RUN_SPD,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	GOTO		2;
	CALL0		ai_generic_walk;
	DONE;
}

void() ai_gev_run = asm
{
local float locked_916;
local float locked_2932;
local float range;
local float angl;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	141;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_vis;
	STORE_F	return_x,	enemy_vis;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	enemy_range;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_F	self,	ai_fov,	locked_916;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	CALL2		ai_check_face;
	STORE_F	return_x,	enemy_infront;
	IFNOT		enemy_vis,	127;
	LE		enemy_range,	DAT_PRJ_QRFL_VELOCITY,	locked_2932;
	IFNOT		locked_2932,	22;
	IFNOT		enemy_infront,	18;
	GT		skill,	TRUE,	locked_2932;
	IF		locked_2932,	3;
	INDIRECT_F	self,	ai_rank,	locked_916;
	LT		locked_916,	FL_SWIM,	locked_916;
	OR		locked_2932,	locked_916,	locked_2932;
	IFNOT		locked_2932,	4;
	STORE_F	FL_CLIENT,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	STORE_F	MOVETYPE_TOSS,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_gev_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_minrange,	locked_2932;
	LE		enemy_range,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	42;
	IFNOT		enemy_infront,	33;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.920000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	21;
	CALL0		ai_attack;
	IFNOT		return_x,	19;
	CALL0		random;
	MUL_F		return_x,	STAT_TRG_ORGZ,	locked_2932;
	ADD_F		IMP_SHOWOBJ,	locked_2932,	angl;
	CALL0		ai_gev_lefty;
	MUL_F		angl,	return_x,	angl;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_gev_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	ADD_F		locked_916,	angl,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_TOSS,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_gev_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_gev_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_minrange,	locked_2932;
	MUL_F		locked_2932,	FL_SWIM,	locked_2932;
	LE		enemy_range,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	48;
	IFNOT		enemy_infront,	39;
	GT		skill,	TRUE,	locked_2932;
	IF		locked_2932,	3;
	INDIRECT_F	self,	ai_rank,	locked_916;
	LT		locked_916,	FL_SWIM,	locked_916;
	OR		locked_2932,	locked_916,	locked_2932;
	IFNOT		locked_2932,	25;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.920000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	21;
	CALL0		ai_attack;
	IFNOT		return_x,	19;
	CALL0		random;
	MUL_F		return_x,	STAT_TRG_ORGZ,	locked_2932;
	ADD_F		IMP_SHOWOBJ,	locked_2932,	angl;
	CALL0		ai_gev_lefty;
	MUL_F		angl,	return_x,	angl;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_gev_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	ADD_F		locked_916,	angl,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	SUB_F		locked_916,	180.000000,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_TOSS,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_gev_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	ideal_yaw,	locked_2932;
	INDIRECT_F	self,	m_fspeed,	locked_916;
	MUL_F		locked_916,	AI_RUN_SPD,	locked_916;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	CALL2		ai_move;
	RETURN	offset_0;
	GOTO		4;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_gev_run_strafe = asm
{
local float spd;
local float temp_1;
local float temp_3;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	temp_1;
	INDIRECT_F	self,	m_sspeed,	temp_3;
	ADD_F		temp_1,	temp_3,	spd;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	ai_dir,	temp_1;
	INDIRECT_F	self,	lefty,	temp_3;
	MUL_F		temp_1,	temp_3,	temp_1;
	MUL_F		spd,	AI_RUN_SPD,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	5;
	ADDRESS	self,	lefty,	temp_1;
	INDIRECT_F	self,	lefty,	temp_3;
	SUB_F		TRUE,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_gev_run_charge = asm
{
local float temp_1;
local float temp_3;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	CALL0		ai_face_targ;
	INDIRECT_F	self,	angles_y,	temp_1;
	ADD_F		temp_1,	DAT_PRJ_FLAK_PROXYRAD,	parm0_x;
	CALL1		anglemod;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	MUL_F		temp_1,	AI_RUN_SPD,	temp_1;
	STORE_F	return_x,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		ai_move;
	GT		skill,	TRUE,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	self,	ai_rank,	temp_3;
	LT		temp_3,	FL_SWIM,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.920000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	2;
	CALL0		ai_attack;
	INDIRECT_F	self,	ai_action_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_gev_melee = asm
{
local float locked_916;
local float locked_2932;
local float insights;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_check_range;
	STORE_F	return_x,	enemy_range;
	STORE_ENT	self,	otemp;
	INDIRECT_E	otemp,	enemy,	self;
	STORE_F	otemp,	parm0_x;
	STORE_F	0.870000,	parm1_x;
	CALL2		ai_check_face;
	STORE_F	return_x,	insights;
	STORE_ENT	otemp,	self;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.920000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	2;
	CALL0		ai_attack;
	INDIRECT_F	self,	lefty,	locked_2932;
	MUL_F		STAT_TRG_LA_HP,	locked_2932,	locked_2932;
	INDIRECT_F	self,	m_fspeed,	locked_916;
	MUL_F		locked_916,	AI_WALK_SPD,	locked_916;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	CALL2		ai_yaw_move;
	NE_F		return_x,	FALSE,	locked_2932;
	IF		locked_2932,	5;
	ADDRESS	self,	lefty,	locked_2932;
	INDIRECT_F	self,	lefty,	locked_916;
	SUB_F		FALSE,	locked_916,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	NE_F		insights,	FALSE,	locked_2932;
	IF		locked_2932,	4;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	29;
	NE_F		insights,	FALSE,	locked_2932;
	IF		locked_2932,	24;
	LE		enemy_range,	STAT_PLR_ANG_X,	locked_2932;
	IFNOT		locked_2932,	14;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_gev_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	SUB_F		locked_916,	180.000000,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_gev_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_gev_missile = asm
{
local float locked_916;
local float locked_2932;
local float angl;
local float insights;
	STORE_F	FALSE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	14;
	STORE_ENT	self,	otemp;
	INDIRECT_E	otemp,	enemy,	self;
	STORE_F	otemp,	parm0_x;
	STORE_F	0.870000,	parm1_x;
	CALL2		ai_check_face;
	STORE_F	return_x,	insights;
	STORE_ENT	otemp,	self;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.920000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	2;
	CALL0		ai_attack;
	INDIRECT_F	self,	ai_action_time,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	37;
	IFNOT		insights,	33;
	GT		skill,	TRUE,	locked_2932;
	IF		locked_2932,	3;
	INDIRECT_F	self,	ai_rank,	locked_916;
	LT		locked_916,	FL_SWIM,	locked_916;
	OR		locked_2932,	locked_916,	locked_2932;
	IFNOT		locked_2932,	19;
	CALL0		random;
	MUL_F		return_x,	STAT_TRG_ORGZ,	locked_2932;
	ADD_F		IMP_SHOWOBJ,	locked_2932,	angl;
	CALL0		ai_gev_lefty;
	MUL_F		angl,	return_x,	angl;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_gev_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ideal_yaw,	locked_916;
	ADD_F		locked_916,	angl,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_TOSS,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_gev_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_gev_missile_strafe = asm
{
local float locked_916;
local float locked_2932;
local float angl;
local float spd;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_F	self,	m_fspeed,	locked_2932;
	DIV_F		locked_2932,	FL_SWIM,	locked_2932;
	INDIRECT_F	self,	m_sspeed,	locked_916;
	ADD_F		locked_2932,	locked_916,	spd;
	CALL0		ai_face_targ;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	0.920000,	parm1_x;
	CALL2		ai_check_face;
	IFNOT		return_x,	2;
	CALL0		ai_attack;
	INDIRECT_F	self,	ai_dir,	locked_2932;
	MUL_F		spd,	AI_RUN_SPD,	locked_916;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	CALL2		ai_move;
	NE_F		return_x,	FALSE,	locked_2932;
	IF		locked_2932,	19;
	CALL0		random;
	MUL_F		return_x,	STAT_TRG_ORGZ,	locked_2932;
	ADD_F		IMP_SHOWOBJ,	locked_2932,	angl;
	CALL0		ai_gev_lefty;
	MUL_F		angl,	return_x,	angl;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_dir,	locked_2932;
	INDIRECT_F	self,	ai_dir,	locked_916;
	SUB_F		locked_916,	angl,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	CALL0		ai_gev_setDuration;
	ADD_F		locked_916,	return_x,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	RETURN	offset_0;
	INDIRECT_F	self,	ai_action_time,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_gev_hunt = asm
{
	DONE;
}

void() ai_gev_pain = asm
{
local float locked_2932;
local vector temp_0;
local vector temp_2;
local float temp_3;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_update_accuracy;
	INDIRECT_E	self,	goalentity,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	15;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_E	self,	goalentity,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STOREP_F	return_x,	locked_2932;
	CALL0		ai_move_turn;
	INDIRECT_F	self,	ideal_yaw,	locked_2932;
	INDIRECT_F	self,	m_fspeed,	temp_3;
	MUL_F		temp_3,	AI_RUN_SPD,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		ai_move;
	INDIRECT_F	self,	ai_action_time,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	4;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		ai_next_state;
	RETURN	offset_0;
	DONE;
}

void() ai_gev_crash = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	INDIRECT_F	other,	takedamage,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_F	self,	health,	temp_1;
	MUL_F		temp_1,	CONTENT_EMPTY,	temp_1;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	MOVETYPE_BOUNCE,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ai_gev_die = asm
{
local float locked_2939;
local vector v;
local entity w_chain;
local float temp_1;
local vector temp_2;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	colormod_x,	locked_2939;
	STOREP_V	'0.250000 0.250000 0.250000',	locked_2939;
	ADDRESS	self,	attack_state,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	INDIRECT_E	self,	w_slot,	w_chain;
	IFNOT		w_chain,	5;
	STORE_F	w_chain,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	w_chain,	w_slot,	w_chain;
	GOTO		-4;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	locked_2939;
	INDIRECT_F	self,	m_fspeed,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_F	self,	m_sspeed,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	MUL_VF	v_up,	DAT_OTL_CTOR_HP,	temp_2;
	ADD_V		locked_2939,	temp_2,	v;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_2,	v,	parm0;
	CALL1		normalize;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	temp_2;
	MUL_VF	temp_2,	DAT_SFGA_DMG,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	avelocity_x,	locked_2939;
	STOREP_V	'250.000000 100.000000 500.000000',	locked_2939;
	DONE;
}

void() ai_gev_th = asm
{
local float locked_2932;
local entity wep;
local vector temp_0;
local vector temp_2;
local float temp_3;
local float temp_4;
	CALL0		ctrl_updateCenterTorso;
	INDIRECT_E	self,	w_slot,	wep;
	IFNOT		wep,	5;
	STORE_F	wep,	parm0_x;
	CALL1		ctrl_wpn_think;
	INDIRECT_E	wep,	w_slot,	wep;
	GOTO		-4;
	INDIRECT_F	self,	deadflag,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	39;
	INDIRECT_E	self,	enemy,	locked_2932;
	IFNOT		locked_2932,	32;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	27;
	ADDRESS	self,	stat_trg_dist,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_V	temp_3,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group1,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ABT_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group2,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_RPLAS_RANGE,	parm2_x;
	CALL3		ai_wep_group_track;
	INDIRECT_F	self,	stat_trg_dist,	locked_2932;
	INDIRECT_F	self,	w_group3,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	DAT_PRJ_ION_VELOCITY,	parm2_x;
	CALL3		ai_wep_group_track;
	GOTO		3;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	world,	locked_2932;
	CALL0		ai_ranged_attack;
	ADDRESS	self,	button0,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_F	self,	attack_state,	parm0_x;
	CALL1		ai_state_control;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_SKIPTHINK,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	12;
	ADDRESS	self,	flags,	locked_2932;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	FL_SKIPTHINK,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	ai_gev_th,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	DONE;
}

void () ai_gev;
void() ai_gev = asm
{
local float temp_1;
local float temp_3;
	CALL0		ai_unit_ini_var;
	INDIRECT_F	self,	nextVecChoice,	parm0_x;
	CALL1		data_iniVehc;
	INDIRECT_F	self,	ai_rank,	parm0_x;
	CALL1		ai_pilot_ini_stats;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_S	self,	target,	parm0_x;
	CALL1		ai_node_pick_rand;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	ai_gev_stand,	temp_1;
	ADDRESS	self,	th_walk,	temp_1;
	STOREP_FNC	ai_gev_walk,	temp_1;
	ADDRESS	self,	th_run,	temp_1;
	STOREP_FNC	ai_gev_run,	temp_1;
	ADDRESS	self,	th_run_strafe,	temp_1;
	STOREP_FNC	ai_gev_run_strafe,	temp_1;
	ADDRESS	self,	th_run_charge,	temp_1;
	STOREP_FNC	ai_gev_run_charge,	temp_1;
	ADDRESS	self,	th_missile,	temp_1;
	STOREP_FNC	ai_gev_missile,	temp_1;
	ADDRESS	self,	th_melee,	temp_1;
	STOREP_FNC	ai_gev_melee,	temp_1;
	ADDRESS	self,	th_missile_strafe,	temp_1;
	STOREP_FNC	ai_gev_missile_strafe,	temp_1;
	ADDRESS	self,	th_hunt,	temp_1;
	STOREP_FNC	ai_gev_hunt,	temp_1;
	ADDRESS	self,	th_pain,	temp_1;
	STOREP_FNC	ai_gev_pain,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	ai_gev_die,	temp_1;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_initialize_system;
	CALL0		droptofloor;
	CALL0		ai_walk_setup;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	ai_gev_th,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_INWATER,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	ADD_F		MOVETYPE_PUSH,	return_x,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		6;
	ADDRESS	self,	nextthink,	temp_1;
	CALL0		random;
	MUL_F		return_x,	0.900000,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

float AI_NODE_PATROL;
float AI_NODE_DEFEND;
float AI_NODE_ATTACK;
float NODE_SPAWN_DROP;
float NODE_SPAWN_REMOVEONTOUCH;
float NODE_SPAWN_INACTIVE;
float NODE_SPAWN_INACTIVEONTOUCH;
void () node_use;
void() node_use = asm
{
local float temp_1;
	INDIRECT_F	self,	isActive,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	6;
	ADDRESS	self,	isActive,	temp_1;
	STOREP_F	TRUE,	temp_1;
	STORE_F	world,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	DONE;
}

void() node_setup = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	FL_NODE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"ai_node",	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	STORE_V	'-10.000000 -10.000000 -18.000000',	parm1;
	STORE_V	'10.000000 10.000000 18.000000',	parm2;
	CALL3		setsize;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	13;
	INDIRECT_V	self,	angles_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_F	self,	mins_z,	temp_1;
	ADD_F		temp_1,	MOVETYPE_STEP,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	temp_1,	parm2_x;
	CALL3		util_dropToGround;
	STORE_F	self,	parm0_x;
	STORE_V	return,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	TRUE,	temp_1;
	INDIRECT_F	self,	pausetime,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	3;
	ADDRESS	self,	pausetime,	temp_1;
	STOREP_F	0.100000,	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	node_touch,	temp_1;
	ADDRESS	self,	isActive,	temp_1;
	STOREP_F	TRUE,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	isActive,	temp_1;
	STOREP_F	FALSE,	temp_1;
	RETURN	offset_0;
	STORE_F	world,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	DONE;
}

void () ai_node_hunt_t;
void() ai_node_hunt_t = asm
{
local float locked_916;
local float locked_2932;
local float t;
local entity this;
local vector temp_0;
local vector temp_2;
local float temp_4;
	INDIRECT_E	self,	owner,	locked_2932;
	EQ_E		other,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	4;
	INDIRECT_E	self,	owner,	locked_916;
	INDIRECT_F	locked_916,	deadflag,	locked_916;
	EQ_F		locked_916,	FALSE,	locked_916;
	AND		locked_2932,	locked_916,	locked_2932;
	IFNOT		locked_2932,	58;
	STORE_ENT	self,	this;
	STORE_ENT	other,	self;
	ADDRESS	self,	ai_hunt_total,	locked_2932;
	INDIRECT_F	self,	ai_hunt_total,	locked_916;
	SUB_F		locked_916,	TRUE,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	INDIRECT_F	self,	ai_hunt_total,	locked_2932;
	EQ_F		locked_2932,	CONTENT_EMPTY,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	goalentity,	locked_2932;
	INDIRECT_E	self,	movetarget,	locked_916;
	STOREP_ENT	locked_916,	locked_2932;
	GOTO		16;
	INDIRECT_S	this,	target,	locked_2932;
	IFNOT		locked_2932,	11;
	ADDRESS	self,	goalentity,	locked_2932;
	ADDRESS	self,	ai_hunt_node,	locked_916;
	INDIRECT_S	this,	target,	temp_4;
	STORE_F	world,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	temp_4,	parm2_x;
	CALL3		find;
	STOREP_ENT	return_x,	locked_916;
	STOREP_ENT	return_x,	locked_2932;
	GOTO		4;
	ADDRESS	self,	goalentity,	locked_2932;
	INDIRECT_E	self,	movetarget,	locked_916;
	STOREP_ENT	locked_916,	locked_2932;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_up,	0.500000,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	INDIRECT_F	self,	m_fspeed,	locked_2932;
	MUL_F		locked_2932,	AI_WALK_SPD,	locked_2932;
	INDIRECT_E	self,	goalentity,	locked_916;
	INDIRECT_V	locked_916,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	ARM_LT_MOD,	parm2_x;
	CALL3		ai_move_time;
	STORE_F	return_x,	t;
	ADDRESS	self,	ai_viewtime,	locked_2932;
	INDIRECT_F	self,	ai_viewcheck,	locked_916;
	ADD_F		time,	locked_916,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	STORE_ENT	this,	self;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	RETURN	offset_0;
	DONE;
}

void () ai_node_hunt_th;
void() ai_node_hunt_th = asm
{
local float locked_916;
local float locked_2932;
local entity this;
local vector temp_0;
local vector temp_2;
local float temp_4;
	INDIRECT_F	self,	pausetime,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	60;
	INDIRECT_E	self,	owner,	locked_2932;
	IFNOT		locked_2932,	4;
	INDIRECT_E	self,	owner,	locked_916;
	INDIRECT_F	locked_916,	deadflag,	locked_916;
	EQ_F		locked_916,	FALSE,	locked_916;
	AND		locked_2932,	locked_916,	locked_2932;
	IFNOT		locked_2932,	50;
	STORE_ENT	self,	this;
	INDIRECT_E	this,	owner,	self;
	ADDRESS	self,	ai_hunt_total,	locked_2932;
	INDIRECT_F	self,	ai_hunt_total,	locked_916;
	SUB_F		locked_916,	TRUE,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	INDIRECT_F	self,	ai_hunt_total,	locked_2932;
	EQ_F		locked_2932,	CONTENT_EMPTY,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	goalentity,	locked_2932;
	INDIRECT_E	self,	movetarget,	locked_916;
	STOREP_ENT	locked_916,	locked_2932;
	GOTO		16;
	INDIRECT_S	this,	target,	locked_2932;
	IFNOT		locked_2932,	11;
	ADDRESS	self,	goalentity,	locked_2932;
	ADDRESS	self,	ai_hunt_node,	locked_916;
	INDIRECT_S	this,	target,	temp_4;
	STORE_F	world,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	temp_4,	parm2_x;
	CALL3		find;
	STOREP_ENT	return_x,	locked_916;
	STOREP_ENT	return_x,	locked_2932;
	GOTO		4;
	ADDRESS	self,	goalentity,	locked_2932;
	INDIRECT_E	self,	movetarget,	locked_916;
	STOREP_ENT	locked_916,	locked_2932;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_up,	0.500000,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_E	self,	goalentity,	locked_916;
	INDIRECT_V	locked_916,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	ai_viewtime,	locked_2932;
	INDIRECT_F	self,	ai_viewcheck,	locked_916;
	ADD_F		time,	locked_916,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	STORE_ENT	this,	self;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	ADDRESS	self,	nextthink,	locked_2932;
	ADD_F		time,	0.100000,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	ai_node_hunt_th,	locked_2932;
	DONE;
}

entity(vector orig, string nodeid, float id, float fadetime, void () action) ai_node_hunt = asm
{
local float locked_2932;
local float totes;
local entity tnode;
local entity this;
local float temp_3;
	STORE_F	id,	totes;
	CALL0		spawn;
	STORE_ENT	return_x,	tnode;
	STORE_ENT	self,	this;
	STORE_ENT	tnode,	self;
	ADDRESS	self,	solid,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	STORE_F	self,	parm0_x;
	STORE_V	'-2.000000 -2.000000 -16.000000',	parm1;
	STORE_V	'2.000000 2.000000 16.000000',	parm2;
	CALL3		setsize;
	STORE_F	self,	parm0_x;
	STORE_V	orig,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	ADDRESS	self,	targetname,	locked_2932;
	STORE_F	id,	parm0_x;
	CALL1		ftos;
	STORE_F	nodeid,	parm0_x;
	STORE_F	"_",	parm1_x;
	STORE_F	return_x,	parm2_x;
	CALL3		strcat;
	STORE_F	return_x,	parm0_x;
	CALL1		strzone;
	STOREP_S	return_x,	locked_2932;
	SUB_F		totes,	TRUE,	totes;
	GT		totes,	CONTENT_EMPTY,	locked_2932;
	IFNOT		locked_2932,	12;
	ADDRESS	self,	target,	locked_2932;
	STORE_F	totes,	parm0_x;
	CALL1		ftos;
	STORE_F	nodeid,	parm0_x;
	STORE_F	"_",	parm1_x;
	STORE_F	return_x,	parm2_x;
	CALL3		strcat;
	STORE_F	return_x,	parm0_x;
	CALL1		strzone;
	STOREP_S	return_x,	locked_2932;
	GOTO		5;
	ADDRESS	self,	target,	locked_2932;
	INDIRECT_E	this,	movetarget,	temp_3;
	INDIRECT_S	temp_3,	targetname,	temp_3;
	STOREP_S	temp_3,	locked_2932;
	ADDRESS	self,	pausetime,	locked_2932;
	ADD_F		time,	fadetime,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	owner,	locked_2932;
	STOREP_ENT	this,	locked_2932;
	ADDRESS	self,	th_stand,	locked_2932;
	STOREP_FNC	action,	locked_2932;
	ADDRESS	self,	touch,	locked_2932;
	STOREP_FNC	ai_node_hunt_t,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	ai_node_hunt_th,	locked_2932;
	STORE_ENT	this,	self;
	RETURN	tnode;
	DONE;
}

void (entity) node_patrol_t;
void(entity o) node_patrol_t = asm
{
local float locked_916;
local float locked_2932;
local entity temp;
local vector temp_0;
local vector temp_2;
local float temp_4;
	INDIRECT_E	other,	movetarget,	locked_2932;
	NE_E		locked_2932,	self,	locked_2932;
	IFNOT		locked_2932,	2;
	RETURN	offset_0;
	INDIRECT_E	other,	enemy,	locked_2932;
	IFNOT		locked_2932,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	i_faction,	locked_2932;
	INDIRECT_F	other,	i_faction,	locked_916;
	EQ_F		locked_2932,	locked_916,	locked_2932;
	IFNOT		locked_2932,	45;
	STORE_ENT	self,	temp;
	STORE_ENT	other,	self;
	STORE_ENT	temp,	other;
	ADDRESS	self,	goalentity,	locked_2932;
	ADDRESS	self,	movetarget,	locked_916;
	INDIRECT_S	other,	target,	temp_4;
	STORE_F	world,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	temp_4,	parm2_x;
	CALL3		find;
	STOREP_ENT	return_x,	locked_916;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	self,	ideal_yaw,	locked_2932;
	INDIRECT_E	self,	goalentity,	locked_916;
	INDIRECT_V	locked_916,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vectoyaw;
	STOREP_F	return_x,	locked_2932;
	STORE_F	leg_stand1,	parm0_x;
	CALL1		ai_leg_frame;
	INDIRECT_E	self,	movetarget,	locked_2932;
	IFNOT		locked_2932,	18;
	INDIRECT_F	other,	pausetime,	locked_2932;
	IFNOT		locked_2932,	10;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	ADDRESS	self,	ai_action_time,	locked_2932;
	INDIRECT_F	self,	ai_action_time,	locked_916;
	INDIRECT_F	other,	pausetime,	temp_4;
	ADD_F		locked_916,	temp_4,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	STORE_ENT	temp,	self;
	RETURN	offset_0;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ai_next_state;
	STORE_F	leg_walk1,	parm0_x;
	CALL1		ai_leg_frame;
	STORE_ENT	temp,	self;
	RETURN	offset_0;
	STORE_F	TRUE,	parm0_x;
	CALL1		ai_next_state;
	STORE_ENT	temp,	self;
	RETURN	offset_0;
	DONE;
}

void() ai_node_t_defend = asm
{
	DONE;
}

void() ai_node_t_attack = asm
{
	DONE;
}

void() node_touch = asm
{
local float locked_2932;
local float temp_3;
	INDIRECT_F	self,	isActive,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	flags,	locked_2932;
	BITAND	locked_2932,	FL_MONSTER,	locked_2932;
	IFNOT		locked_2932,	14;
	INDIRECT_F	self,	data_idx,	locked_2932;
	GOTO		6;
	STORE_F	other,	parm0_x;
	CALL1		node_patrol_t;
	GOTO		9;
	GOTO		8;
	GOTO		7;
	EQ_F		locked_2932,	TRUE,	temp_3;
	IF		temp_3,	-6;
	EQ_F		locked_2932,	FL_SWIM,	temp_3;
	IF		temp_3,	-5;
	EQ_F		locked_2932,	MOVETYPE_WALK,	temp_3;
	IF		temp_3,	-6;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	6;
	STORE_F	world,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	isActive,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	DONE;
}

void () ai_node;
void() ai_node = asm
{
local float temp_1;
	INDIRECT_S	self,	targetname,	temp_1;
	NOT_S		temp_1,	temp_1;
	IFNOT		temp_1,	6;
	STORE_F	"node - missing targetname",	parm0_x;
	CALL1		objerror;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	CALL0		node_setup;
	DONE;
}

float(entity targ, entity inflictor, float dmg_amt) t_damage_bal = asm
{
local float crit;
local float mod;
local float shields;
local float dmgtype;
local float damage;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_F	inflictor,	p_dmgtype,	dmgtype;
	STORE_F	dmg_amt,	damage;
	INDIRECT_F	targ,	sh_cur,	shields;
	GT		shields,	FALSE,	temp_1;
	IFNOT		temp_1,	6;
	DIV_F		damage,	FL_SWIM,	temp_1;
	SUB_F		damage,	temp_1,	damage;
	SUB_F		shields,	damage,	shields;
	STORE_F	FALSE,	damage;
	GOTO		22;
	BITAND	dmgtype,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	2;
	MUL_F		damage,	FL_SWIM,	damage;
	MUL_F		dmgtype,	FL_INWATER,	temp_1;
	IFNOT		temp_1,	17;
	STORE_F	0.250000,	crit;
	SUB_F		MOVETYPE_WALK,	skill,	temp_1;
	DIV_F		temp_1,	MOVETYPE_BOUNCE,	temp_1;
	ADD_F		crit,	temp_1,	crit;
	INDIRECT_F	targ,	vec_size,	temp_1;
	SUB_F		MOVETYPE_WALK,	temp_1,	temp_1;
	DIV_F		temp_1,	MOVETYPE_BOUNCE,	temp_1;
	ADD_F		crit,	temp_1,	crit;
	INDIRECT_F	targ,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	2;
	DIV_F		crit,	SHVEXP_EFFSTX_PERCENTAGE,	crit;
	CALL0		random;
	LE		return_x,	crit,	temp_1;
	IFNOT		temp_1,	2;
	MUL_F		damage,	SHVBAL_EFFRAM_PERCENTAGE,	damage;
	LT		shields,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	FALSE,	shields;
	ADDRESS	targ,	sh_cur,	temp_1;
	STOREP_F	shields,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	24;
	ADDRESS	targ,	sh_hit,	temp_1;
	DIV_F		dmg_amt,	STAT_PLR_ANG_X,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	targ,	sh_hit,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_3;
	INDIRECT_F	targ,	vec_size,	temp_4;
	SUB_F		MOVETYPE_STEP,	temp_4,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	targ,	sh_hit,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_3;
	SUB_F		MOVETYPE_WALK,	skill,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	EQ_F		shields,	FALSE,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	targ,	sh_hit,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_3;
	INDIRECT_F	targ,	sh_hit,	temp_4;
	MUL_F		temp_4,	FL_SWIM,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	damage;
	DONE;
}

float(entity targ, entity inflictor, float dmg_amt) t_damage_ene = asm
{
local float crit;
local float mod;
local float shields;
local float dmgtype;
local float damage;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_F	targ,	sh_cur,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	dmg_amt;
	INDIRECT_F	inflictor,	p_dmgtype,	dmgtype;
	STORE_F	dmg_amt,	damage;
	INDIRECT_F	targ,	sh_cur,	shields;
	MUL_F		damage,	0.500000,	temp_1;
	ADD_F		damage,	temp_1,	damage;
	BITAND	dmgtype,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	17;
	STORE_F	0.250000,	crit;
	SUB_F		MOVETYPE_WALK,	skill,	temp_1;
	DIV_F		temp_1,	MOVETYPE_BOUNCE,	temp_1;
	ADD_F		crit,	temp_1,	crit;
	INDIRECT_F	targ,	vec_size,	temp_1;
	SUB_F		MOVETYPE_WALK,	temp_1,	temp_1;
	DIV_F		temp_1,	MOVETYPE_BOUNCE,	temp_1;
	ADD_F		crit,	temp_1,	crit;
	INDIRECT_F	targ,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	2;
	DIV_F		crit,	SHVEXP_EFFSTX_PERCENTAGE,	crit;
	CALL0		random;
	LE		return_x,	crit,	temp_1;
	IFNOT		temp_1,	2;
	MUL_F		damage,	SHVENE_EFFRAM_PERCENTAGE,	damage;
	BITAND	dmgtype,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	5;
	MUL_F		damage,	0.250000,	mod;
	SUB_F		shields,	mod,	shields;
	SUB_F		damage,	mod,	damage;
	GOTO		13;
	SUB_F		shields,	damage,	shields;
	LT		shields,	FALSE,	temp_1;
	IFNOT		temp_1,	9;
	BITAND	dmgtype,	FL_INWATER,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	shields,	mod;
	MUL_F		mod,	CONTENT_EMPTY,	damage;
	GOTO		2;
	STORE_F	FALSE,	damage;
	STORE_F	FALSE,	shields;
	GOTO		2;
	STORE_F	FALSE,	damage;
	ADDRESS	targ,	sh_cur,	temp_1;
	STOREP_F	shields,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	24;
	ADDRESS	targ,	sh_hit,	temp_1;
	DIV_F		dmg_amt,	STAT_PLR_ANG_X,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	targ,	sh_hit,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_3;
	INDIRECT_F	targ,	vec_size,	temp_4;
	SUB_F		MOVETYPE_STEP,	temp_4,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	targ,	sh_hit,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_3;
	SUB_F		MOVETYPE_WALK,	skill,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	EQ_F		shields,	FALSE,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	targ,	sh_hit,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_3;
	INDIRECT_F	targ,	sh_hit,	temp_4;
	MUL_F		temp_4,	FL_SWIM,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	BITAND	dmgtype,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	FALSE,	damage;
	RETURN	damage;
	DONE;
}

float(entity targ, entity inflictor, float dmg_amt) t_damage_mis = asm
{
local float quarter;
local float crit;
local float mod;
local float shields;
local float dmgtype;
local float damage;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_F	inflictor,	p_dmgtype,	dmgtype;
	STORE_F	dmg_amt,	damage;
	INDIRECT_F	targ,	sh_cur,	shields;
	MUL_F		shields,	0.250000,	quarter;
	INDIRECT_F	targ,	sh_cur,	temp_1;
	GT		temp_1,	quarter,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	FALSE,	damage;
	GOTO		30;
	INDIRECT_F	targ,	sh_cur,	temp_1;
	LE		temp_1,	quarter,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	targ,	sh_cur,	temp_3;
	GT		temp_3,	FALSE,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	targ,	sh_cur,	temp_1;
	INDIRECT_F	targ,	sh_max,	temp_3;
	DIV_F		temp_1,	temp_3,	mod;
	DIV_F		mod,	FL_SWIM,	mod;
	SUB_F		damage,	mod,	damage;
	GOTO		17;
	STORE_F	0.250000,	crit;
	SUB_F		MOVETYPE_WALK,	skill,	temp_1;
	DIV_F		temp_1,	MOVETYPE_BOUNCE,	temp_1;
	ADD_F		crit,	temp_1,	crit;
	INDIRECT_F	targ,	vec_size,	temp_1;
	SUB_F		MOVETYPE_WALK,	temp_1,	temp_1;
	DIV_F		temp_1,	MOVETYPE_BOUNCE,	temp_1;
	ADD_F		crit,	temp_1,	crit;
	INDIRECT_F	targ,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	2;
	DIV_F		crit,	SHVEXP_EFFSTX_PERCENTAGE,	crit;
	CALL0		random;
	LE		return_x,	crit,	temp_1;
	IFNOT		temp_1,	2;
	MUL_F		damage,	SHVEXP_EFFSTX_PERCENTAGE,	damage;
	ADDRESS	targ,	sh_cur,	temp_1;
	STOREP_F	shields,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	28;
	ADDRESS	targ,	sh_hit,	temp_1;
	DIV_F		dmg_amt,	STAT_PLR_ANG_X,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	targ,	sh_hit,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_3;
	INDIRECT_F	targ,	vec_size,	temp_4;
	SUB_F		MOVETYPE_STEP,	temp_4,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	targ,	sh_hit,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_3;
	SUB_F		MOVETYPE_WALK,	skill,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	targ,	sh_hit,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_3;
	DIV_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	EQ_F		shields,	FALSE,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	targ,	sh_hit,	temp_1;
	INDIRECT_F	targ,	sh_hit,	temp_3;
	INDIRECT_F	targ,	sh_hit,	temp_4;
	MUL_F		temp_4,	FL_SWIM,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	damage;
	DONE;
}

entity(entity trg, entity inflictor, entity attacker, float dmg_amt, float dmg_type, vector dmg_point, vector force) t_damage = asm
{
local entity friend;
local float irad;
local entity targ_act;
local entity oself;
local float new_dmg;
local vector temp_0;
local float temp_1;
local float temp_3;
	INDIRECT_F	trg,	takedamage,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	2;
	RETURN	trg;
	INDIRECT_F	trg,	flags,	temp_1;
	BITAND	temp_1,	FL_GODMODE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	trg;
	INDIRECT_F	trg,	i_faction,	temp_1;
	INDIRECT_F	attacker,	i_faction,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	DIV_F		dmg_amt,	FL_SWIM,	dmg_amt;
	INDIRECT_F	trg,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	9;
	ADDRESS	trg,	dmg_inflictor,	temp_1;
	STOREP_ENT	inflictor,	temp_1;
	INDIRECT_F	trg,	was_hit,	temp_1;
	LT		temp_1,	time,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	trg,	was_hit,	temp_1;
	ADD_F		time,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	trg,	parm0_x;
	STORE_V	dmg_point,	parm1;
	CALL2		util_chekPointToHitDir;
	INDIRECT_F	attacker,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	attacker,	w_proj,	temp_1;
	ADD_F		time,	ARM_HV_MOD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	attacker,	hitdir_buffer,	temp_1;
	BITAND	temp_1,	FL_INWATER,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	5;
	ADDRESS	attacker,	hitdir_buffer,	temp_1;
	INDIRECT_F	attacker,	hitdir_buffer,	temp_3;
	BITOR		temp_3,	FL_INWATER,	temp_3;
	STOREP_F	temp_3,	temp_1;
	BITAND	dmg_type,	TRUE,	temp_1;
	IFNOT		temp_1,	7;
	STORE_F	trg,	parm0_x;
	STORE_F	inflictor,	parm1_x;
	STORE_F	dmg_amt,	parm2_x;
	CALL3		t_damage_bal;
	STORE_F	return_x,	dmg_amt;
	GOTO		16;
	BITAND	dmg_type,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	7;
	STORE_F	trg,	parm0_x;
	STORE_F	inflictor,	parm1_x;
	STORE_F	dmg_amt,	parm2_x;
	CALL3		t_damage_ene;
	STORE_F	return_x,	dmg_amt;
	GOTO		8;
	BITAND	dmg_type,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	6;
	STORE_F	trg,	parm0_x;
	STORE_F	inflictor,	parm1_x;
	STORE_F	dmg_amt,	parm2_x;
	CALL3		t_damage_mis;
	STORE_F	return_x,	dmg_amt;
	STORE_F	"dmg_amt2",	parm0_x;
	STORE_F	dmg_amt,	parm1_x;
	CALL2		cons_logAFloat;
	INDIRECT_F	trg,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	trg,	parm0_x;
	STORE_F	attacker,	parm1_x;
	CALL2		ai_damage_react;
	GT		dmg_amt,	FALSE,	temp_1;
	IFNOT		temp_1,	8;
	STORE_F	trg,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	"sound/fx_armorhit.ogg",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	GOTO		8;
	INDIRECT_V	attacker,	origin_x,	temp_0;
	SUB_V		temp_0,	dmg_point,	parm0;
	CALL1		vectoangles;
	STORE_V	dmg_point,	parm0;
	STORE_V	return,	parm1;
	CALL2		te_shield_test;
	RETURN	trg;
	INDIRECT_F	trg,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	22;
	INDIRECT_F	trg,	origin_z,	temp_1;
	SUB_F		temp_1,	MOVETYPE_FLY,	temp_1;
	LT		dmg_point_z,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	trg,	e_legs,	trg;
	GOTO		16;
	INDIRECT_V	trg,	origin_x,	temp_0;
	SUB_V		dmg_point,	temp_0,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	irad;
	STORE_V	dmg_point,	parm0;
	STORE_F	irad,	parm1_x;
	STORE_F	trg,	parm2_x;
	CALL3		t_find_part;
	STORE_ENT	return_x,	targ_act;
	NE_E		targ_act,	world,	temp_1;
	IFNOT		temp_1,	5;
	INDIRECT_F	targ_act,	deadflag,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	STORE_ENT	targ_act,	trg;
	INDIRECT_F	trg,	data_type,	temp_1;
	EQ_F		temp_1,	MOVETYPE_PUSH,	temp_1;
	IFNOT		temp_1,	11;
	INDIRECT_F	self,	radar_range,	parm0_x;
	CALL1		ai_find_friend;
	STORE_ENT	return_x,	friend;
	IFNOT		friend,	7;
	INDIRECT_F	attacker,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	STORE_F	friend,	parm0_x;
	STORE_F	attacker,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	CALL3		ai_give_target;
	ADDRESS	trg,	health,	temp_1;
	INDIRECT_F	trg,	health,	temp_3;
	SUB_F		temp_3,	dmg_amt,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	trg,	health,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_FU	trg,	th_die,	temp_1;
	IFNOT		temp_1,	18;
	INDIRECT_F	trg,	comp_id,	temp_1;
	EQ_F		temp_1,	MOVETYPE_FLY,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_E	trg,	owner,	temp_1;
	ADDRESS	temp_1,	m_fspeed,	temp_1;
	INDIRECT_E	trg,	owner,	temp_3;
	INDIRECT_F	temp_3,	m_fspeed,	temp_3;
	DIV_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	trg,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	GOTO		6;
	STORE_F	trg,	parm0_x;
	STORE_F	attacker,	parm1_x;
	STORE_F	dmg_type,	parm2_x;
	CALL3		killed;
	RETURN	trg;
	RETURN	trg;
	DONE;
}

entity(vector point, float rad, entity trg) t_find_part = asm
{
local float diff;
local entity toSender;
local entity f_wep;
local entity cprt;
local float cur_dist;
local vector temp_0;
local float temp_1;
	STORE_F	rad,	cur_dist;
	STORE_ENT	trg,	cprt;
	STORE_ENT	trg,	f_wep;
	IFNOT		cprt,	16;
	NE_E		cprt,	trg,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_V	cprt,	origin_x,	temp_0;
	SUB_V		point,	temp_0,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	diff;
	INDIRECT_F	cprt,	deadflag,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	LT		diff,	cur_dist,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	diff,	cur_dist;
	STORE_ENT	cprt,	toSender;
	INDIRECT_E	cprt,	c_part,	cprt;
	GOTO		-15;
	RETURN	toSender;
	DONE;
}

entity(entity parent, vector org, float start_rad) closestWeapon = asm
{
local float diff;
local entity toSender;
local entity wep;
local float cur_dist;
local vector temp_0;
local float temp_1;
	STORE_F	start_rad,	cur_dist;
	STORE_ENT	parent,	wep;
	IFNOT		wep,	16;
	INDIRECT_V	wep,	origin_x,	temp_0;
	SUB_V		temp_0,	org,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	diff;
	NE_E		wep,	parent,	temp_1;
	IFNOT		temp_1,	8;
	INDIRECT_F	wep,	deadflag,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	LT		diff,	cur_dist,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	diff,	cur_dist;
	STORE_ENT	wep,	toSender;
	INDIRECT_E	wep,	w_slot,	wep;
	GOTO		-15;
	EQ_E		wep,	world,	temp_1;
	IFNOT		temp_1,	2;
	STORE_ENT	parent,	wep;
	RETURN	toSender;
	DONE;
}

void(entity targ, entity attacker, float dmg_type) killed = asm
{
local entity wep;
local entity oself;
local float temp_1;
local float temp_3;
	STORE_ENT	self,	oself;
	STORE_ENT	targ,	self;
	INDIRECT_F	self,	health,	temp_1;
	LT		temp_1,	-99.000000,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	-99.000000,	temp_1;
	INDIRECT_F	self,	data_type,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	12;
	INDIRECT_F	self,	movetype,	temp_1;
	EQ_F		temp_1,	MOVETYPE_PUSH,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	self,	movetype,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	5;
	INDIRECT_FU	self,	th_die,	temp_1;
	CALL0		temp_1;
	STORE_ENT	oself,	self;
	RETURN	offset_0;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	self,	data_type,	temp_3;
	EQ_F		temp_3,	MOVETYPE_WALK,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	self,	data_type,	temp_3;
	EQ_F		temp_3,	MOVETYPE_PUSH,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	ladder_entity,	temp_1;
	STOREP_ENT	attacker,	temp_1;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	attacker,	temp_1;
	ADDRESS	self,	takedamage,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	ADDRESS	self,	doobits,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_S	self,	classname,	temp_1;
	EQ_S		temp_1,	MECH_PIECE,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	comp_id,	temp_3;
	NE_F		temp_3,	CONTENT_EMPTY,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	19;
	INDIRECT_E	self,	owner,	wep;
	IFNOT		wep,	14;
	INDIRECT_E	wep,	w_slot,	wep;
	INDIRECT_F	wep,	c_parent,	temp_1;
	INDIRECT_F	self,	comp_id,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	8;
	INDIRECT_F	wep,	deadflag,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	STORE_F	wep,	parm0_x;
	STORE_F	attacker,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		killed;
	GOTO		-13;
	INDIRECT_FU	self,	th_die,	temp_1;
	CALL0		temp_1;
	GOTO		3;
	INDIRECT_FU	self,	th_die,	temp_1;
	CALL0		temp_1;
	STORE_ENT	oself,	self;
	DONE;
}

void () T_MissileTouch;
void() T_MissileTouch = asm
{
	DONE;
}

void () info_player_start;
float(entity targ, entity inflictor) CanDamage = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
local vector temp_5;
	INDIRECT_F	targ,	movetype,	temp_1;
	EQ_F		temp_1,	MOVETYPE_PUSH,	temp_1;
	IFNOT		temp_1,	18;
	INDIRECT_V	inflictor,	origin_x,	temp_0;
	INDIRECT_V	targ,	absmin_x,	temp_2;
	INDIRECT_V	targ,	absmax_x,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	MUL_FV	0.500000,	temp_2,	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	EQ_F		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	EQ_E		trace_ent,	targ,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	RETURN	FALSE;
	INDIRECT_V	inflictor,	origin_x,	temp_0;
	INDIRECT_V	targ,	origin_x,	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	EQ_F		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	INDIRECT_V	inflictor,	origin_x,	temp_0;
	INDIRECT_V	targ,	origin_x,	temp_2;
	ADD_V		temp_2,	'15.000000 15.000000 0.000000',	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	EQ_F		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	INDIRECT_V	inflictor,	origin_x,	temp_0;
	INDIRECT_V	targ,	origin_x,	temp_2;
	ADD_V		temp_2,	'-15.000000 -15.000000 0.000000',	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	EQ_F		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	INDIRECT_V	inflictor,	origin_x,	temp_0;
	INDIRECT_V	targ,	origin_x,	temp_2;
	ADD_V		temp_2,	'-15.000000 15.000000 0.000000',	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	EQ_F		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	INDIRECT_V	inflictor,	origin_x,	temp_0;
	INDIRECT_V	targ,	origin_x,	temp_2;
	ADD_V		temp_2,	'15.000000 -15.000000 0.000000',	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	EQ_F		trace_fraction,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	RETURN	FALSE;
	DONE;
}

void (entity, entity) Killed;
void(entity targ, entity attacker) Killed = asm
{
local entity oself;
local float temp_1;
local float temp_3;
	STORE_ENT	self,	oself;
	STORE_ENT	targ,	self;
	INDIRECT_F	self,	health,	temp_1;
	LT		temp_1,	-99.000000,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_F	self,	movetype,	temp_1;
	EQ_F		temp_1,	MOVETYPE_PUSH,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	self,	movetype,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	5;
	INDIRECT_FU	self,	th_die,	temp_1;
	CALL0		temp_1;
	STORE_ENT	oself,	self;
	RETURN	offset_0;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	attacker,	temp_1;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	5;
	ADD_F		killed_monsters,	TRUE,	killed_monsters;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	SVC_KILLEDMONSTER,	parm1_x;
	CALL2		WriteByte;
	ADDRESS	self,	takedamage,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	CALL0		monster_death_use;
	INDIRECT_FU	self,	th_die,	temp_1;
	CALL0		temp_1;
	STORE_ENT	oself,	self;
	DONE;
}

void(entity targ, entity inflictor, entity attacker, float damage) T_Damage = asm
{
local float take;
local float save;
local entity oldself;
local vector dir;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
local vector temp_5;
	INDIRECT_F	targ,	takedamage,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	2;
	RETURN	offset_0;
	STORE_ENT	attacker,	damage_attacker;
	INDIRECT_F	targ,	armortype,	temp_1;
	MUL_F		temp_1,	damage,	parm0_x;
	CALL1		ceil;
	STORE_F	return_x,	save;
	INDIRECT_F	targ,	armorvalue,	temp_1;
	GE		save,	temp_1,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_F	targ,	armorvalue,	save;
	ADDRESS	targ,	armortype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	targ,	items,	temp_1;
	INDIRECT_F	targ,	items,	temp_3;
	INDIRECT_F	targ,	items,	temp_4;
	BITAND	temp_4,	57344.000000,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	targ,	armorvalue,	temp_1;
	INDIRECT_F	targ,	armorvalue,	temp_3;
	SUB_F		temp_3,	save,	temp_3;
	STOREP_F	temp_3,	temp_1;
	SUB_F		damage,	save,	parm0_x;
	CALL1		ceil;
	STORE_F	return_x,	take;
	INDIRECT_F	targ,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	11;
	ADDRESS	targ,	dmg_take,	temp_1;
	INDIRECT_F	targ,	dmg_take,	temp_3;
	ADD_F		temp_3,	take,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	targ,	dmg_save,	temp_1;
	INDIRECT_F	targ,	dmg_save,	temp_3;
	ADD_F		temp_3,	save,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	targ,	dmg_inflictor,	temp_1;
	STOREP_ENT	inflictor,	temp_1;
	NE_E		inflictor,	world,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	targ,	movetype,	temp_3;
	EQ_F		temp_3,	MOVETYPE_WALK,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_V	targ,	origin_x,	temp_0;
	INDIRECT_V	inflictor,	absmin_x,	temp_2;
	INDIRECT_V	inflictor,	absmax_x,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	MUL_VF	temp_2,	0.500000,	temp_2;
	SUB_V		temp_0,	temp_2,	dir;
	STORE_V	dir,	parm0;
	CALL1		normalize;
	STORE_V	return,	dir;
	ADDRESS	targ,	velocity_x,	temp_0_x;
	INDIRECT_V	targ,	velocity_x,	temp_2;
	MUL_VF	dir,	damage,	temp_5;
	MUL_VF	temp_5,	FL_CLIENT,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	INDIRECT_F	targ,	flags,	temp_1;
	BITAND	temp_1,	FL_GODMODE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	EQ_F		teamplay,	TRUE,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	targ,	team,	temp_3;
	GT		temp_3,	FALSE,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_F	targ,	team,	temp_3;
	INDIRECT_F	attacker,	team,	temp_4;
	EQ_F		temp_3,	temp_4,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	NE_E		targ,	attacker,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_S	attacker,	classname,	temp_3;
	EQ_S		temp_3,	"player",	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_S	inflictor,	classname,	temp_3;
	NE_S		temp_3,	"door",	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	ADDRESS	targ,	health,	temp_1;
	INDIRECT_F	targ,	health,	temp_3;
	SUB_F		temp_3,	take,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	targ,	health,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	STORE_F	targ,	parm0_x;
	STORE_F	attacker,	parm1_x;
	CALL2		Killed;
	RETURN	offset_0;
	STORE_ENT	self,	oldself;
	STORE_ENT	targ,	self;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	2;
	NE_E		attacker,	world,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	24;
	NE_E		self,	attacker,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	self,	enemy,	temp_3;
	NE_E		attacker,	temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	18;
	INDIRECT_S	self,	classname,	temp_1;
	INDIRECT_S	attacker,	classname,	temp_3;
	NE_S		temp_1,	temp_3,	temp_1;
	IF		temp_1,	3;
	INDIRECT_S	self,	classname,	temp_3;
	EQ_S		temp_3,	"monster_army",	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_S	temp_1,	classname,	temp_1;
	EQ_S		temp_1,	"player",	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	oldenemy,	temp_1;
	INDIRECT_E	self,	enemy,	temp_3;
	STOREP_ENT	temp_3,	temp_1;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	attacker,	temp_1;
	INDIRECT_FU	self,	th_pain,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_FU	self,	th_pain,	temp_1;
	STORE_F	attacker,	parm0_x;
	STORE_F	take,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	STORE_F	"",	parm3_x;
	CALL4		temp_1;
	EQ_F		skill,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	pain_finished,	temp_1;
	ADD_F		time,	MOVETYPE_FLY,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_ENT	oldself,	self;
	DONE;
}

void (entity, entity, float, entity) T_RadiusDamage;
void(entity inflictor, entity attacker, float damage, entity ignore) T_RadiusDamage = asm
{
local vector org;
local entity head;
local float points;
local vector temp_0;
local float temp_1;
local vector temp_2;
local vector temp_5;
	INDIRECT_V	inflictor,	origin_x,	temp_0;
	ADD_F		damage,	STAT_PLR_ORG_X,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_1,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	head;
	IFNOT		head,	45;
	NE_E		head,	ignore,	temp_1;
	IFNOT		temp_1,	41;
	INDIRECT_F	head,	takedamage,	temp_1;
	IFNOT		temp_1,	39;
	INDIRECT_V	head,	origin_x,	temp_0;
	INDIRECT_V	head,	mins_x,	temp_2;
	INDIRECT_V	head,	maxs_x,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	MUL_VF	temp_2,	0.500000,	temp_2;
	ADD_V		temp_0,	temp_2,	org;
	INDIRECT_V	inflictor,	origin_x,	temp_0;
	SUB_V		temp_0,	org,	parm0;
	CALL1		vlen;
	MUL_F		0.500000,	return_x,	points;
	LT		points,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	FALSE,	points;
	SUB_F		damage,	points,	points;
	EQ_E		head,	attacker,	temp_1;
	IFNOT		temp_1,	2;
	MUL_F		points,	0.500000,	points;
	GT		points,	FALSE,	temp_1;
	IFNOT		temp_1,	20;
	STORE_F	head,	parm0_x;
	STORE_F	inflictor,	parm1_x;
	CALL2		CanDamage;
	IFNOT		return_x,	16;
	INDIRECT_S	head,	classname,	temp_1;
	EQ_S		temp_1,	"monster_shambler",	temp_1;
	IFNOT		temp_1,	8;
	MUL_F		points,	0.500000,	temp_1;
	STORE_F	head,	parm0_x;
	STORE_F	inflictor,	parm1_x;
	STORE_F	attacker,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	CALL4		T_Damage;
	GOTO		6;
	STORE_F	head,	parm0_x;
	STORE_F	inflictor,	parm1_x;
	STORE_F	attacker,	parm2_x;
	STORE_F	points,	parm3_x;
	CALL4		T_Damage;
	INDIRECT_E	head,	chain,	head;
	GOTO		-44;
	DONE;
}

void (entity, float) T_BeamDamage;
void(entity attacker, float damage) T_BeamDamage = asm
{
local entity head;
local float points;
local vector temp_0;
local float temp_1;
local vector temp_2;
	INDIRECT_V	attacker,	origin_x,	temp_0;
	ADD_F		damage,	STAT_PLR_ORG_X,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_1,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	head;
	IFNOT		head,	38;
	INDIRECT_F	head,	takedamage,	temp_1;
	IFNOT		temp_1,	34;
	INDIRECT_V	attacker,	origin_x,	temp_0;
	INDIRECT_V	head,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	MUL_F		0.500000,	return_x,	points;
	LT		points,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	FALSE,	points;
	SUB_F		damage,	points,	points;
	EQ_E		head,	attacker,	temp_1;
	IFNOT		temp_1,	2;
	MUL_F		points,	0.500000,	points;
	GT		points,	FALSE,	temp_1;
	IFNOT		temp_1,	20;
	STORE_F	head,	parm0_x;
	STORE_F	attacker,	parm1_x;
	CALL2		CanDamage;
	IFNOT		return_x,	16;
	INDIRECT_S	head,	classname,	temp_1;
	EQ_S		temp_1,	"monster_shambler",	temp_1;
	IFNOT		temp_1,	8;
	MUL_F		points,	0.500000,	temp_1;
	STORE_F	head,	parm0_x;
	STORE_F	attacker,	parm1_x;
	STORE_F	attacker,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	CALL4		T_Damage;
	GOTO		6;
	STORE_F	head,	parm0_x;
	STORE_F	attacker,	parm1_x;
	STORE_F	attacker,	parm2_x;
	STORE_F	points,	parm3_x;
	CALL4		T_Damage;
	INDIRECT_E	head,	chain,	head;
	GOTO		-37;
	DONE;
}

void() SetChangeParms = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_F	self,	health,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	CALL0		SetNewParms;
	RETURN	offset_0;
	ADDRESS	self,	items,	temp_1;
	INDIRECT_F	self,	items,	temp_3;
	INDIRECT_F	self,	items,	temp_4;
	BITAND	temp_4,	8257536.000000,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	health,	temp_1;
	GT		temp_1,	STAT_PLR_ANG_X,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	INDIRECT_F	self,	health,	temp_1;
	LT		temp_1,	TE_BLOOD,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	TE_BLOOD,	temp_1;
	INDIRECT_F	self,	i_reserve,	parm1;
	INDIRECT_F	self,	health,	parm2;
	INDIRECT_F	self,	i_faction,	parm3;
	INDIRECT_F	self,	ammo_shells,	temp_1;
	LT		temp_1,	IMP_SHOWOBJ,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	IMP_SHOWOBJ,	parm4;
	GOTO		2;
	STORE_F	FALSE,	parm4;
	STORE_F	FALSE,	parm5;
	STORE_F	FALSE,	parm6;
	STORE_F	FALSE,	parm7;
	STORE_F	FALSE,	parm8;
	STORE_F	FALSE,	parm9;
	DONE;
}

void() SetNewParms = asm
{
	STORE_F	FALSE,	parm1;
	STORE_F	FALSE,	parm2;
	STORE_F	FALSE,	parm3;
	STORE_F	FALSE,	parm4;
	STORE_F	FALSE,	parm5;
	STORE_F	FALSE,	parm6;
	STORE_F	FALSE,	parm7;
	STORE_F	FALSE,	parm8;
	STORE_F	FALSE,	parm9;
	DONE;
}

void() DecodeLevelParms = asm
{
local float temp_1;
	NE_F		deathmatch,	FALSE,	temp_1;
	IF		temp_1,	5;
	INDIRECT_S	world,	model,	temp_1;
	EQ_S		temp_1,	"maps/start.bsp",	temp_1;
	IFNOT		temp_1,	2;
	CALL0		SetNewParms;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	DONE;
}

entity() FindIntermission = asm
{
local float cyc;
local entity spot;
local float temp_1;
	STORE_F	world,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"info_intermission",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	spot;
	IFNOT		spot,	19;
	CALL0		random;
	MUL_F		return_x,	MOVETYPE_STEP,	cyc;
	GT		cyc,	TRUE,	temp_1;
	IFNOT		temp_1,	14;
	STORE_F	spot,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"info_intermission",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	spot;
	IF		spot,	6;
	STORE_F	spot,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"info_intermission",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	spot;
	SUB_F		cyc,	TRUE,	cyc;
	GOTO		-14;
	RETURN	spot;
	STORE_F	world,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"info_player_start",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	spot;
	IFNOT		spot,	2;
	RETURN	spot;
	STORE_F	world,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"testplayerstart",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	spot;
	IFNOT		spot,	2;
	RETURN	spot;
	STORE_F	"FindIntermission: no spot",	parm0_x;
	CALL1		objerror;
	RETURN	world;
	DONE;
}

void() GotoNextMap = asm
{
local float temp_1;
	STORE_F	"gamemode",	parm0_x;
	CALL1		cvar;
	EQ_F		return_x,	TRUE,	temp_1;
	IFNOT		temp_1,	5;
	STORE_F	nextmap,	parm0_x;
	CALL1		savefile_changemap;
	CALL0		savefile_append;
	CALL0		savefile_save;
	STORE_F	"samelevel",	parm0_x;
	CALL1		cvar;
	IFNOT		return_x,	4;
	STORE_F	mapname,	parm0_x;
	CALL1		changelevel;
	GOTO		3;
	STORE_F	nextmap,	parm0_x;
	CALL1		changelevel;
	DONE;
}

void() ExitIntermission = asm
{
local float temp_1;
	IFNOT		deathmatch,	3;
	CALL0		GotoNextMap;
	RETURN	offset_0;
	ADD_F		time,	TRUE,	intermission_exittime;
	ADD_F		intermission_running,	TRUE,	intermission_running;
	EQ_F		intermission_running,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	92;
	INDIRECT_S	world,	model,	temp_1;
	EQ_S		temp_1,	"maps/e1m7.bsp",	temp_1;
	IFNOT		temp_1,	29;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	FL_MONSTER,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	CALL2		WriteByte;
	STORE_F	"registered",	parm0_x;
	CALL1		cvar;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	8;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	SVC_FINALE,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	"As the corpse of the monstrous entity
Chthon sinks back into the lava whence
it rose, you grip the Rune of Earth
Magic tightly. Now that you have
conquered the Dimension of the Doomed,
realm of Earth Magic, you are ready to
complete your task in the other three
haunted lands of Quake. Or are you? If
you don't register Quake, you'll never
know what awaits you in the Realm of
Black Magic, the Netherworld, and the
Elder World!",	parm1_x;
	CALL2		WriteString;
	GOTO		7;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	SVC_FINALE,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	"As the corpse of the monstrous entity
Chthon sinks back into the lava whence
it rose, you grip the Rune of Earth
Magic tightly. Now that you have
conquered the Dimension of the Doomed,
realm of Earth Magic, you are ready to
complete your task. A Rune of magic
power lies at the end of each haunted
land of Quake. Go forth, seek the
totality of the four Runes!",	parm1_x;
	CALL2		WriteString;
	RETURN	offset_0;
	GOTO		60;
	INDIRECT_S	world,	model,	temp_1;
	EQ_S		temp_1,	"maps/e2m6.bsp",	temp_1;
	IFNOT		temp_1,	18;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	FL_MONSTER,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	SVC_FINALE,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	"The Rune of Black Magic throbs evilly in
your hand and whispers dark thoughts
into your brain. You learn the inmost
lore of the Hell-Mother; Shub-Niggurath!
You now know that she is behind all the
terrible plotting which has led to so
much death and horror. But she is not
inviolate! Armed with this Rune, you
realize that once all four Runes are
combined, the gate to Shub-Niggurath's
Pit will open, and you can face the
Witch-Goddess herself in her frightful
otherworld cathedral.",	parm1_x;
	CALL2		WriteString;
	RETURN	offset_0;
	GOTO		40;
	INDIRECT_S	world,	model,	temp_1;
	EQ_S		temp_1,	"maps/e3m6.bsp",	temp_1;
	IFNOT		temp_1,	18;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	FL_MONSTER,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	SVC_FINALE,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	"The charred viscera of diabolic horrors
bubble viscously as you seize the Rune
of Hell Magic. Its heat scorches your
hand, and its terrible secrets blight
your mind. Gathering the shreds of your
courage, you shake the devil's shackles
from your soul, and become ever more
hard and determined to destroy the
hideous creatures whose mere existence
threatens the souls and psyches of all
the population of Earth.",	parm1_x;
	CALL2		WriteString;
	RETURN	offset_0;
	GOTO		20;
	INDIRECT_S	world,	model,	temp_1;
	EQ_S		temp_1,	"maps/e4m7.bsp",	temp_1;
	IFNOT		temp_1,	17;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	FL_MONSTER,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	SVC_FINALE,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	"Despite the awful might of the Elder
World, you have achieved the Rune of
Elder Magic, capstone of all types of
arcane wisdom. Beyond good and evil,
beyond life and death, the Rune
pulsates, heavy with import. Patient and
potent, the Elder Being Shub-Niggurath
weaves her dire plans to clear off all
life from the Earth, and bring her own
foul offspring to our world! For all the
dwellers in these nightmare dimensions
are her descendants! Once all Runes of
magic power are united, the energy
behind them will blast open the Gateway
to Shub-Niggurath, and you can travel
there to foil the Hell-Mother's plots
in person.",	parm1_x;
	CALL2		WriteString;
	RETURN	offset_0;
	CALL0		GotoNextMap;
	EQ_F		intermission_running,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	19;
	STORE_F	"registered",	parm0_x;
	CALL1		cvar;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	5;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	SVC_SELLSCREEN,	parm1_x;
	CALL2		WriteByte;
	RETURN	offset_0;
	BITAND	serverflags,	IMP_SWEAPON3,	temp_1;
	EQ_F		temp_1,	IMP_SWEAPON3,	temp_1;
	IFNOT		temp_1,	8;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	SVC_FINALE,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	"Now, you have all four Runes. You sense
tremendous invisible forces moving to
unseal ancient barriers. Shub-Niggurath
had hoped to use the Runes Herself to
clear off the Earth, but now instead,
you will use them to enter her home and
confront her as an avatar of avenging
Earth-life. If you defeat her, you will
be remembered forever as the savior of
the planet. If she conquers, it will be
as if you had never been born.",	parm1_x;
	CALL2		WriteString;
	RETURN	offset_0;
	CALL0		GotoNextMap;
	DONE;
}

void() IntermissionThink = asm
{
local float temp_1;
local float temp_3;
	LT		time,	intermission_exittime,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	button0,	temp_1;
	NOT_F		temp_1,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	button1,	temp_3;
	NOT_F		temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	button2,	temp_3;
	NOT_F		temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	CALL0		ExitIntermission;
	DONE;
}

void() execute_changelevel = asm
{
local entity this;
local entity pos;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local vector temp_5;
	STORE_F	TRUE,	intermission_running;
	IFNOT		deathmatch,	3;
	ADD_F		time,	MOVETYPE_FLY,	intermission_exittime;
	GOTO		2;
	ADD_F		time,	FL_SWIM,	intermission_exittime;
	CALL0		FindIntermission;
	STORE_ENT	return_x,	pos;
	STORE_F	world,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"player",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	other;
	STORE_ENT	self,	this;
	NE_E		other,	world,	temp_1;
	IFNOT		temp_1,	37;
	INDIRECT_F	other,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	4;
	STORE_ENT	other,	self;
	CALL0		player_unmakeMech;
	STORE_ENT	this,	self;
	ADDRESS	other,	view_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	other,	angles_x,	temp_0_x;
	ADDRESS	other,	v_angle_x,	temp_2_x;
	INDIRECT_V	pos,	mangle_x,	temp_5;
	STOREP_V	temp_5_x,	temp_2;
	STOREP_V	temp_5_x,	temp_0;
	ADDRESS	other,	fixangle,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	other,	nextthink,	temp_1;
	ADD_F		time,	0.500000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	other,	takedamage,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	other,	solid,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	other,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	other,	modelindex,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_V	pos,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	STORE_F	other,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"player",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	other;
	GOTO		-37;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	SVC_INTERMISSION,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void() changelevel_touch = asm
{
local float locked_2932;
local entity pos;
local float temp_3;
local float temp_4;
	INDIRECT_S	other,	classname,	locked_2932;
	NE_S		locked_2932,	"player",	locked_2932;
	IFNOT		locked_2932,	2;
	RETURN	offset_0;
	STORE_F	"noexit",	parm0_x;
	CALL1		cvar;
	EQ_F		return_x,	TRUE,	locked_2932;
	IF		locked_2932,	7;
	STORE_F	"noexit",	parm0_x;
	CALL1		cvar;
	EQ_F		return_x,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	2;
	NE_S		mapname,	"start",	temp_4;
	AND		temp_3,	temp_4,	temp_3;
	OR		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	7;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	50000.000000,	parm3_x;
	CALL4		T_Damage;
	RETURN	offset_0;
	IF		coop,	1;
	OR		coop,	deathmatch,	locked_2932;
	IFNOT		locked_2932,	5;
	INDIRECT_S	other,	netname,	parm0_x;
	CALL1		bprint;
	STORE_F	" exited the level
",	parm0_x;
	CALL1		bprint;
	INDIRECT_S	self,	map,	nextmap;
	CALL0		SUB_UseTargets;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	2;
	EQ_F		deathmatch,	FALSE,	temp_3;
	AND		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	3;
	CALL0		GotoNextMap;
	RETURN	offset_0;
	ADDRESS	self,	touch,	locked_2932;
	STOREP_FNC	SUB_Null,	locked_2932;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	execute_changelevel,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	DONE;
}

void() changelevel_use = asm
{
local float locked_2932;
local float temp_3;
local float temp_4;
	STORE_F	"noexit",	parm0_x;
	CALL1		cvar;
	EQ_F		return_x,	TRUE,	locked_2932;
	IF		locked_2932,	7;
	STORE_F	"noexit",	parm0_x;
	CALL1		cvar;
	EQ_F		return_x,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	2;
	NE_S		mapname,	"start",	temp_4;
	AND		temp_3,	temp_4,	temp_3;
	OR		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	7;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	50000.000000,	parm3_x;
	CALL4		T_Damage;
	RETURN	offset_0;
	IF		coop,	1;
	OR		coop,	deathmatch,	locked_2932;
	IFNOT		locked_2932,	5;
	INDIRECT_S	other,	netname,	parm0_x;
	CALL1		bprint;
	STORE_F	" exited the level
",	parm0_x;
	CALL1		bprint;
	INDIRECT_S	self,	map,	nextmap;
	CALL0		SUB_UseTargets;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	2;
	EQ_F		deathmatch,	FALSE,	temp_3;
	AND		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	3;
	CALL0		GotoNextMap;
	RETURN	offset_0;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	execute_changelevel,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	INDIRECT_F	self,	delay,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	DONE;
}

void() server_make_sweep = asm
{
local float dist;
local float inv;
local entity blip;
local float high;
local float low;
local float yaw;
local float sweep;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_F	self,	data_type,	temp_1;
	NE_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	70;
	INDIRECT_F	self,	radar_time,	temp_1;
	INDIRECT_F	self,	radar_range,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	radar_time,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_F	self,	radar_range,	temp_1;
	MUL_F		temp_1,	ARM_LT_MOD,	inv;
	ADDRESS	self,	radar_time,	temp_1;
	INDIRECT_F	self,	radar_time,	temp_3;
	ADD_F		temp_3,	inv,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_F	self,	radar_range,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_1,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	blip;
	IFNOT		blip,	51;
	INDIRECT_F	blip,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	blip,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	42;
	NE_E		blip,	self,	temp_1;
	IFNOT		temp_1,	40;
	INDIRECT_F	blip,	deadflag,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	37;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	blip,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	dist;
	INDIRECT_F	self,	radar_time,	temp_1;
	DIV_F		inv,	FL_SWIM,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	LE		dist,	temp_1,	temp_1;
	IFNOT		temp_1,	5;
	INDIRECT_F	self,	radar_time,	temp_3;
	DIV_F		inv,	FL_SWIM,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	GE		dist,	temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	21;
	INDIRECT_F	self,	stat_rdr_mode,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	16;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	blip,	origin_x,	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	EQ_E		trace_ent,	blip,	temp_1;
	IF		temp_1,	2;
	EQ_F		trace_fraction,	TRUE,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	blip,	parm0_x;
	CALL1		client_push_radar_ping;
	GOTO		3;
	STORE_F	blip,	parm0_x;
	CALL1		client_push_radar_ping;
	INDIRECT_E	blip,	chain,	blip;
	GOTO		-50;
	DONE;
}

void() server_getTarget = asm
{
local entity src;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local vector temp_5;
	INDIRECT_V	self,	v_angle_x,	parm0;
	CALL1		makevectors;
	STORE_ENT	self,	src;
	INDIRECT_E	self,	e_cam,	temp_1;
	NE_E		temp_1,	world,	temp_1;
	IFNOT		temp_1,	2;
	INDIRECT_E	self,	e_cam,	src;
	INDIRECT_V	src,	origin_x,	temp_0;
	INDIRECT_V	src,	origin_x,	temp_2;
	INDIRECT_F	self,	stat_rdr_rng,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	STORE_F	trace_ent,	parm0_x;
	CALL1		ai_valid_target;
	IFNOT		return_x,	26;
	INDIRECT_F	trace_ent,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	trace_ent,	flags,	temp_3;
	BITAND	temp_3,	FL_MONSTER,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	18;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	trace_ent,	temp_1;
	INDIRECT_F	self,	stat_rdr_mode,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	lock_timer,	temp_1;
	INDIRECT_F	self,	w_firetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		6;
	ADDRESS	self,	lock_timer,	temp_1;
	INDIRECT_F	self,	w_firetime,	temp_3;
	MUL_F		temp_3,	SHVENE_EFFRAM_PERCENTAGE,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnTarget,	parm1_x;
	CALL2		trigger_event;
	GOTO		5;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	world,	temp_1;
	ADDRESS	self,	lock_timer,	temp_1;
	STOREP_F	FALSE,	temp_1;
	DONE;
}

void() server_updateTargetInfo = asm
{
local float locked_2932;
local float dst;
local float isvis;
local vector temp_0;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		ai_valid_target;
	NOT_F		return_x,	locked_2932;
	IF		locked_2932,	4;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_F	temp_3,	health,	temp_3;
	LE		temp_3,	FALSE,	temp_3;
	OR		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	32;
	ADDRESS	self,	stat_trg_dataidx,	locked_2932;
	STOREP_F	CONTENT_EMPTY,	locked_2932;
	ADDRESS	self,	stat_trg_ddflg,	locked_2932;
	STOREP_F	CONTENT_EMPTY,	locked_2932;
	ADDRESS	self,	stat_trg_dist,	locked_2932;
	STOREP_F	CONTENT_EMPTY,	locked_2932;
	ADDRESS	self,	stat_trg_face,	locked_2932;
	STOREP_F	CONTENT_EMPTY,	locked_2932;
	ADDRESS	self,	stat_trg_faction,	locked_2932;
	STOREP_F	CONTENT_EMPTY,	locked_2932;
	ADDRESS	self,	stat_trg_ent_id,	locked_2932;
	STOREP_F	CONTENT_EMPTY,	locked_2932;
	INDIRECT_F	self,	stat_lck_stt,	locked_2932;
	BITAND	locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	7;
	ADDRESS	self,	stat_lck_stt,	locked_2932;
	INDIRECT_F	self,	stat_lck_stt,	temp_3;
	INDIRECT_F	self,	stat_lck_stt,	temp_4;
	BITAND	temp_4,	FL_SWIM,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	stat_lck_stt,	locked_2932;
	BITAND	locked_2932,	MOVETYPE_STEP,	locked_2932;
	IFNOT		locked_2932,	7;
	ADDRESS	self,	stat_lck_stt,	locked_2932;
	INDIRECT_F	self,	stat_lck_stt,	temp_3;
	INDIRECT_F	self,	stat_lck_stt,	temp_4;
	BITAND	temp_4,	MOVETYPE_STEP,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	RETURN	offset_0;
	ADDRESS	self,	stat_trg_ent_id,	locked_2932;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		num_for_edict;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	stat_trg_dataidx,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_F	temp_3,	data_idx,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	stat_trg_dat,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_F	temp_3,	data_type,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	stat_trg_faction,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_F	temp_3,	i_faction,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_V	locked_2932,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	dst;
	INDIRECT_F	self,	stat_rdr_rng,	locked_2932;
	GT		dst,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	4;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	world,	locked_2932;
	RETURN	offset_0;
	ADDRESS	self,	stat_trg_ddflg,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_F	temp_3,	deadflag,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	stat_trg_dist,	locked_2932;
	STOREP_F	dst,	locked_2932;
	ADDRESS	self,	stat_trg_face,	locked_2932;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		util_checkPointAngle;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_F	locked_2932,	i_faction,	locked_2932;
	INDIRECT_F	self,	i_faction,	temp_3;
	NE_F		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	81;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_V	locked_2932,	origin_x,	parm0;
	CALL1		util_lockOnChoke;
	IFNOT		return_x,	46;
	INDIRECT_F	self,	stat_lck_stt,	locked_2932;
	BITAND	locked_2932,	FL_SWIM,	locked_2932;
	NOT_F		locked_2932,	locked_2932;
	IFNOT		locked_2932,	4;
	INDIRECT_F	self,	stat_lck_stt,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	NOT_F		temp_3,	temp_3;
	AND		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	19;
	ADDRESS	self,	stat_lck_stt,	locked_2932;
	INDIRECT_F	self,	stat_lck_stt,	temp_3;
	BITOR		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	power_timer_segment,	locked_2932;
	STOREP_F	time,	locked_2932;
	INDIRECT_F	self,	stat_rdr_mode,	locked_2932;
	IFNOT		locked_2932,	6;
	ADDRESS	self,	lock_timer,	locked_2932;
	INDIRECT_F	self,	w_firetime,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	GOTO		6;
	ADDRESS	self,	lock_timer,	locked_2932;
	INDIRECT_F	self,	w_firetime,	temp_3;
	MUL_F		temp_3,	FL_SWIM,	temp_3;
	ADD_F		time,	temp_3,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	lock_timer,	locked_2932;
	GT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	15;
	INDIRECT_F	self,	stat_lck_stt,	locked_2932;
	BITAND	locked_2932,	MOVETYPE_STEP,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	11;
	ADDRESS	self,	stat_lck_stt,	locked_2932;
	INDIRECT_F	self,	stat_lck_stt,	temp_3;
	INDIRECT_F	self,	stat_lck_stt,	temp_4;
	BITAND	temp_4,	FL_SWIM,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	self,	stat_lck_stt,	locked_2932;
	INDIRECT_F	self,	stat_lck_stt,	temp_3;
	BITOR		temp_3,	MOVETYPE_STEP,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	GOTO		32;
	INDIRECT_F	self,	stat_lck_stt,	locked_2932;
	BITAND	locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	7;
	ADDRESS	self,	stat_lck_stt,	locked_2932;
	INDIRECT_F	self,	stat_lck_stt,	temp_3;
	INDIRECT_F	self,	stat_lck_stt,	temp_4;
	BITAND	temp_4,	FL_SWIM,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	stat_lck_stt,	locked_2932;
	BITAND	locked_2932,	MOVETYPE_STEP,	locked_2932;
	IFNOT		locked_2932,	7;
	ADDRESS	self,	stat_lck_stt,	locked_2932;
	INDIRECT_F	self,	stat_lck_stt,	temp_3;
	INDIRECT_F	self,	stat_lck_stt,	temp_4;
	BITAND	temp_4,	MOVETYPE_STEP,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_E	self,	enemy,	locked_2932;
	INDIRECT_F	locked_2932,	stat_lck_stt,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	10;
	INDIRECT_E	self,	enemy,	locked_2932;
	ADDRESS	locked_2932,	stat_lck_stt,	locked_2932;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_F	temp_3,	stat_lck_stt,	temp_3;
	INDIRECT_E	self,	enemy,	temp_4;
	INDIRECT_F	temp_4,	stat_lck_stt,	temp_4;
	BITAND	temp_4,	FL_CLIENT,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	DONE;
}

void() savefile_append = asm
{
local float temp_1;
	INDIRECT_S	world,	inv_m_light,	temp_1;
	NE_S		temp_1,	"",	temp_1;
	IFNOT		temp_1,	11;
	NE_S		SAVE_MECHS_LIGHT,	"",	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_S	world,	inv_m_light,	parm0_x;
	STORE_F	SAVE_MECHS_LIGHT,	parm1_x;
	CALL2		savefile_insert;
	STORE_S	return_x,	SAVE_MECHS_LIGHT;
	GOTO		4;
	INDIRECT_S	world,	inv_m_light,	parm0_x;
	CALL1		strzone;
	STORE_S	return_x,	SAVE_MECHS_LIGHT;
	INDIRECT_S	world,	inv_m_medim,	temp_1;
	NE_S		temp_1,	"",	temp_1;
	IFNOT		temp_1,	11;
	NE_S		SAVE_MECHS_MEDIM,	"",	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_S	world,	inv_m_medim,	parm0_x;
	STORE_F	SAVE_MECHS_MEDIM,	parm1_x;
	CALL2		savefile_insert;
	STORE_S	return_x,	SAVE_MECHS_MEDIM;
	GOTO		4;
	INDIRECT_S	world,	inv_m_medim,	parm0_x;
	CALL1		strzone;
	STORE_S	return_x,	SAVE_MECHS_MEDIM;
	INDIRECT_S	world,	inv_m_heavy,	temp_1;
	NE_S		temp_1,	"",	temp_1;
	IFNOT		temp_1,	11;
	NE_S		SAVE_MECHS_HEAVY,	"",	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_S	world,	inv_m_heavy,	parm0_x;
	STORE_F	SAVE_MECHS_HEAVY,	parm1_x;
	CALL2		savefile_insert;
	STORE_S	return_x,	SAVE_MECHS_HEAVY;
	GOTO		4;
	INDIRECT_S	world,	inv_m_heavy,	parm0_x;
	CALL1		strzone;
	STORE_S	return_x,	SAVE_MECHS_HEAVY;
	INDIRECT_S	world,	inv_items,	temp_1;
	NE_S		temp_1,	"",	temp_1;
	IFNOT		temp_1,	11;
	NE_S		SAVE_ITEMS_ALL,	"",	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_S	world,	inv_items,	parm0_x;
	STORE_F	SAVE_ITEMS_ALL,	parm1_x;
	CALL2		savefile_insert;
	STORE_S	return_x,	SAVE_ITEMS_ALL;
	GOTO		4;
	INDIRECT_S	world,	inv_items,	parm0_x;
	CALL1		strzone;
	STORE_S	return_x,	SAVE_ITEMS_ALL;
	DONE;
}

void(string nextmap) savefile_changemap = asm
{
	STORE_S	nextmap,	SAVE_MAP;
	DONE;
}

string(string item, string source) savefile_insert = asm
{
local string chk;
local string toke;
local float itr;
local float tokens;
local float com;
local string line;
local string update;
local float temp_1;
local float temp_3;
	STORE_F	item,	parm0_x;
	STORE_F	" ",	parm1_x;
	CALL2		tokenizebyseparator;
	STORE_F	return_x,	tokens;
	STORE_S	"",	update;
	STORE_F	" ",	parm0_x;
	STORE_F	source,	parm1_x;
	CALL2		strcat;
	STORE_S	return_x,	line;
	STORE_F	FALSE,	itr;
	LE		itr,	tokens,	temp_1;
	IFNOT		temp_1,	32;
	STORE_F	itr,	parm0_x;
	CALL1		argv;
	STORE_S	return_x,	toke;
	NE_S		toke,	"",	temp_1;
	IFNOT		temp_1,	2;
	NE_S		toke,	" ",	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	22;
	STORE_F	" ",	parm0_x;
	STORE_F	toke,	parm1_x;
	CALL2		strcat;
	STORE_S	return_x,	chk;
	STORE_F	line,	parm0_x;
	STORE_F	chk,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		strstrofs;
	EQ_F		return_x,	CONTENT_EMPTY,	temp_1;
	IFNOT		temp_1,	12;
	EQ_F		itr,	FALSE,	temp_1;
	IFNOT		temp_1,	6;
	STORE_F	update,	parm0_x;
	STORE_F	toke,	parm1_x;
	CALL2		strcat;
	STORE_S	return_x,	update;
	GOTO		5;
	STORE_F	update,	parm0_x;
	STORE_F	chk,	parm1_x;
	CALL2		strcat;
	STORE_S	return_x,	update;
	ADD_F		itr,	TRUE,	itr;
	GOTO		-32;
	NE_S		update,	"",	temp_1;
	IFNOT		temp_1,	10;
	STORE_F	source,	parm0_x;
	STORE_F	" ",	parm1_x;
	STORE_F	update,	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	update;
	STORE_F	update,	parm0_x;
	CALL1		strzone;
	RETURN	return_x;
	GOTO		4;
	STORE_F	source,	parm0_x;
	CALL1		strzone;
	RETURN	return_x;
	DONE;
}

void() savefile_load = asm
{
local float locked_2932;
local string line;
local string contents;
local string file;
local float line_cntr;
local float line_array;
local float line_val;
local float line_tag;
local float argc;
local float flannel;
local float temp_3;
	STORE_F	"saveslot",	parm0_x;
	CALL1		cvar_string;
	STORE_F	PATH_DATA_SAVE,	parm0_x;
	STORE_F	"/",	parm1_x;
	STORE_F	SAVE_FILE_NAME,	parm2_x;
	STORE_F	return_x,	parm3_x;
	STORE_F	SAVE_FILE_EXT,	parm4_x;
	CALL5		strcat;
	STORE_S	return_x,	file;
	STORE_F	file,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	CALL2		fopen;
	STORE_F	return_x,	flannel;
	STORE_F	flannel,	parm0_x;
	CALL1		fgets;
	STORE_S	return_x,	contents;
	STORE_F	contents,	parm0_x;
	STORE_F	"{",	parm1_x;
	STORE_F	",",	parm2_x;
	STORE_F	"}",	parm3_x;
	CALL4		tokenizebyseparator;
	STORE_F	return_x,	argc;
	STORE_F	flannel,	parm0_x;
	CALL1		fgets;
	STORE_S	return_x,	line;
	NE_S		line,	"",	locked_2932;
	IFNOT		locked_2932,	69;
	NE_S		line,	"{",	locked_2932;
	IFNOT		locked_2932,	2;
	NE_S		line,	"}",	temp_3;
	AND		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	6;
	STORE_F	line,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FL_SWIM,	parm2_x;
	CALL3		substring;
	NE_S		return_x,	"//",	temp_3;
	AND		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	53;
	STORE_F	line,	parm0_x;
	STORE_F	"'",	parm1_x;
	STORE_F	"'",	parm2_x;
	STORE_F	": ",	parm3_x;
	STORE_F	",",	parm4_x;
	CALL5		tokenizebyseparator;
	STORE_F	return_x,	line_tag;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MSN_NAME,	locked_2932;
	IFNOT		locked_2932,	6;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		strzone;
	STORE_S	return_x,	SAVE_MAP;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MECHS_LIGHT,	locked_2932;
	IFNOT		locked_2932,	6;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		strzone;
	STORE_S	return_x,	SAVE_MECHS_LIGHT;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MECHS_MEDIUM,	locked_2932;
	IFNOT		locked_2932,	6;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		strzone;
	STORE_S	return_x,	SAVE_MECHS_MEDIM;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MECHS_HEAVY,	locked_2932;
	IFNOT		locked_2932,	6;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		strzone;
	STORE_S	return_x,	SAVE_MECHS_HEAVY;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_ITEMS,	locked_2932;
	IFNOT		locked_2932,	6;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		strzone;
	STORE_S	return_x,	SAVE_ITEMS_ALL;
	STORE_F	flannel,	parm0_x;
	CALL1		fgets;
	STORE_S	return_x,	line;
	GOTO		-69;
	STORE_F	flannel,	parm0_x;
	CALL1		fclose;
	DONE;
}

void() savefile_save = asm
{
local string line;
local string file;
local float flannel;
	STORE_F	"saveslot",	parm0_x;
	CALL1		cvar_string;
	STORE_F	PATH_DATA_SAVE,	parm0_x;
	STORE_F	"/",	parm1_x;
	STORE_F	SAVE_FILE_NAME,	parm2_x;
	STORE_F	return_x,	parm3_x;
	STORE_F	SAVE_FILE_EXT,	parm4_x;
	CALL5		strcat;
	STORE_S	return_x,	file;
	STORE_F	file,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	CALL2		fopen;
	STORE_F	return_x,	flannel;
	STORE_F	flannel,	parm0_x;
	STORE_F	"{
",	parm1_x;
	CALL2		fputs;
	STORE_F	"saveslot",	parm0_x;
	CALL1		cvar_string;
	STORE_F	"  'save' : ",	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	",
",	parm2_x;
	CALL3		strcat;
	STORE_F	flannel,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		fputs;
	STORE_F	"  'mission' : ",	parm0_x;
	STORE_F	SAVE_MAP,	parm1_x;
	STORE_F	",
",	parm2_x;
	CALL3		strcat;
	STORE_F	flannel,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		fputs;
	STORE_F	"  'light' : ",	parm0_x;
	STORE_F	SAVE_MECHS_LIGHT,	parm1_x;
	STORE_F	",
",	parm2_x;
	CALL3		strcat;
	STORE_F	flannel,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		fputs;
	STORE_F	"  'medium' : ",	parm0_x;
	STORE_F	SAVE_MECHS_MEDIM,	parm1_x;
	STORE_F	",
",	parm2_x;
	CALL3		strcat;
	STORE_F	flannel,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		fputs;
	STORE_F	"  'heavy' : ",	parm0_x;
	STORE_F	SAVE_MECHS_HEAVY,	parm1_x;
	STORE_F	",
",	parm2_x;
	CALL3		strcat;
	STORE_F	flannel,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		fputs;
	STORE_F	"  'items' : ",	parm0_x;
	STORE_F	SAVE_ITEMS_ALL,	parm1_x;
	STORE_F	",
",	parm2_x;
	CALL3		strcat;
	STORE_F	flannel,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		fputs;
	STORE_F	TRUE,	parm0_x;
	CALL1		ftos;
	STORE_F	"  'points' : ",	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	",
",	parm2_x;
	CALL3		strcat;
	STORE_F	flannel,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		fputs;
	STORE_F	flannel,	parm0_x;
	STORE_F	"}",	parm1_x;
	CALL2		fputs;
	STORE_F	flannel,	parm0_x;
	CALL1		fclose;
	DONE;
}

void() savefile_default = asm
{
local string line;
local string file;
local float flannel;
	STORE_F	"saveslot",	parm0_x;
	CALL1		cvar_string;
	STORE_F	PATH_DATA_SAVE,	parm0_x;
	STORE_F	"/",	parm1_x;
	STORE_F	SAVE_FILE_NAME,	parm2_x;
	STORE_F	return_x,	parm3_x;
	STORE_F	SAVE_FILE_EXT,	parm4_x;
	CALL5		strcat;
	STORE_S	return_x,	file;
	STORE_F	file,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	CALL2		fopen;
	STORE_F	return_x,	flannel;
	STORE_F	flannel,	parm0_x;
	STORE_F	"{
",	parm1_x;
	CALL2		fputs;
	STORE_F	"saveslot",	parm0_x;
	CALL1		cvar_string;
	STORE_F	"  'save' : ",	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	",
",	parm2_x;
	CALL3		strcat;
	STORE_F	flannel,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		fputs;
	STORE_F	flannel,	parm0_x;
	STORE_F	"  'mission' : start,
",	parm1_x;
	CALL2		fputs;
	STORE_F	flannel,	parm0_x;
	STORE_F	"  'light' : 1,
",	parm1_x;
	CALL2		fputs;
	STORE_F	flannel,	parm0_x;
	STORE_F	"  'medium' : 2,
",	parm1_x;
	CALL2		fputs;
	STORE_F	flannel,	parm0_x;
	STORE_F	"  'heavy' : 3,
",	parm1_x;
	CALL2		fputs;
	STORE_F	flannel,	parm0_x;
	STORE_F	"  'items' : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25,
",	parm1_x;
	CALL2		fputs;
	STORE_F	flannel,	parm0_x;
	STORE_F	"  'points' : ,
",	parm1_x;
	CALL2		fputs;
	STORE_F	flannel,	parm0_x;
	STORE_F	"}",	parm1_x;
	CALL2		fputs;
	STORE_F	flannel,	parm0_x;
	CALL1		fclose;
	DONE;
}

void() mapfile_coop_load = asm
{
local float locked_2932;
local float argc;
local float line_tag;
local float flannel;
local string contents;
local string line;
local string file;
local float temp_3;
	STORE_F	mapname,	parm0_x;
	STORE_F	".",	parm1_x;
	CALL2		tokenizebyseparator;
	STORE_F	FALSE,	parm0_x;
	CALL1		argv;
	STORE_S	return_x,	file;
	INDIRECT_S	world,	map_file,	locked_2932;
	STORE_F	PATH_DATA_MAP,	parm0_x;
	STORE_F	"/",	parm1_x;
	STORE_F	file,	parm2_x;
	STORE_F	"/",	parm3_x;
	STORE_F	locked_2932,	parm4_x;
	STORE_F	SAVE_FILE_EXT,	parm5_x;
	CALL6		strcat;
	STORE_S	return_x,	file;
	STORE_F	file,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	CALL2		fopen;
	STORE_F	return_x,	flannel;
	GT		flannel,	CONTENT_EMPTY,	locked_2932;
	IFNOT		locked_2932,	76;
	STORE_F	flannel,	parm0_x;
	CALL1		fgets;
	STORE_S	return_x,	contents;
	STORE_F	contents,	parm0_x;
	STORE_F	"{",	parm1_x;
	STORE_F	",",	parm2_x;
	STORE_F	"}",	parm3_x;
	CALL4		tokenizebyseparator;
	STORE_F	return_x,	argc;
	STORE_F	flannel,	parm0_x;
	CALL1		fgets;
	STORE_S	return_x,	line;
	NE_S		line,	"",	locked_2932;
	IFNOT		locked_2932,	60;
	NE_S		line,	"{",	locked_2932;
	IFNOT		locked_2932,	2;
	NE_S		line,	"}",	temp_3;
	AND		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	6;
	STORE_F	line,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FL_SWIM,	parm2_x;
	CALL3		substring;
	NE_S		return_x,	"//",	temp_3;
	AND		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	44;
	STORE_F	line,	parm0_x;
	STORE_F	"'",	parm1_x;
	STORE_F	"'",	parm2_x;
	STORE_F	": ",	parm3_x;
	STORE_F	",",	parm4_x;
	CALL5		tokenizebyseparator;
	STORE_F	return_x,	line_tag;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MSN_NAME,	locked_2932;
	IFNOT		locked_2932,	1;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MECHS_LIGHT,	locked_2932;
	IFNOT		locked_2932,	5;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		client_sendAvailableLightMechs;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MECHS_MEDIUM,	locked_2932;
	IFNOT		locked_2932,	5;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		client_sendAvailableMediumMechs;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MECHS_HEAVY,	locked_2932;
	IFNOT		locked_2932,	5;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		client_sendAvailableHeavyMechs;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_ITEMS,	locked_2932;
	IFNOT		locked_2932,	5;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		client_sendAvailableItems;
	STORE_F	flannel,	parm0_x;
	CALL1		fgets;
	STORE_S	return_x,	line;
	GOTO		-60;
	STORE_F	flannel,	parm0_x;
	CALL1		fclose;
	DONE;
}

void(float faction) mapfile_pvp_load = asm
{
local float locked_2932;
local float argc;
local float line_tag;
local float flannel;
local string contents;
local string line;
local string file;
local float temp_3;
	INDIRECT_S	world,	map_file,	locked_2932;
	STORE_F	faction,	parm0_x;
	CALL1		ftos;
	STORE_F	PATH_DATA_MAP,	parm0_x;
	STORE_F	"/",	parm1_x;
	STORE_F	mapname,	parm2_x;
	STORE_F	"/",	parm3_x;
	STORE_F	locked_2932,	parm4_x;
	STORE_F	"_",	parm5_x;
	STORE_F	return_x,	parm6_x;
	STORE_F	SAVE_FILE_EXT,	parm7_x;
	CALL8		strcat;
	STORE_S	return_x,	file;
	STORE_F	file,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	CALL2		fopen;
	STORE_F	return_x,	flannel;
	GT		flannel,	CONTENT_EMPTY,	locked_2932;
	IFNOT		locked_2932,	76;
	STORE_F	flannel,	parm0_x;
	CALL1		fgets;
	STORE_S	return_x,	contents;
	STORE_F	contents,	parm0_x;
	STORE_F	"{",	parm1_x;
	STORE_F	",",	parm2_x;
	STORE_F	"}",	parm3_x;
	CALL4		tokenizebyseparator;
	STORE_F	return_x,	argc;
	STORE_F	flannel,	parm0_x;
	CALL1		fgets;
	STORE_S	return_x,	line;
	NE_S		line,	"",	locked_2932;
	IFNOT		locked_2932,	60;
	NE_S		line,	"{",	locked_2932;
	IFNOT		locked_2932,	2;
	NE_S		line,	"}",	temp_3;
	AND		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	6;
	STORE_F	line,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FL_SWIM,	parm2_x;
	CALL3		substring;
	NE_S		return_x,	"//",	temp_3;
	AND		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	44;
	STORE_F	line,	parm0_x;
	STORE_F	"'",	parm1_x;
	STORE_F	"'",	parm2_x;
	STORE_F	": ",	parm3_x;
	STORE_F	",",	parm4_x;
	CALL5		tokenizebyseparator;
	STORE_F	return_x,	line_tag;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MSN_NAME,	locked_2932;
	IFNOT		locked_2932,	1;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MECHS_LIGHT,	locked_2932;
	IFNOT		locked_2932,	5;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		client_sendAvailableLightMechs;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MECHS_MEDIUM,	locked_2932;
	IFNOT		locked_2932,	5;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		client_sendAvailableMediumMechs;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_MECHS_HEAVY,	locked_2932;
	IFNOT		locked_2932,	5;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		client_sendAvailableHeavyMechs;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	SAVE_FILE_ITEMS,	locked_2932;
	IFNOT		locked_2932,	5;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		client_sendAvailableItems;
	STORE_F	flannel,	parm0_x;
	CALL1		fgets;
	STORE_S	return_x,	line;
	GOTO		-60;
	STORE_F	flannel,	parm0_x;
	CALL1		fclose;
	DONE;
}

vector(vector angl, vector org, float zAdjust) util_dropToGround = asm
{
local vector spot;
local vector temp_0;
local float temp_1;
	STORE_V	angl,	parm0;
	CALL1		makevectors;
	MUL_VF	v_up,	-3000.000000,	temp_0;
	ADD_V		org,	temp_0,	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	STORE_V	trace_endpos,	spot;
	SUB_F		spot_z,	zAdjust,	spot_z;
	RETURN	spot_x;
	DONE;
}

float(float numOfSides) util_roll_dice = asm
{
local float roll;
local float temp_1;
	CALL0		crandom;
	ADD_F		TRUE,	return_x,	temp_1;
	MUL_F		temp_1,	numOfSides,	roll;
	STORE_F	roll,	parm0_x;
	CALL1		ceil;
	STORE_F	return_x,	roll;
	LT		roll,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	MUL_F		roll,	CONTENT_EMPTY,	roll;
	EQ_F		roll,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	roll;
	RETURN	roll;
	DONE;
}

float (entity, float) util_getPieceHpForAverage;
float(entity t, float max) util_getPieceHpForAverage = asm
{
local float temp_1;
	IFNOT		t,	6;
	IFNOT		max,	3;
	INDIRECT_F	t,	max_health,	temp_1;
	RETURN	temp_1;
	INDIRECT_F	t,	health,	temp_1;
	RETURN	temp_1;
	RETURN	FALSE;
	DONE;
}

float(entity t) util_getMechHpAverage = asm
{
local float cur;
local float total;
local float temp_1;
	NE_E		t,	world,	temp_1;
	IFNOT		temp_1,	45;
	INDIRECT_F	t,	max_health,	total;
	INDIRECT_E	t,	e_arm_l,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_getPieceHpForAverage;
	ADD_F		total,	return_x,	total;
	INDIRECT_E	t,	e_arm_r,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_getPieceHpForAverage;
	ADD_F		total,	return_x,	total;
	INDIRECT_E	t,	e_tor_l,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_getPieceHpForAverage;
	ADD_F		total,	return_x,	total;
	INDIRECT_E	t,	e_tor_r,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_getPieceHpForAverage;
	ADD_F		total,	return_x,	total;
	INDIRECT_E	t,	e_legs,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_getPieceHpForAverage;
	ADD_F		total,	return_x,	total;
	INDIRECT_F	t,	health,	cur;
	INDIRECT_E	t,	e_arm_l,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	CALL2		util_getPieceHpForAverage;
	ADD_F		cur,	return_x,	cur;
	INDIRECT_E	t,	e_arm_r,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	CALL2		util_getPieceHpForAverage;
	ADD_F		cur,	return_x,	cur;
	INDIRECT_E	t,	e_tor_l,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	CALL2		util_getPieceHpForAverage;
	ADD_F		cur,	return_x,	cur;
	INDIRECT_E	t,	e_tor_r,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	CALL2		util_getPieceHpForAverage;
	ADD_F		cur,	return_x,	cur;
	INDIRECT_E	t,	e_legs,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	CALL2		util_getPieceHpForAverage;
	ADD_F		cur,	return_x,	cur;
	DIV_F		cur,	total,	total;
	RETURN	total;
	RETURN	FALSE;
	DONE;
}

float(entity t) util_getMechHpTotal = asm
{
local float cur;
local float total;
local float temp_1;
local float temp_3;
	NE_E		t,	world,	temp_1;
	IFNOT		temp_1,	14;
	INDIRECT_F	t,	max_health,	temp_1;
	INDIRECT_E	t,	e_arm_l,	temp_3;
	INDIRECT_F	temp_3,	max_health,	temp_3;
	MUL_F		temp_3,	FL_SWIM,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	INDIRECT_E	t,	e_tor_l,	temp_3;
	INDIRECT_F	temp_3,	max_health,	temp_3;
	MUL_F		temp_3,	FL_SWIM,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	INDIRECT_E	t,	e_legs,	temp_3;
	INDIRECT_F	temp_3,	max_health,	temp_3;
	ADD_F		temp_1,	temp_3,	total;
	RETURN	total;
	RETURN	FALSE;
	DONE;
}

float(float yee, float targAng, float buffer) util_checkAngNotIdeal = asm
{
local float trg_high;
local float trg_low;
local float temp_1;
local float temp_3;
	SUB_F		targAng,	buffer,	parm0_x;
	CALL1		anglemod;
	STORE_F	return_x,	trg_low;
	ADD_F		targAng,	buffer,	parm0_x;
	CALL1		anglemod;
	STORE_F	return_x,	trg_high;
	LT		yee,	trg_low,	temp_1;
	IF		temp_1,	2;
	GT		yee,	trg_high,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	RETURN	FALSE;
	DONE;
}

vector(vector facing, vector centerpoint, vector sz_max) util_findOpenSpawnArea = asm
{
local float box;
local float dir;
local float side;
local float dist;
local vector destin;
local vector probe;
local vector locus;
local vector temp_0;
local float temp_1;
local vector temp_2;
	MUL_F		sz_max_x,	FL_SWIM,	box;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	CALL1		util_roll_dice;
	MUL_F		box,	return_x,	dist;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		util_roll_dice;
	STORE_F	return_x,	side;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		util_roll_dice;
	STORE_F	return_x,	dir;
	EQ_F		side,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	CONTENT_EMPTY,	side;
	EQ_F		dir,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	CONTENT_EMPTY,	dir;
	STORE_V	facing,	parm0;
	CALL1		makevectors;
	MUL_F		dir,	dist,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_0;
	ADD_V		centerpoint,	temp_0,	temp_0;
	MUL_F		side,	dist,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	locus;
	STORE_V	centerpoint,	parm0;
	STORE_V	locus,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	RETURN	trace_endpos_x;
	DONE;
}

vector(entity own, float range) util_traceForPlayer = asm
{
local vector vcr;
local entity cam;
local vector temp_0;
local float temp_1;
local vector temp_2;
	INDIRECT_E	own,	e_cam,	cam;
	INDIRECT_V	own,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	own,	origin_x,	temp_0;
	INDIRECT_F	cam,	c_ofs_x,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	cam,	c_ofs_y,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	cam,	c_ofs_z,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	vcr;
	MUL_VF	v_forward,	DAT_BLD_H_SM_RADAR_RADAR_RANGE,	temp_0;
	ADD_V		vcr,	temp_0,	temp_0;
	STORE_V	vcr,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	own,	parm3_x;
	CALL4		traceline;
	RETURN	trace_endpos_x;
	DONE;
}

vector(vector viewAngle, float idealRange, vector weaponSpread, float playerAcc) util_applySpreadToTrace = asm
{
local float locked_2939;
local vector acc;
local vector src;
local vector direction;
local vector wepAim;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_E	self,	owner,	parm0_x;
	STORE_F	100000.000000,	parm1_x;
	CALL2		aim;
	STORE_V	return,	wepAim;
	STORE_V	viewAngle,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	locked_2939;
	MUL_VF	v_forward,	MOVETYPE_STEP,	temp_2;
	ADD_V		locked_2939,	temp_2,	src;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	absmin_z,	temp_1;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	size_z,	temp_3;
	MUL_F		temp_3,	DAT_MNT_SHIELD_RATE,	temp_3;
	ADD_F		temp_1,	temp_3,	src_z;
	MUL_F		weaponSpread_x,	playerAcc,	acc_x;
	MUL_F		weaponSpread_y,	playerAcc,	acc_y;
	CALL0		crandom;
	MUL_F		acc_x,	return_x,	acc_x;
	CALL0		crandom;
	MUL_F		acc_y,	return_x,	acc_y;
	MUL_FV	acc_x,	v_right,	locked_2939;
	ADD_V		wepAim,	locked_2939,	locked_2939;
	CALL0		crandom;
	MUL_F		return_x,	acc_y,	temp_1;
	MUL_FV	temp_1,	v_up,	temp_2;
	ADD_V		locked_2939,	temp_2,	direction;
	MUL_VF	direction,	idealRange,	locked_2939;
	ADD_V		src,	locked_2939,	locked_2939;
	STORE_V	src,	parm0;
	STORE_V	locked_2939,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	RETURN	trace_endpos_x;
	DONE;
}

vector(vector start, vector offsets, vector viewAngle) util_getOffsetOfVector = asm
{
local vector v;
local vector temp_0;
local vector temp_2;
	STORE_V	viewAngle,	parm0;
	CALL1		makevectors;
	MUL_VF	v_forward,	offsets_z,	temp_0;
	ADD_V		start,	temp_0,	temp_0;
	MUL_VF	v_up,	offsets_y,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_right,	offsets_x,	temp_2;
	ADD_V		temp_0,	temp_2,	v;
	RETURN	v_x;
	DONE;
}

vector(vector startOrigin, vector viewAngle, float wepRange, entity parent) util_traceForAI = asm
{
local vector viewLine;
local vector temp_0;
	STORE_V	viewAngle,	parm0;
	CALL1		makevectors;
	MUL_VF	v_forward,	wepRange,	temp_0;
	ADD_V		startOrigin,	temp_0,	viewLine;
	STORE_V	startOrigin,	parm0;
	STORE_V	viewLine,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	parent,	parm3_x;
	CALL4		traceline;
	RETURN	trace_endpos_x;
	DONE;
}

float(entity trg) util_checkPointAngle = asm
{
local float toSender;
local vector temp_0;
	INDIRECT_V	trg,	origin_x,	parm0;
	CALL1		util_checkPointAngleImpl;
	STORE_F	return_x,	toSender;
	RETURN	toSender;
	DONE;
}

float(vector orig) util_checkPointAngleImpl = asm
{
local float s_dot;
local float f_dot;
local vector vec;
local vector temp_0;
local float temp_1;
local float temp_3;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		orig,	temp_0,	parm0;
	CALL1		normalize;
	STORE_V	return,	vec;
	MUL_V		vec,	v_forward,	f_dot;
	MUL_V		vec,	v_right,	s_dot;
	GT		f_dot,	DAT_LAS_RL_RATE,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	CONTENT_EMPTY;
	GOTO		13;
	LT		f_dot,	-0.900000,	temp_1;
	IFNOT		temp_1,	2;
	LE		s_dot,	0.100000,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	FL_SWIM;
	GOTO		6;
	GT		s_dot,	0.100000,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	TRUE;
	GOTO		2;
	RETURN	FALSE;
	DONE;
}

float(vector orig) util_lockOnChoke = asm
{
local vector vew;
local vector vec;
local vector temp_0;
local float temp_1;
local float temp_3;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		orig,	temp_0,	parm0;
	CALL1		normalize;
	STORE_V	return,	vec;
	MUL_V		vec,	v_forward,	vew_x;
	MUL_V		vec,	v_right,	vew_y;
	INDIRECT_V	self,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	SUB_V		orig,	temp_0,	parm0;
	CALL1		normalize;
	STORE_V	return,	vec;
	MUL_V		vec,	v_up,	vew_z;
	GT		vew_x,	0.900000,	temp_1;
	IFNOT		temp_1,	12;
	LT		vew_y,	AI_DMG_SKILL_VET,	temp_1;
	IFNOT		temp_1,	2;
	GT		vew_y,	-0.400000,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	7;
	LT		vew_z,	AI_DMG_SKILL_VET,	temp_1;
	IFNOT		temp_1,	2;
	GT		vew_z,	-0.400000,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	TRUE;
	RETURN	FALSE;
	DONE;
}

void(entity ent, vector pnt) util_chekPointToHitDir = asm
{
local float hit_ang;
local entity this;
local float temp_1;
local float temp_3;
	STORE_ENT	self,	this;
	STORE_ENT	ent,	self;
	STORE_V	pnt,	parm0;
	CALL1		util_checkPointAngleImpl;
	STORE_F	return_x,	hit_ang;
	EQ_F		hit_ang,	FALSE,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_F	self,	hitdir_buffer,	temp_1;
	BITAND	temp_1,	FL_SWIM,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	hitdir_buffer,	temp_1;
	INDIRECT_F	self,	hitdir_buffer,	temp_3;
	BITOR		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		30;
	EQ_F		hit_ang,	TRUE,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_F	self,	hitdir_buffer,	temp_1;
	BITAND	temp_1,	MOVETYPE_STEP,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	hitdir_buffer,	temp_1;
	INDIRECT_F	self,	hitdir_buffer,	temp_3;
	BITOR		temp_3,	MOVETYPE_STEP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		19;
	EQ_F		hit_ang,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	17;
	INDIRECT_F	self,	hitdir_buffer,	temp_1;
	BITAND	temp_1,	MOVETYPE_STEP,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	hitdir_buffer,	temp_1;
	INDIRECT_F	self,	hitdir_buffer,	temp_3;
	BITOR		temp_3,	MOVETYPE_STEP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	hitdir_buffer,	temp_1;
	BITAND	temp_1,	FL_SWIM,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	hitdir_buffer,	temp_1;
	INDIRECT_F	self,	hitdir_buffer,	temp_3;
	BITOR		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_ENT	this,	self;
	DONE;
}

void(entity targ, entity src, vector ofs) util_setOffsetOrigin = asm
{
local vector next;
local vector temp_0;
local vector temp_2;
	INDIRECT_V	src,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	src,	origin_x,	temp_0;
	MUL_VF	v_up,	ofs_y,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_right,	ofs_x,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	MUL_VF	v_forward,	ofs_z,	temp_2;
	ADD_V		temp_0,	temp_2,	next;
	STORE_F	targ,	parm0_x;
	STORE_V	next,	parm1;
	CALL2		setorigin;
	DONE;
}

void(string mdl_name, float skinNum, float ef_flags) util_setModel = asm
{
local float temp_1;
local float temp_3;
	ADDRESS	self,	effects,	temp_1;
	INDIRECT_F	self,	effects,	temp_3;
	BITOR		temp_3,	ef_flags,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	mdl_name,	parm1_x;
	CALL2		setmodel;
	ADDRESS	self,	skin,	temp_1;
	STOREP_F	skinNum,	temp_1;
	DONE;
}

void(float dmgMode, float solid_type, float move_type) util_setCollider = asm
{
local float temp_1;
	ADDRESS	self,	takedamage,	temp_1;
	STOREP_F	dmgMode,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	solid_type,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	move_type,	temp_1;
	DONE;
}

void(float hp, float max_hp, float arm_type, float arm_val) util_setHealthArmor = asm
{
local float temp_1;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	hp,	temp_1;
	ADDRESS	self,	max_health,	temp_1;
	STOREP_F	max_hp,	temp_1;
	ADDRESS	self,	armortype,	temp_1;
	STOREP_F	arm_type,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	STOREP_F	arm_val,	temp_1;
	ADDRESS	self,	max_armor,	temp_1;
	STOREP_F	arm_val,	temp_1;
	DONE;
}

float(entity t, float tolerance) util_cornerSlopeCheck = asm
{
local float val;
local vector c4;
local vector c3;
local vector c2;
local vector c1;
local vector start;
local vector temp_0;
local float temp_1;
local vector temp_2;
	STORE_F	FALSE,	val;
	INDIRECT_V	t,	origin_x,	temp_0;
	INDIRECT_F	self,	mins_z,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	start;
	INDIRECT_V	t,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_F	self,	maxs_x,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_0;
	ADD_V		start,	temp_0,	temp_0;
	INDIRECT_F	self,	maxs_y,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	c1;
	INDIRECT_F	self,	mins_x,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_0;
	ADD_V		start,	temp_0,	temp_0;
	INDIRECT_F	self,	maxs_y,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	c2;
	INDIRECT_F	self,	mins_x,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_0;
	ADD_V		start,	temp_0,	temp_0;
	INDIRECT_F	self,	mins_y,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	c3;
	INDIRECT_F	self,	maxs_x,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_0;
	ADD_V		start,	temp_0,	temp_0;
	INDIRECT_F	self,	mins_y,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	c4;
	MUL_VF	v_up,	-128.000000,	temp_0;
	ADD_V		c1,	temp_0,	temp_0;
	STORE_V	c1,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	t,	parm3_x;
	CALL4		traceline;
	LT		trace_plane_normal_z,	tolerance,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	val;
	MUL_VF	v_up,	-128.000000,	temp_0;
	ADD_V		c2,	temp_0,	temp_0;
	STORE_V	c2,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	t,	parm3_x;
	CALL4		traceline;
	LT		trace_plane_normal_z,	tolerance,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	val;
	MUL_VF	v_up,	-128.000000,	temp_0;
	ADD_V		c3,	temp_0,	temp_0;
	STORE_V	c3,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	t,	parm3_x;
	CALL4		traceline;
	LT		trace_plane_normal_z,	tolerance,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	val;
	MUL_VF	v_up,	-128.000000,	temp_0;
	ADD_V		c4,	temp_0,	temp_0;
	STORE_V	c4,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	t,	parm3_x;
	CALL4		traceline;
	LT		trace_plane_normal_z,	tolerance,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	val;
	RETURN	val;
	DONE;
}

void(entity t) util_generateBuildingFoundation = asm
{
local entity n;
local entity this;
local vector v;
local vector temp_0;
local float temp_1;
local vector temp_2;
	INDIRECT_V	t,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	t,	origin_x,	temp_0;
	INDIRECT_F	t,	mins_z,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	v;
	CALL0		spawn;
	STORE_ENT	return_x,	n;
	STORE_ENT	self,	this;
	STORE_ENT	n,	self;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"map_terrain",	temp_1;
	INDIRECT_F	t,	vec_size,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	6;
	STORE_F	"q3mdl/base_small.obj",	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	GOTO		16;
	INDIRECT_F	t,	vec_size,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	6;
	STORE_F	"q3mdl/base_med.obj",	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	GOTO		8;
	INDIRECT_F	t,	vec_size,	temp_1;
	EQ_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	5;
	STORE_F	"q3mdl/base_large.obj",	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	FALSE,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_2;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_2,	parm2;
	CALL3		setsize;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_V	t,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	v,	parm1;
	CALL2		setorigin;
	STORE_ENT	this,	self;
	DONE;
}

float(vector p, vector pmin, vector pmax) util_checkInBounds = asm
{
local vector ok;
local float temp_1;
local float temp_3;
	STORE_V	VEC_ORIGIN,	ok;
	SUB_F		pmin_x,	TRUE,	temp_1;
	GT		p_x,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADD_F		pmax_x,	TRUE,	temp_3;
	LT		p_x,	temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	ok_x;
	SUB_F		pmin_y,	TRUE,	temp_1;
	GT		p_y,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADD_F		pmax_y,	TRUE,	temp_3;
	LT		p_y,	temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	ok_y;
	SUB_F		pmin_z,	TRUE,	temp_1;
	GT		p_z,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADD_F		pmax_z,	TRUE,	temp_3;
	LT		p_z,	temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	TRUE,	ok_z;
	EQ_F		ok_x,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	EQ_F		ok_y,	TRUE,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	EQ_F		ok_z,	TRUE,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	RETURN	TRUE;
	GOTO		2;
	RETURN	FALSE;
	DONE;
}

void(float bits, float b, float bb, float bbb) util_subThreeBits = asm
{
local float temp_1;
	BITOR		b,	bb,	temp_1;
	BITOR		temp_1,	bbb,	temp_1;
	BITAND	bits,	temp_1,	temp_1;
	SUB_F		bits,	temp_1,	bits;
	DONE;
}

entity(float part, entity unit) util_getPartFromName = asm
{
local float temp_1;
	GOTO		18;
	INDIRECT_F	unit,	flags,	temp_1;
	BITAND	temp_1,	FL_TURRET,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	unit,	e_tor_c,	temp_1;
	RETURN	temp_1;
	RETURN	unit;
	INDIRECT_E	unit,	e_tor_r,	temp_1;
	RETURN	temp_1;
	INDIRECT_E	unit,	e_tor_l,	temp_1;
	RETURN	temp_1;
	INDIRECT_E	unit,	e_legs,	temp_1;
	RETURN	temp_1;
	INDIRECT_E	unit,	e_arm_l,	temp_1;
	RETURN	temp_1;
	INDIRECT_E	unit,	e_arm_r,	temp_1;
	RETURN	temp_1;
	RETURN	unit;
	EQ_F		part,	FL_SWIM,	temp_1;
	IF		temp_1,	-18;
	EQ_F		part,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-14;
	EQ_F		part,	MOVETYPE_STEP,	temp_1;
	IF		temp_1,	-14;
	EQ_F		part,	MOVETYPE_FLY,	temp_1;
	IF		temp_1,	-14;
	EQ_F		part,	FL_CLIENT,	temp_1;
	IF		temp_1,	-14;
	EQ_F		part,	MOVETYPE_FLYMISSILE,	temp_1;
	IF		temp_1,	-14;
	GOTO		-13;
	DONE;
}

float(float v) anglemod = asm
{
local float temp_1;
	GE		v,	360.000000,	temp_1;
	IFNOT		temp_1,	3;
	SUB_F		v,	360.000000,	v;
	GOTO		-3;
	LT		v,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADD_F		v,	360.000000,	v;
	GOTO		-3;
	RETURN	v;
	DONE;
}

void(string msg, float val) cons_logAFloat = asm
{
	STORE_F	val,	parm0_x;
	CALL1		ftos;
	STORE_F	msg,	parm0_x;
	STORE_F	":",	parm1_x;
	STORE_F	return_x,	parm2_x;
	STORE_F	" 
",	parm3_x;
	CALL4		strcat;
	STORE_F	return_x,	parm0_x;
	CALL1		bprint;
	DONE;
}

void(string msg, vector v1) cons_logAVector = asm
{
	STORE_V	v1,	parm0;
	CALL1		vtos;
	STORE_F	msg,	parm0_x;
	STORE_F	":",	parm1_x;
	STORE_F	return_x,	parm2_x;
	STORE_F	"
",	parm3_x;
	CALL4		strcat;
	STORE_F	return_x,	parm0_x;
	CALL1		bprint;
	DONE;
}

void(string msg, string s1) cons_logAString = asm
{
	STORE_F	msg,	parm0_x;
	STORE_F	":",	parm1_x;
	STORE_F	s1,	parm2_x;
	STORE_F	"
",	parm3_x;
	CALL4		strcat;
	STORE_F	return_x,	parm0_x;
	CALL1		bprint;
	DONE;
}

void(string msg, float val, string split, float val2) cons_log2Float = asm
{
local float locked_2932;
local float temp_3;
	STORE_F	val,	parm0_x;
	CALL1		ftos;
	STORE_F	val2,	parm0_x;
	STORE_F	return_x,	locked_2932;
	CALL1		ftos;
	STORE_F	return_x,	temp_3;
	STORE_F	locked_2932,	return_x;
	STORE_F	msg,	parm0_x;
	STORE_F	":",	parm1_x;
	STORE_F	return_x,	parm2_x;
	STORE_F	"| ",	parm3_x;
	STORE_F	split,	parm4_x;
	STORE_F	":",	parm5_x;
	STORE_F	temp_3,	parm6_x;
	STORE_F	"
",	parm7_x;
	CALL8		strcat;
	STORE_F	return_x,	parm0_x;
	CALL1		bprint;
	DONE;
}

void(string msg, vector v1, string split, vector v2) cons_log2Vectors = asm
{
local float locked_2932;
local float temp_3;
	STORE_V	v1,	parm0;
	CALL1		vtos;
	STORE_V	v2,	parm0;
	STORE_F	return_x,	locked_2932;
	CALL1		vtos;
	STORE_F	return_x,	temp_3;
	STORE_F	locked_2932,	return_x;
	STORE_F	msg,	parm0_x;
	STORE_F	":",	parm1_x;
	STORE_F	return_x,	parm2_x;
	STORE_F	"| ",	parm3_x;
	STORE_F	split,	parm4_x;
	STORE_F	":",	parm5_x;
	STORE_F	temp_3,	parm6_x;
	STORE_F	"
",	parm7_x;
	CALL8		strcat;
	STORE_F	return_x,	parm0_x;
	CALL1		bprint;
	DONE;
}

void(string msg, string s1, string split, string s2) cons_log2Strings = asm
{
	STORE_F	msg,	parm0_x;
	STORE_F	" : ",	parm1_x;
	STORE_F	s1,	parm2_x;
	STORE_F	" | ",	parm3_x;
	STORE_F	split,	parm4_x;
	STORE_F	" : ",	parm5_x;
	STORE_F	s2,	parm6_x;
	STORE_F	"
",	parm7_x;
	CALL8		strcat;
	STORE_F	return_x,	parm0_x;
	CALL1		bprint;
	DONE;
}

void () player_spawnAsObserver;
void() player_spawnAsObserver = asm
{
	DONE;
}

void() player_makeObserver = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	view_ofs_x,	temp_0_x;
	STOREP_V	'0.000000 0.000000 1.000000',	temp_0;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	STORE_F	TRUE,	parm2_x;
	STORE_F	FALSE,	parm3_x;
	CALL4		util_setHealthArmor;
	STORE_F	FALSE,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	STORE_F	MOVETYPE_FLY,	parm2_x;
	CALL3		util_setCollider;
	ADDRESS	self,	weaponmodel,	temp_1;
	STOREP_S	"",	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	STORE_V	'-4.000000 -4.000000 -4.000000',	parm1;
	STORE_V	'4.000000 4.000000 4.000000',	parm2;
	CALL3		setsize;
	ADDRESS	self,	scale,	temp_1;
	STOREP_F	DAT_PRJ_SFGA_GLOWSIZE,	temp_1;
	STORE_F	DAT_PRJ_QRFL_VELOCITY,	parm0_x;
	STORE_F	DAT_PRJ_QRFL_VELOCITY,	parm1_x;
	STORE_F	DAT_PRJ_QRFL_VELOCITY,	parm2_x;
	STORE_F	"3",	parm3_x;
	STORE_F	"0",	parm4_x;
	CALL5		client_update_moveSpeed;
	STORE_F	"0",	parm0_x;
	STORE_F	"0",	parm1_x;
	STORE_F	"0",	parm2_x;
	CALL3		client_update_viewBob;
	STORE_F	"0",	parm0_x;
	STORE_F	"0",	parm1_x;
	STORE_F	"0",	parm2_x;
	CALL3		client_update_modelBob;
	ADDRESS	self,	stat_wep_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_wep_rel,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_plr_stt,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	DONE;
}

void() player_unmakeObserver = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	TRUE,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	scale,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	view_ofs_x,	temp_0_x;
	STOREP_V	'0.000000 0.000000 1.000000',	temp_0;
	DONE;
}

void() player_makeVec = asm
{
	DONE;
}

void() player_makeMech = asm
{
local float locked_896;
local float locked_916;
local float locked_2932;
local float temp_6;
	ADDRESS	self,	data_idx,	locked_2932;
	INDIRECT_F	self,	nextVecChoice,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	INDIRECT_F	self,	nextVecChoice,	parm0_x;
	CALL1		data_iniMech;
	ADDRESS	self,	stat_rdr_mode,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	ADDRESS	self,	stat_rdr_rng,	locked_2932;
	INDIRECT_F	self,	radar_range,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	MOVETYPE_FLY,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	e_cam,	locked_2932;
	STORE_F	TRUE,	parm0_x;
	STORE_F	locked_2932,	parm1_x;
	CALL2		WriteEntity;
	CALL0		droptofloor;
	ADDRESS	self,	currentWeaponGroup,	locked_2932;
	INDIRECT_F	self,	w_group1,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	power_timer,	locked_2932;
	ADD_F		time,	MOVETYPE_PUSH,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	STORE_F	"mechdev",	parm0_x;
	CALL1		cvar;
	IFNOT		return_x,	4;
	ADDRESS	self,	power_timer,	locked_2932;
	ADD_F		time,	POWERUP_DEBUG,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	power_timer_segment,	locked_2932;
	ADD_F		time,	0.007000,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	ADDRESS	self,	stat_plr_stt,	locked_2932;
	STOREP_F	MOVETYPE_WALK,	locked_2932;
	CALL0		client_push_player_info;
	INDIRECT_F	self,	m_fspeed,	locked_2932;
	INDIRECT_F	self,	m_sspeed,	locked_916;
	INDIRECT_F	self,	m_bspeed,	locked_896;
	INDIRECT_F	self,	m_maccel,	parm0_x;
	CALL1		ftos;
	INDIRECT_S	self,	m_rollangle,	temp_6;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	STORE_F	locked_896,	parm2_x;
	STORE_F	return_x,	parm3_x;
	STORE_F	temp_6,	parm4_x;
	CALL5		client_update_moveSpeed;
	INDIRECT_S	self,	m_bob,	locked_2932;
	INDIRECT_S	self,	m_bcycle,	locked_916;
	INDIRECT_S	self,	m_bup,	locked_896;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	STORE_F	locked_896,	parm2_x;
	CALL3		client_update_viewBob;
	INDIRECT_S	self,	m_bmodel,	locked_2932;
	INDIRECT_S	self,	m_bside,	locked_916;
	INDIRECT_S	self,	m_bobspd,	locked_896;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	STORE_F	locked_896,	parm2_x;
	CALL3		client_update_modelBob;
	DONE;
}

void() player_unmakeMech = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	vec_size,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_trg_face,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn1,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn2,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn3,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn4,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn5,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn6,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn7,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn8,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn9,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_lck_stt,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	was_hit,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	hitdir_buffer,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_hit_dirs,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_rdr_mode,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_spr_x,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_spr_y,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	accuracy,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	accuracyMod,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_plr_stt,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	stat_plr_fir,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	stat_lck_stt,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	stat_ctor_hp,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_rdr_mode,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_rdr_rng,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	world,	temp_1;
	CALL0		mech_clearWeaponGroups;
	DONE;
}

void() SV_PlayerPhysics = asm
{
local float locked_2790;
local float locked_2939;
local float f;
local float wishspeed;
local vector v;
local vector wishdir;
local vector wishvel;
local float temp_1;
local float temp_3;
local float temp_4;
local vector temp_5;
	INDIRECT_F	self,	movetype,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	NE_F		time,	lastclientthink,	temp_1;
	IFNOT		temp_1,	20;
	STORE_F	time,	lastclientthink;
	STORE_F	"sv_maxairspeed",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	sv_maxairspeed;
	STORE_F	"sv_maxspeed",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	sv_maxspeed;
	STORE_F	"sv_friction",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	sv_friction;
	STORE_F	"sv_accelerate",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	sv_accelerate;
	STORE_F	"sv_stopspeed",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	sv_stopspeed;
	STORE_F	"sv_gravity",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	sv_gravity;
	INDIRECT_V	self,	punchangle_x,	locked_2939;
	NE_V		locked_2939,	VEC_ORIGIN,	temp_1;
	IFNOT		temp_1,	15;
	INDIRECT_V	self,	punchangle_x,	parm0;
	CALL1		vlen;
	MUL_F		MOVETYPE_BOUNCE,	frametime,	temp_1;
	SUB_F		return_x,	temp_1,	f;
	GT		f,	FALSE,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	punchangle_x,	locked_2939;
	INDIRECT_V	self,	punchangle_x,	parm0;
	CALL1		normalize;
	MUL_VF	return,	f,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	GOTO		3;
	ADDRESS	self,	punchangle_x,	locked_2939;
	STOREP_V	VEC_ORIGIN_x,	locked_2939;
	INDIRECT_V	self,	punchvector_x,	locked_2939;
	NE_V		locked_2939,	VEC_ORIGIN,	temp_1;
	IFNOT		temp_1,	15;
	INDIRECT_V	self,	punchvector_x,	parm0;
	CALL1		vlen;
	MUL_F		SVC_INTERMISSION,	frametime,	temp_1;
	SUB_F		return_x,	temp_1,	f;
	GT		f,	FALSE,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	punchvector_x,	locked_2939;
	INDIRECT_V	self,	punchvector_x,	parm0;
	CALL1		normalize;
	MUL_VF	return,	f,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	GOTO		3;
	ADDRESS	self,	punchvector_x,	locked_2939;
	STOREP_V	VEC_ORIGIN_x,	locked_2939;
	INDIRECT_F	self,	deadflag,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	fixangle,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	10;
	ADDRESS	self,	angles_x,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	angles_y,	temp_1;
	INDIRECT_F	self,	v_angle_y,	temp_3;
	INDIRECT_F	self,	punchangle_y,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	angles_z,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_WATERJUMP,	temp_1;
	IFNOT		temp_1,	23;
	ADDRESS	self,	velocity_x,	temp_1;
	INDIRECT_F	self,	movedir_x,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	velocity_y,	temp_1;
	INDIRECT_F	self,	movedir_y,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	teleport_time,	temp_1;
	GT		time,	temp_1,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	self,	waterlevel,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	9;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	FL_WATERJUMP,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	teleport_time,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		320;
	INDIRECT_F	self,	movetype,	temp_1;
	EQ_F		temp_1,	FL_CLIENT,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	self,	movetype,	temp_3;
	EQ_F		temp_3,	MOVETYPE_FLY,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	45;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	locked_2790;
	MUL_F		frametime,	sv_friction,	temp_1;
	SUB_F		TRUE,	temp_1,	temp_1;
	MUL_VF	locked_2790,	temp_1,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	INDIRECT_V	self,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_F	self,	movement_x,	temp_1;
	MUL_VF	v_forward,	temp_1,	locked_2939;
	INDIRECT_F	self,	movement_y,	temp_1;
	MUL_VF	v_right,	temp_1,	locked_2790;
	ADD_V		locked_2939,	locked_2790,	locked_2939;
	INDIRECT_F	self,	movement_z,	temp_1;
	MUL_VF	'0.000000 0.000000 1.000000',	temp_1,	locked_2790;
	ADD_V		locked_2939,	locked_2790,	wishvel;
	STORE_V	wishvel,	parm0;
	CALL1		normalize;
	STORE_V	return,	wishdir;
	STORE_V	wishvel,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	wishspeed;
	GT		wishspeed,	sv_maxspeed,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	sv_maxspeed,	wishspeed;
	INDIRECT_F	self,	teleport_time,	temp_1;
	GE		time,	temp_1,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_V	self,	velocity_x,	locked_2939;
	MUL_V		locked_2939,	wishdir,	temp_1;
	SUB_F		wishspeed,	temp_1,	f;
	GT		f,	FALSE,	temp_1;
	IFNOT		temp_1,	11;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	locked_2790;
	MUL_F		sv_accelerate,	frametime,	temp_1;
	MUL_F		temp_1,	wishspeed,	temp_1;
	STORE_F	f,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		min;
	MUL_VF	wishdir,	return_x,	temp_5;
	ADD_V		locked_2790,	temp_5,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	GOTO		269;
	INDIRECT_F	self,	waterlevel,	temp_1;
	GE		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	46;
	INDIRECT_V	self,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_F	self,	movement_x,	temp_1;
	MUL_VF	v_forward,	temp_1,	locked_2939;
	INDIRECT_F	self,	movement_y,	temp_1;
	MUL_VF	v_right,	temp_1,	locked_2790;
	ADD_V		locked_2939,	locked_2790,	locked_2939;
	INDIRECT_F	self,	movement_z,	temp_1;
	MUL_VF	'0.000000 0.000000 1.000000',	temp_1,	locked_2790;
	ADD_V		locked_2939,	locked_2790,	wishvel;
	EQ_V		wishvel,	VEC_ORIGIN,	temp_1;
	IFNOT		temp_1,	2;
	STORE_V	'0.000000 0.000000 -60.000000',	wishvel;
	STORE_V	wishvel,	parm0;
	CALL1		normalize;
	STORE_V	return,	wishdir;
	STORE_V	wishvel,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	wishspeed;
	GT		wishspeed,	sv_maxspeed,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	sv_maxspeed,	wishspeed;
	MUL_F		wishspeed,	DAT_MNT_SHIELD_RATE,	wishspeed;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	locked_2790;
	MUL_F		frametime,	sv_friction,	temp_1;
	SUB_F		TRUE,	temp_1,	temp_1;
	MUL_VF	locked_2790,	temp_1,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	INDIRECT_V	self,	velocity_x,	locked_2939;
	MUL_V		locked_2939,	wishdir,	temp_1;
	SUB_F		wishspeed,	temp_1,	f;
	GT		f,	FALSE,	temp_1;
	IFNOT		temp_1,	11;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	locked_2790;
	MUL_F		sv_accelerate,	frametime,	temp_1;
	MUL_F		temp_1,	wishspeed,	temp_1;
	STORE_F	f,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		min;
	MUL_VF	wishdir,	return_x,	temp_5;
	ADD_V		locked_2790,	temp_5,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	GOTO		221;
	INDIRECT_F	self,	ladder_time,	temp_1;
	LT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	116;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	locked_2790;
	MUL_F		frametime,	sv_friction,	temp_1;
	SUB_F		TRUE,	temp_1,	temp_1;
	MUL_VF	locked_2790,	temp_1,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	INDIRECT_V	self,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_F	self,	movement_x,	temp_1;
	MUL_VF	v_forward,	temp_1,	locked_2939;
	INDIRECT_F	self,	movement_y,	temp_1;
	MUL_VF	v_right,	temp_1,	locked_2790;
	ADD_V		locked_2939,	locked_2790,	locked_2939;
	INDIRECT_F	self,	movement_z,	temp_1;
	MUL_VF	'0.000000 0.000000 1.000000',	temp_1,	locked_2790;
	ADD_V		locked_2939,	locked_2790,	wishvel;
	INDIRECT_F	self,	gravity,	temp_1;
	IFNOT		temp_1,	9;
	ADDRESS	self,	velocity_z,	temp_1;
	INDIRECT_F	self,	velocity_z,	temp_3;
	INDIRECT_F	self,	gravity,	temp_4;
	MUL_F		temp_4,	sv_gravity,	temp_4;
	MUL_F		temp_4,	frametime,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		6;
	ADDRESS	self,	velocity_z,	temp_1;
	INDIRECT_F	self,	velocity_z,	temp_3;
	MUL_F		sv_gravity,	frametime,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	ladder_entity,	temp_1;
	INDIRECT_S	temp_1,	classname,	temp_1;
	EQ_S		temp_1,	"func_water",	temp_1;
	IFNOT		temp_1,	53;
	STORE_V	wishvel,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	f;
	INDIRECT_E	self,	ladder_entity,	temp_1;
	INDIRECT_F	temp_1,	speed,	temp_1;
	GT		f,	temp_1,	temp_1;
	IFNOT		temp_1,	5;
	INDIRECT_E	self,	ladder_entity,	temp_1;
	INDIRECT_F	temp_1,	speed,	temp_1;
	DIV_F		temp_1,	f,	temp_1;
	MUL_VF	wishvel,	temp_1,	wishvel;
	ADDRESS	self,	watertype,	temp_1;
	INDIRECT_E	self,	ladder_entity,	temp_3;
	INDIRECT_F	temp_3,	skin,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	ladder_entity,	temp_1;
	INDIRECT_F	temp_1,	origin_z,	temp_1;
	INDIRECT_E	self,	ladder_entity,	temp_3;
	INDIRECT_F	temp_3,	maxs_z,	temp_3;
	ADD_F		temp_1,	temp_3,	f;
	INDIRECT_F	self,	origin_z,	temp_1;
	INDIRECT_F	self,	view_ofs_z,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	LT		temp_1,	f,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	waterlevel,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	GOTO		25;
	INDIRECT_F	self,	origin_z,	temp_1;
	INDIRECT_F	self,	mins_z,	temp_3;
	INDIRECT_F	self,	maxs_z,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	MUL_F		temp_3,	0.500000,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	LT		temp_1,	f,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	waterlevel,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	GOTO		14;
	INDIRECT_F	self,	origin_z,	temp_1;
	INDIRECT_F	self,	mins_z,	temp_3;
	ADD_F		temp_1,	temp_3,	temp_1;
	ADD_F		temp_1,	TRUE,	temp_1;
	LT		temp_1,	f,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	waterlevel,	temp_1;
	STOREP_F	TRUE,	temp_1;
	GOTO		5;
	ADDRESS	self,	waterlevel,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	watertype,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	STORE_V	wishvel,	parm0;
	CALL1		normalize;
	STORE_V	return,	wishdir;
	STORE_V	wishvel,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	wishspeed;
	GT		wishspeed,	sv_maxspeed,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	sv_maxspeed,	wishspeed;
	INDIRECT_F	self,	teleport_time,	temp_1;
	GE		time,	temp_1,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_V	self,	velocity_x,	locked_2939;
	MUL_V		locked_2939,	wishdir,	temp_1;
	SUB_F		wishspeed,	temp_1,	f;
	GT		f,	FALSE,	temp_1;
	IFNOT		temp_1,	11;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	locked_2790;
	MUL_F		sv_accelerate,	frametime,	temp_1;
	MUL_F		temp_1,	wishspeed,	temp_1;
	STORE_F	f,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		min;
	MUL_VF	wishdir,	return_x,	temp_5;
	ADD_V		locked_2790,	temp_5,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	GOTO		103;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_ONGROUND,	temp_1;
	IFNOT		temp_1,	65;
	INDIRECT_F	self,	v_angle_y,	temp_1;
	MUL_FV	temp_1,	DAT_OTL_CAM_OFFSET_ALT,	parm0;
	CALL1		makevectors;
	INDIRECT_F	self,	movement_x,	temp_1;
	MUL_VF	v_forward,	temp_1,	locked_2939;
	INDIRECT_F	self,	movement_y,	temp_1;
	MUL_VF	v_right,	temp_1,	locked_2790;
	ADD_V		locked_2939,	locked_2790,	wishvel;
	INDIRECT_F	self,	velocity_x,	temp_1;
	IF		temp_1,	2;
	INDIRECT_F	self,	velocity_y,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	24;
	INDIRECT_V	self,	velocity_x,	v;
	STORE_F	FALSE,	v_z;
	STORE_V	v,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	f;
	LT		f,	sv_stopspeed,	temp_1;
	IFNOT		temp_1,	6;
	DIV_F		sv_stopspeed,	f,	temp_1;
	MUL_F		frametime,	temp_1,	temp_1;
	MUL_F		temp_1,	sv_friction,	temp_1;
	SUB_F		TRUE,	temp_1,	f;
	GOTO		3;
	MUL_F		frametime,	sv_friction,	temp_1;
	SUB_F		TRUE,	temp_1,	f;
	GT		f,	FALSE,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	locked_2790;
	MUL_VF	locked_2790,	f,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	GOTO		3;
	ADDRESS	self,	velocity_x,	locked_2939;
	STOREP_V	VEC_ORIGIN_x,	locked_2939;
	STORE_V	wishvel,	parm0;
	CALL1		normalize;
	STORE_V	return,	wishdir;
	STORE_V	wishvel,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	wishspeed;
	GT		wishspeed,	sv_maxspeed,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	sv_maxspeed,	wishspeed;
	INDIRECT_F	self,	teleport_time,	temp_1;
	GE		time,	temp_1,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_V	self,	velocity_x,	locked_2939;
	MUL_V		locked_2939,	wishdir,	temp_1;
	SUB_F		wishspeed,	temp_1,	f;
	GT		f,	FALSE,	temp_1;
	IFNOT		temp_1,	11;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	locked_2790;
	MUL_F		sv_accelerate,	frametime,	temp_1;
	MUL_F		temp_1,	wishspeed,	temp_1;
	STORE_F	f,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		min;
	MUL_VF	wishdir,	return_x,	temp_5;
	ADD_V		locked_2790,	temp_5,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	GOTO		36;
	INDIRECT_F	self,	v_angle_y,	temp_1;
	MUL_FV	temp_1,	DAT_OTL_CAM_OFFSET_ALT,	parm0;
	CALL1		makevectors;
	INDIRECT_F	self,	movement_x,	temp_1;
	MUL_VF	v_forward,	temp_1,	locked_2939;
	INDIRECT_F	self,	movement_y,	temp_1;
	MUL_VF	v_right,	temp_1,	locked_2790;
	ADD_V		locked_2939,	locked_2790,	wishvel;
	STORE_V	wishvel,	parm0;
	CALL1		normalize;
	STORE_V	return,	wishdir;
	STORE_V	wishvel,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	wishspeed;
	GT		wishspeed,	sv_maxairspeed,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	sv_maxairspeed,	wishspeed;
	INDIRECT_F	self,	teleport_time,	temp_1;
	GE		time,	temp_1,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_V	self,	velocity_x,	locked_2939;
	MUL_V		locked_2939,	wishdir,	temp_1;
	SUB_F		wishspeed,	temp_1,	f;
	GT		f,	FALSE,	temp_1;
	IFNOT		temp_1,	11;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	locked_2790;
	MUL_F		sv_accelerate,	frametime,	temp_1;
	MUL_F		temp_1,	wishspeed,	temp_1;
	STORE_F	f,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		min;
	MUL_VF	wishdir,	return_x,	temp_5;
	ADD_V		locked_2790,	temp_5,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	DONE;
}

void() mh_world_ini = asm
{
	STORE_F	"mechdev",	parm0_x;
	STORE_F	"0",	parm1_x;
	STORE_F	TRUE,	parm2_x;
	CALL3		registercvar;
	STORE_F	"campaign",	parm0_x;
	STORE_F	"0",	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		registercvar;
	STORE_F	"saveslot",	parm0_x;
	STORE_F	"0",	parm1_x;
	STORE_F	TRUE,	parm2_x;
	CALL3		registercvar;
	STORE_F	"gamemode",	parm0_x;
	STORE_F	"0",	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		registercvar;
	STORE_F	"gametype",	parm0_x;
	STORE_F	"0",	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		registercvar;
	STORE_F	"cl_hud_alpha",	parm0_x;
	STORE_F	"1",	parm1_x;
	STORE_F	TRUE,	parm2_x;
	CALL3		registercvar;
	STORE_F	"cl_hud_color",	parm0_x;
	STORE_F	"0",	parm1_x;
	STORE_F	TRUE,	parm2_x;
	CALL3		registercvar;
	STORE_F	TRUE,	parm0_x;
	CALL1		ftos;
	STORE_F	"gamemode",	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		cvar_set;
	IFNOT		coop,	6;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		ftos;
	STORE_F	"gamemode",	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		cvar_set;
	IFNOT		deathmatch,	6;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		ftos;
	STORE_F	"gamemode",	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		cvar_set;
	STORE_F	STAT_PLR_NAME,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	STORE_F	netname,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_ORG_X,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	STORE_F	stat_cofs_x,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_ORG_Y,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	STORE_F	stat_cofs_y,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_ORG_Z,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	STORE_F	stat_cofs_z,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_DIDX,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	data_idx,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_DTYPE,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	data_type,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_RADMOD,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_rdr_mode,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_LCK_STT,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_lck_stt,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_HITDIR,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_hit_dirs,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_RETDIST,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_ret_dist,	parm2_x;
	CALL3		addstat;
	STORE_F	TE_BLOOD,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_trg_ent_id,	parm2_x;
	CALL3		addstat;
	STORE_F	TE_EXPLOSIONRGB,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_trg_dat,	parm2_x;
	CALL3		addstat;
	STORE_F	TE_PARTICLECUBE,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_trg_dataidx,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_TRG_FACTION,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_trg_faction,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_CAM_ORG_X,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	STORE_F	stat_plr_camx,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_CAM_ORG_Y,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	STORE_F	stat_plr_camy,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_CAM_ORG_Z,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	STORE_F	stat_plr_camz,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_WEP1_ID,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_w1_id,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_WEP2_ID,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_w2_id,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_WEP3_ID,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_w3_id,	parm2_x;
	CALL3		addstat;
	STORE_F	TE_SMALLFLASH,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_w4_id,	parm2_x;
	CALL3		addstat;
	STORE_F	TE_CUSTOMFLASH,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_w5_id,	parm2_x;
	CALL3		addstat;
	STORE_F	TE_FLAMEJET,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_w6_id,	parm2_x;
	CALL3		addstat;
	STORE_F	TE_PLASMABURN,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_w7_id,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_WEP8_ID,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_w8_id,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_WEP9_ID,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_w9_id,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_TRG_DDFLG,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_trg_ddflg,	parm2_x;
	CALL3		addstat;
	STORE_F	TE_PARTICLERAIN,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_trg_dist,	parm2_x;
	CALL3		addstat;
	STORE_F	TE_PARTICLESNOW,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_trg_face,	parm2_x;
	CALL3		addstat;
	STORE_F	SVC_SELLSCREEN,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	STORE_F	accuracy,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_ANG_X,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	STORE_F	stat_plr_ang_x,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_ANG_Y,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	STORE_F	stat_plr_ang_y,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_ANG_Z,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	STORE_F	stat_plr_ang_z,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_PLR_REP,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	stat_plr_rep,	parm2_x;
	CALL3		addstat;
	STORE_F	STAT_RAD_SWEEP,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	STORE_F	radar_time,	parm2_x;
	CALL3		addstat;
	DONE;
}

void(float mech_id) data_iniMech = asm
{
local float temp_1;
	GOTO		16;
	STORE_F	data_otl_ini,	parm0_x;
	CALL1		build_mech_unit;
	GOTO		20;
	STORE_F	data_mtk_ini,	parm0_x;
	CALL1		build_mech_unit;
	GOTO		17;
	STORE_F	data_mnt_ini,	parm0_x;
	CALL1		build_mech_unit;
	GOTO		14;
	STORE_F	"Error: failed to build mech with id",	parm0_x;
	STORE_F	mech_id,	parm1_x;
	CALL2		cons_logAFloat;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	GOTO		8;
	EQ_F		mech_id,	TRUE,	temp_1;
	IF		temp_1,	-16;
	EQ_F		mech_id,	FL_SWIM,	temp_1;
	IF		temp_1,	-15;
	EQ_F		mech_id,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-14;
	GOTO		-12;
	DONE;
}

void(float vec_id) data_iniVehc = asm
{
local float temp_1;
	GOTO		37;
	STORE_F	data_HS_TruckA_ini,	parm0_x;
	CALL1		build_vehicle_unit;
	GOTO		55;
	STORE_F	data_HS_TruckB_ini,	parm0_x;
	CALL1		build_vehicle_unit;
	GOTO		52;
	STORE_F	data_HS_TruckC_ini,	parm0_x;
	CALL1		build_vehicle_unit;
	GOTO		49;
	STORE_F	data_HS_Dozer_ini,	parm0_x;
	CALL1		build_vehicle_unit;
	GOTO		46;
	STORE_F	data_HS_Loader_ini,	parm0_x;
	CALL1		build_vehicle_unit;
	GOTO		43;
	STORE_F	data_HS_Excat_ini,	parm0_x;
	CALL1		build_vehicle_unit;
	GOTO		40;
	STORE_F	data_H_TD_ini,	parm0_x;
	CALL1		build_vehicle_unit;
	GOTO		37;
	STORE_F	data_HS_TANKL_ini,	parm0_x;
	CALL1		build_vehicle_unit;
	GOTO		34;
	STORE_F	data_HS_GEVL_ini,	parm0_x;
	CALL1		build_vehicle_unit;
	GOTO		31;
	STORE_F	data_PSC_VTOLL_ini,	parm0_x;
	CALL1		build_vtol_unit;
	GOTO		28;
	STORE_F	"Error: failed to build vehicle with id",	parm0_x;
	STORE_F	vec_id,	parm1_x;
	CALL2		cons_logAFloat;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	GOTO		22;
	EQ_F		vec_id,	TRUE,	temp_1;
	IF		temp_1,	-37;
	EQ_F		vec_id,	FL_SWIM,	temp_1;
	IF		temp_1,	-36;
	EQ_F		vec_id,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-35;
	EQ_F		vec_id,	MOVETYPE_STEP,	temp_1;
	IF		temp_1,	-34;
	EQ_F		vec_id,	MOVETYPE_FLY,	temp_1;
	IF		temp_1,	-33;
	EQ_F		vec_id,	MOVETYPE_TOSS,	temp_1;
	IF		temp_1,	-32;
	EQ_F		vec_id,	MOVETYPE_FLYMISSILE,	temp_1;
	IF		temp_1,	-31;
	EQ_F		vec_id,	MOVETYPE_PUSH,	temp_1;
	IF		temp_1,	-30;
	EQ_F		vec_id,	MOVETYPE_BOUNCEMISSILE,	temp_1;
	IF		temp_1,	-29;
	EQ_F		vec_id,	STAT_PLR_HITDIR,	temp_1;
	IF		temp_1,	-28;
	GOTO		-26;
	DONE;
}

void(float vec_id) data_iniTurret = asm
{
local float temp_1;
	GOTO		10;
	STORE_F	data_tur_hlite_ini,	parm0_x;
	CALL1		build_turret_unit;
	RETURN	offset_0;
	STORE_F	"Error: failed to build turret with id",	parm0_x;
	STORE_F	vec_id,	parm1_x;
	CALL2		cons_logAFloat;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	EQ_F		vec_id,	TRUE,	temp_1;
	IF		temp_1,	-10;
	GOTO		-8;
	DONE;
}

void(float prj_id) data_iniProjectile = asm
{
local float temp_1;
	GOTO		19;
	CALL0		data_prj_emp_ini;
	RETURN	offset_0;
	CALL0		data_prj_mis_ini;
	RETURN	offset_0;
	CALL0		data_prj_mlgd_ini;
	RETURN	offset_0;
	CALL0		data_prj_marh_ini;
	RETURN	offset_0;
	CALL0		data_prj_rplas_ini;
	RETURN	offset_0;
	CALL0		data_prj_qrfl_ini;
	RETURN	offset_0;
	CALL0		data_prj_sfga_ini;
	RETURN	offset_0;
	CALL0		data_prj_ion_ini;
	RETURN	offset_0;
	CALL0		data_prj_swrm_ini;
	RETURN	offset_0;
	EQ_F		prj_id,	FL_SWIM,	temp_1;
	IF		temp_1,	-19;
	EQ_F		prj_id,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-19;
	EQ_F		prj_id,	MOVETYPE_STEP,	temp_1;
	IF		temp_1,	-19;
	EQ_F		prj_id,	MOVETYPE_FLY,	temp_1;
	IF		temp_1,	-19;
	EQ_F		prj_id,	MOVETYPE_TOSS,	temp_1;
	IF		temp_1,	-19;
	EQ_F		prj_id,	MOVETYPE_PUSH,	temp_1;
	IF		temp_1,	-19;
	EQ_F		prj_id,	FL_CLIENT,	temp_1;
	IF		temp_1,	-19;
	EQ_F		prj_id,	MOVETYPE_FLYMISSILE,	temp_1;
	IF		temp_1,	-19;
	EQ_F		prj_id,	MOVETYPE_BOUNCE,	temp_1;
	IF		temp_1,	-19;
	STORE_F	"Error: failed to find projectile of ",	parm0_x;
	STORE_F	prj_id,	parm1_x;
	CALL2		cons_logAFloat;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void(float wep_id) data_iniWep = asm
{
local float temp_1;
	GOTO		41;
	CALL0		data_latc_ini;
	RETURN	offset_0;
	CALL0		data_emp_ini;
	RETURN	offset_0;
	CALL0		data_las_ini;
	RETURN	offset_0;
	CALL0		data_mis_ini;
	RETURN	offset_0;
	CALL0		data_qrfl_ini;
	RETURN	offset_0;
	CALL0		data_rplas_ini;
	RETURN	offset_0;
	CALL0		data_sfga_ini;
	RETURN	offset_0;
	CALL0		data_pac_ini;
	RETURN	offset_0;
	CALL0		data_esr_ini;
	RETURN	offset_0;
	CALL0		data_mlgd_ini;
	RETURN	offset_0;
	CALL0		data_marh_ini;
	RETURN	offset_0;
	CALL0		data_flak_ini;
	RETURN	offset_0;
	CALL0		data_ion_ini;
	RETURN	offset_0;
	CALL0		data_swrm_ini;
	RETURN	offset_0;
	CALL0		data_eqp_atgm_ini;
	RETURN	offset_0;
	CALL0		data_eqp_enbat_ini;
	RETURN	offset_0;
	CALL0		data_eqp_recap_ini;
	RETURN	offset_0;
	CALL0		data_eqp_lsar_ini;
	RETURN	offset_0;
	CALL0		data_eqp_hsem_ini;
	RETURN	offset_0;
	CALL0		data_eqp_scap_ini;
	RETURN	offset_0;
	EQ_F		wep_id,	TRUE,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	FL_SWIM,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	MOVETYPE_STEP,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	MOVETYPE_FLY,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	MOVETYPE_TOSS,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	MOVETYPE_BOUNCEMISSILE,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	MOVETYPE_PUSH,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	FL_CLIENT,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	MOVETYPE_FLYMISSILE,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	MOVETYPE_BOUNCE,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	MOVETYPE_FOLLOW,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	IMP_SWEAPON1,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	DPCONTENTS_LIQUIDSMASK,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	IMP_SWEAPON3,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	FL_INWATER,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	20.000000,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	IMP_SWEAPON6,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	IMP_SWEAPON5,	temp_1;
	IF		temp_1,	-41;
	EQ_F		wep_id,	IMP_SWEAPON7,	temp_1;
	IF		temp_1,	-41;
	DONE;
}

void() client_push_player_info = asm
{
local float targShield;
local float enm;
local entity wep;
local float temp_1;
local float temp_3;
	ADDRESS	self,	ammo_rockets,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	ammo_cells,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	armorvalue,	temp_1;
	INDIRECT_F	self,	stat_plr_stt,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	STAT_WEP_REL,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	self,	origin_x,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	self,	origin_y,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	self,	origin_z,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	self,	stat_rdr_rng,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteLong;
	INDIRECT_F	self,	data_type,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	151;
	INDIRECT_F	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	DIV_F		temp_1,	temp_3,	temp_1;
	MUL_F		temp_1,	STAT_PLR_ANG_X,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteShort;
	INDIRECT_F	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_max,	temp_3;
	DIV_F		temp_1,	temp_3,	temp_1;
	MUL_F		temp_1,	STAT_PLR_ANG_X,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteShort;
	STORE_F	self,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	e_legs,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	e_tor_l,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	e_tor_r,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	e_arm_l,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	e_arm_r,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	self,	hardpoint_cnt,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	w_slot,	wep;
	IFNOT		wep,	7;
	INDIRECT_F	wep,	rl_cur,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	wep,	w_slot,	wep;
	GOTO		-6;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		num_for_edict;
	STORE_F	return_x,	enm;
	STORE_F	TRUE,	parm0_x;
	STORE_F	enm,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	enemy,	temp_1;
	NE_E		temp_1,	world,	temp_1;
	IFNOT		temp_1,	86;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	temp_1,	origin_x,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	temp_1,	origin_y,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	temp_1,	origin_z,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	temp_1,	sh_cur,	targShield;
	LE		targShield,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	FALSE,	targShield;
	GOTO		7;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	temp_1,	sh_cur,	temp_1;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_F	temp_3,	sh_max,	temp_3;
	DIV_F		temp_1,	temp_3,	temp_1;
	MUL_F		temp_1,	STAT_PLR_ANG_X,	targShield;
	STORE_F	TRUE,	parm0_x;
	STORE_F	targShield,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	enemy,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_E	temp_1,	e_legs,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_E	temp_1,	e_tor_l,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_E	temp_1,	e_tor_r,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_E	temp_1,	e_arm_l,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_E	temp_1,	e_arm_r,	parm0_x;
	CALL1		csqc_updateCompStat;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_F	temp_1,	maxs_y,	temp_1;
	MUL_F		temp_1,	FL_SWIM,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteShort;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_S	temp_1,	netname,	temp_1;
	EQ_S		temp_1,	"",	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_E	self,	enemy,	temp_1;
	ADDRESS	temp_1,	netname,	temp_1;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_S	temp_3,	vec_name,	temp_3;
	STOREP_S	temp_3,	temp_1;
	INDIRECT_E	self,	enemy,	temp_1;
	INDIRECT_S	temp_1,	netname,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteString;
	DONE;
}

void(entity targetClient) server_push_player_info = asm
{
local entity this;
	STORE_ENT	self,	this;
	STORE_ENT	targetClient,	self;
	CALL0		client_push_player_info;
	STORE_ENT	this,	self;
	DONE;
}

void(entity radarPing) client_push_radar_ping = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	STAT_NAV_DIR,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	radarPing,	origin_x,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	radarPing,	origin_y,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	radarPing,	origin_z,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	radarPing,	origin_x,	temp_2;
	SUB_V		temp_0,	temp_2,	parm0;
	CALL1		vlen;
	STORE_F	TRUE,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		WriteLong;
	INDIRECT_F	radarPing,	data_type,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	radarPing,	i_faction,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void(entity targetClient) client_push_hud_highlight = asm
{
local entity this;
local float temp_1;
	STORE_ENT	self,	this;
	STORE_ENT	targetClient,	self;
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	STAT_LCK_STT,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	this,	movedir_x,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	this,	movedir_y,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	this,	movedir_z,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	this,	c_ofs_x,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	this,	c_ofs_y,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	this,	c_ofs_z,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	this,	color_x,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	this,	color_y,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	this,	color_z,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	this,	p_lifetime,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteShort;
	STORE_ENT	this,	self;
	DONE;
}

void(entity navpoint) client_send_navpoint = asm
{
local float nactive;
local float temp_1;
local float temp_3;
	STORE_ENT	self,	msg_entity;
	INDIRECT_F	navpoint,	isActive,	nactive;
	INDIRECT_F	navpoint,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	NE_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	FALSE,	nactive;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	TE_EVT_NAV,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	navpoint,	data_idx,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	nactive,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	navpoint,	origin_x,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	navpoint,	origin_y,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	navpoint,	origin_z,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	DONE;
}

void(entity objective) client_send_objective = asm
{
local float nactive;
local float temp_1;
local float temp_3;
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	STAT_RAD_SWEEP,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	objective,	data_idx,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	objective,	isActive,	nactive;
	INDIRECT_F	objective,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	NE_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	FALSE,	nactive;
	STORE_F	TRUE,	parm0_x;
	STORE_F	nactive,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	objective,	state_1,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void(entity deploy) client_send_deploypoint = asm
{
local float nactive;
local float temp_1;
local float temp_3;
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	TE_EVT_DEP,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	deploy,	data_idx,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	deploy,	isActive,	nactive;
	INDIRECT_F	deploy,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	NE_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	STORE_F	FALSE,	nactive;
	STORE_F	TRUE,	parm0_x;
	STORE_F	nactive,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	deploy,	origin_x,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	deploy,	origin_y,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	INDIRECT_F	deploy,	origin_z,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteCoord;
	DONE;
}

void(entity targetClient) client_send_boundary_warning = asm
{
local entity this;
local float temp_1;
	STORE_ENT	self,	this;
	STORE_ENT	targetClient,	self;
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	TE_MSN_BOUND,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	this,	isActive,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_F	this,	ai_dir,	temp_1;
	STORE_F	TRUE,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		WriteAngle;
	STORE_ENT	this,	self;
	DONE;
}

void() client_push_mapobjects = asm
{
local float locked_2932;
local entity obj;
local float temp_3;
	STORE_F	flags,	parm0_x;
	STORE_F	FL_NODE,	parm1_x;
	CALL2		findchainflags;
	STORE_ENT	return_x,	obj;
	IFNOT		obj,	20;
	INDIRECT_F	obj,	data_type,	locked_2932;
	GOTO		10;
	STORE_F	obj,	parm0_x;
	CALL1		client_send_deploypoint;
	GOTO		13;
	STORE_F	obj,	parm0_x;
	CALL1		client_send_navpoint;
	GOTO		10;
	STORE_F	obj,	parm0_x;
	CALL1		client_send_objective;
	GOTO		7;
	EQ_F		locked_2932,	MOVETYPE_BOUNCEMISSILE,	temp_3;
	IF		temp_3,	-10;
	EQ_F		locked_2932,	FL_CLIENT,	temp_3;
	IF		temp_3,	-9;
	EQ_F		locked_2932,	MOVETYPE_FLYMISSILE,	temp_3;
	IF		temp_3,	-8;
	INDIRECT_E	obj,	chain,	obj;
	GOTO		-19;
	DONE;
}

void(string str, float tokens) client_ParseMechCommand = asm
{
local float locked_2932;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	"setwep",	locked_2932;
	IFNOT		locked_2932,	8;
	INDIRECT_F	self,	deadflag,	locked_2932;
	GE		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	4;
	STORE_F	str,	parm0_x;
	STORE_F	tokens,	parm1_x;
	CALL2		client_setWeapon;
	GOTO		70;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	"setmech",	locked_2932;
	IFNOT		locked_2932,	14;
	ADDRESS	self,	vec_size,	locked_2932;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		stof;
	STOREP_F	return_x,	locked_2932;
	ADDRESS	self,	nextVecChoice,	locked_2932;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		stof;
	STOREP_F	return_x,	locked_2932;
	GOTO		53;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	"spawn",	locked_2932;
	IFNOT		locked_2932,	11;
	INDIRECT_F	self,	data_type,	locked_2932;
	EQ_F		locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	7;
	CALL0		player_unmakeObserver;
	CALL0		player_makeMech;
	CALL0		spawnpoint_select;
	INDIRECT_F	world,	sounds,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		client_playTrack;
	GOTO		39;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	"setgroup",	locked_2932;
	IFNOT		locked_2932,	5;
	STORE_F	str,	parm0_x;
	STORE_F	tokens,	parm1_x;
	CALL2		client_setWeaponGroup;
	GOTO		31;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	"setnav",	locked_2932;
	IFNOT		locked_2932,	5;
	STORE_F	str,	parm0_x;
	STORE_F	tokens,	parm1_x;
	CALL2		client_setNavPoint;
	GOTO		23;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	"setfaction",	locked_2932;
	IFNOT		locked_2932,	10;
	ADDRESS	self,	i_faction,	locked_2932;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		stof;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	i_faction,	parm0_x;
	CALL1		mapfile_pvp_load;
	GOTO		10;
	STORE_F	TRUE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	"setmode",	locked_2932;
	IFNOT		locked_2932,	6;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		argv;
	STORE_F	"gamemode",	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		cvar_set;
	DONE;
}

void(string cmd, float tokens) client_setWeaponGroup = asm
{
local float groupval;
local float groupnum;
local float temp_1;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		stof;
	STORE_F	return_x,	groupnum;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		stof;
	STORE_F	return_x,	groupval;
	GOTO		16;
	ADDRESS	self,	w_group1,	temp_1;
	STOREP_F	groupval,	temp_1;
	GOTO		23;
	ADDRESS	self,	w_group2,	temp_1;
	STOREP_F	groupval,	temp_1;
	GOTO		20;
	ADDRESS	self,	w_group3,	temp_1;
	STOREP_F	groupval,	temp_1;
	GOTO		17;
	ADDRESS	self,	w_group4,	temp_1;
	STOREP_F	groupval,	temp_1;
	GOTO		14;
	ADDRESS	self,	w_group5,	temp_1;
	STOREP_F	groupval,	temp_1;
	GOTO		11;
	EQ_F		groupnum,	TRUE,	temp_1;
	IF		temp_1,	-16;
	EQ_F		groupnum,	FL_SWIM,	temp_1;
	IF		temp_1,	-15;
	EQ_F		groupnum,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-14;
	EQ_F		groupnum,	MOVETYPE_STEP,	temp_1;
	IF		temp_1,	-13;
	EQ_F		groupnum,	MOVETYPE_FLY,	temp_1;
	IF		temp_1,	-12;
	DONE;
}

void(string mechs) client_sendAvailableLightMechs = asm
{
local string cmd;
	STORE_F	"mech list_light [",	parm0_x;
	STORE_F	mechs,	parm1_x;
	STORE_F	"]
",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	cmd;
	STORE_F	self,	parm0_x;
	STORE_F	cmd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void(string mechs) client_sendAvailableMediumMechs = asm
{
local string cmd;
	STORE_F	"mech list_med [",	parm0_x;
	STORE_F	mechs,	parm1_x;
	STORE_F	"]
",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	cmd;
	STORE_F	self,	parm0_x;
	STORE_F	cmd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void(string mechs) client_sendAvailableHeavyMechs = asm
{
local string cmd;
	STORE_F	"mech list_hvy [",	parm0_x;
	STORE_F	mechs,	parm1_x;
	STORE_F	"]
",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	cmd;
	STORE_F	self,	parm0_x;
	STORE_F	cmd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void(string itms) client_sendAvailableItems = asm
{
local string cmd;
	STORE_F	"mech list_items [",	parm0_x;
	STORE_F	itms,	parm1_x;
	STORE_F	"]
",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	cmd;
	STORE_F	self,	parm0_x;
	STORE_F	cmd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void(float mode) client_sendGameMode = asm
{
local string cmd;
	STORE_F	mode,	parm0_x;
	CALL1		ftos;
	STORE_F	"mech gamemode ",	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	"
",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	cmd;
	STORE_F	self,	parm0_x;
	STORE_F	cmd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void(string cmd, float tokens) client_setWeapon = asm
{
local entity oself;
local float new_id;
local float wslotid;
local float temp_1;
	STORE_ENT	self,	oself;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		stof;
	STORE_F	return_x,	wslotid;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		stof;
	STORE_F	return_x,	new_id;
	GOTO		28;
	ADDRESS	self,	next_wepn1,	temp_1;
	STOREP_F	new_id,	temp_1;
	GOTO		43;
	ADDRESS	self,	next_wepn2,	temp_1;
	STOREP_F	new_id,	temp_1;
	GOTO		40;
	ADDRESS	self,	next_wepn3,	temp_1;
	STOREP_F	new_id,	temp_1;
	GOTO		37;
	ADDRESS	self,	next_wepn4,	temp_1;
	STOREP_F	new_id,	temp_1;
	GOTO		34;
	ADDRESS	self,	next_wepn5,	temp_1;
	STOREP_F	new_id,	temp_1;
	GOTO		31;
	ADDRESS	self,	next_wepn6,	temp_1;
	STOREP_F	new_id,	temp_1;
	GOTO		28;
	ADDRESS	self,	next_wepn7,	temp_1;
	STOREP_F	new_id,	temp_1;
	GOTO		25;
	ADDRESS	self,	next_wepn8,	temp_1;
	STOREP_F	new_id,	temp_1;
	GOTO		22;
	ADDRESS	self,	next_wepn9,	temp_1;
	STOREP_F	new_id,	temp_1;
	GOTO		19;
	EQ_F		wslotid,	TRUE,	temp_1;
	IF		temp_1,	-28;
	EQ_F		wslotid,	FL_SWIM,	temp_1;
	IF		temp_1,	-27;
	EQ_F		wslotid,	MOVETYPE_STEP,	temp_1;
	IF		temp_1,	-26;
	EQ_F		wslotid,	FL_CLIENT,	temp_1;
	IF		temp_1,	-25;
	EQ_F		wslotid,	FL_INWATER,	temp_1;
	IF		temp_1,	-24;
	EQ_F		wslotid,	FL_MONSTER,	temp_1;
	IF		temp_1,	-23;
	EQ_F		wslotid,	FL_GODMODE,	temp_1;
	IF		temp_1,	-22;
	EQ_F		wslotid,	FL_NOTARGET,	temp_1;
	IF		temp_1,	-21;
	EQ_F		wslotid,	FL_ITEM,	temp_1;
	IF		temp_1,	-20;
	DONE;
}

void(float track, float loop) client_playTrack = asm
{
local string cmd;
	STORE_S	"cd ",	cmd;
	IFNOT		loop,	6;
	STORE_F	cmd,	parm0_x;
	STORE_F	"loop ",	parm1_x;
	CALL2		strcat;
	STORE_S	return_x,	cmd;
	GOTO		5;
	STORE_F	cmd,	parm0_x;
	STORE_F	"play ",	parm1_x;
	CALL2		strcat;
	STORE_S	return_x,	cmd;
	STORE_F	track,	parm0_x;
	CALL1		ftos;
	STORE_F	cmd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	"
",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	cmd;
	STORE_F	self,	parm0_x;
	STORE_F	cmd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void() client_sendMissionFileName = asm
{
local string cmd;
local float temp_1;
	INDIRECT_S	world,	msn_file,	temp_1;
	STORE_F	"mech msn_file ",	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	"
",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	cmd;
	STORE_F	self,	parm0_x;
	STORE_F	cmd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void(string fileName) client_sendAnimaticFileName = asm
{
local string cmd;
	STORE_F	"mech anm_file ",	parm0_x;
	STORE_F	fileName,	parm1_x;
	STORE_F	"
",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	cmd;
	STORE_F	self,	parm0_x;
	STORE_F	cmd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void(string cmd, float tokens) client_setNavPoint = asm
{
local entity nav;
local float nav_id;
local float temp_1;
local float temp_3;
	STORE_F	FL_SWIM,	parm0_x;
	CALL1		argv;
	STORE_F	return_x,	parm0_x;
	CALL1		stof;
	STORE_F	return_x,	nav_id;
	STORE_F	data_type,	parm0_x;
	STORE_F	MOVETYPE_BOUNCEMISSILE,	parm1_x;
	CALL2		findchainfloat;
	STORE_ENT	return_x,	nav;
	IFNOT		nav,	14;
	INDIRECT_F	nav,	isActive,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_F	nav,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_F	nav,	data_idx,	temp_1;
	EQ_F		temp_1,	nav_id,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	goalentity,	temp_1;
	STOREP_ENT	nav,	temp_1;
	INDIRECT_E	nav,	chain,	nav;
	GOTO		-13;
	DONE;
}

void(entity client, float fogDense, vector fogColor, float fogAlpha, vector fogDist, float fogFade) client_sendFog = asm
{
local string fogCmd;
	STORE_S	"fog ",	fogCmd;
	STORE_F	fogDense,	parm0_x;
	CALL1		ftos;
	STORE_F	fogCmd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	" ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	fogCmd;
	STORE_F	fogColor_x,	parm0_x;
	CALL1		ftos;
	STORE_F	fogCmd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	" ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	fogCmd;
	STORE_F	fogColor_y,	parm0_x;
	CALL1		ftos;
	STORE_F	fogCmd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	" ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	fogCmd;
	STORE_F	fogColor_z,	parm0_x;
	CALL1		ftos;
	STORE_F	fogCmd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	" ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	fogCmd;
	STORE_F	fogAlpha,	parm0_x;
	CALL1		ftos;
	STORE_F	fogCmd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	" ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	fogCmd;
	STORE_F	fogDist_x,	parm0_x;
	CALL1		ftos;
	STORE_F	fogCmd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	" ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	fogCmd;
	STORE_F	fogDist_y,	parm0_x;
	CALL1		ftos;
	STORE_F	fogCmd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	" ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	fogCmd;
	STORE_F	fogDist_z,	parm0_x;
	CALL1		ftos;
	STORE_F	fogCmd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	" ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	fogCmd;
	STORE_F	fogFade,	parm0_x;
	CALL1		ftos;
	STORE_F	fogCmd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	"
",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	fogCmd;
	STORE_F	client,	parm0_x;
	STORE_F	fogCmd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void(entity client, float trackNum, float entFlags) client_sendMusic = asm
{
local string musicCmd;
local float temp_1;
	STORE_ENT	self,	otemp;
	STORE_ENT	client,	self;
	BITAND	entFlags,	FL_SWIM,	temp_1;
	STORE_F	trackNum,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		client_playTrack;
	STORE_ENT	otemp,	self;
	DONE;
}

void(float fwd, float side, float bck, string accel, string roll) client_update_moveSpeed = asm
{
local string comd;
	STORE_F	fwd,	parm0_x;
	CALL1		ftos;
	STORE_F	"cl_forwardspeed ",	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	" 
 ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	comd;
	STORE_F	side,	parm0_x;
	CALL1		ftos;
	STORE_F	"cl_sidespeed ",	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	" 
 ",	parm2_x;
	CALL3		strcat;
	STORE_F	comd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		strcat;
	STORE_S	return_x,	comd;
	STORE_F	bck,	parm0_x;
	CALL1		ftos;
	STORE_F	"cl_backspeed ",	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	" 
 ",	parm2_x;
	CALL3		strcat;
	STORE_F	comd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		strcat;
	STORE_S	return_x,	comd;
	STORE_F	"cl_movespeedkey ",	parm0_x;
	STORE_F	accel,	parm1_x;
	STORE_F	" 
 ",	parm2_x;
	CALL3		strcat;
	STORE_F	comd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		strcat;
	STORE_S	return_x,	comd;
	STORE_F	"cl_rollangle ",	parm0_x;
	STORE_F	roll,	parm1_x;
	STORE_F	" 
",	parm2_x;
	CALL3		strcat;
	STORE_F	comd,	parm0_x;
	STORE_F	return_x,	parm1_x;
	CALL2		strcat;
	STORE_S	return_x,	comd;
	STORE_F	self,	parm0_x;
	STORE_F	comd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void(string bob, string cycle, string up) client_update_viewBob = asm
{
local string comd;
	STORE_F	"cl_bob ",	parm0_x;
	STORE_F	bob,	parm1_x;
	STORE_F	" 
 ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	comd;
	STORE_F	comd,	parm0_x;
	STORE_F	"cl_bobcycle ",	parm1_x;
	STORE_F	cycle,	parm2_x;
	STORE_F	" 
 ",	parm3_x;
	CALL4		strcat;
	STORE_S	return_x,	comd;
	STORE_F	comd,	parm0_x;
	STORE_F	"cl_bobup ",	parm1_x;
	STORE_F	up,	parm2_x;
	STORE_F	" 
",	parm3_x;
	CALL4		strcat;
	STORE_S	return_x,	comd;
	STORE_F	self,	parm0_x;
	STORE_F	comd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void(string bobmodel, string side, string bmod_speed) client_update_modelBob = asm
{
local string comd;
	STORE_F	"cl_bobmodel ",	parm0_x;
	STORE_F	bobmodel,	parm1_x;
	STORE_F	" 
 ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	comd;
	STORE_F	comd,	parm0_x;
	STORE_F	"cl_bobmodel_side ",	parm1_x;
	STORE_F	side,	parm2_x;
	STORE_F	" 
 ",	parm3_x;
	CALL4		strcat;
	STORE_S	return_x,	comd;
	STORE_F	comd,	parm0_x;
	STORE_F	"cl_bobmodel_speed ",	parm1_x;
	STORE_F	bmod_speed,	parm2_x;
	STORE_F	" 
",	parm3_x;
	CALL4		strcat;
	STORE_S	return_x,	comd;
	STORE_F	self,	parm0_x;
	STORE_F	comd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void(string p_max, string p_min) client_update_viewPitch = asm
{
local string comd;
	STORE_F	"in_pitch_max ",	parm0_x;
	STORE_F	p_max,	parm1_x;
	STORE_F	" 
 ",	parm2_x;
	CALL3		strcat;
	STORE_S	return_x,	comd;
	STORE_F	comd,	parm0_x;
	STORE_F	"in_pitch_min ",	parm1_x;
	STORE_F	p_min,	parm2_x;
	STORE_F	"
",	parm3_x;
	CALL4		strcat;
	STORE_S	return_x,	comd;
	STORE_F	self,	parm0_x;
	STORE_F	comd,	parm1_x;
	CALL2		stuffcmd;
	DONE;
}

void() respawn = asm
{
local float temp_1;
	IFNOT		coop,	10;
	STORE_F	self,	parm0_x;
	CALL1		CopyToBodyQue;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	3;
	CALL0		player_unmakeMech;
	CALL0		player_makeObserver;
	CALL0		PutClientInServer;
	GOTO		14;
	IFNOT		deathmatch,	11;
	STORE_F	self,	parm0_x;
	CALL1		CopyToBodyQue;
	CALL0		SetNewParms;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	3;
	CALL0		player_unmakeMech;
	CALL0		player_makeObserver;
	CALL0		PutClientInServer;
	GOTO		3;
	STORE_F	"restart
",	parm0_x;
	CALL1		localcmd;
	DONE;
}

entity() spawnpoint_coop = asm
{
local entity locus;
local float temp_1;
local float temp_3;
	STORE_F	data_type,	parm0_x;
	STORE_F	IMP_SWEAPON3,	parm1_x;
	CALL2		findchainfloat;
	STORE_ENT	return_x,	locus;
	IFNOT		locus,	18;
	INDIRECT_F	locus,	i_faction,	temp_1;
	INDIRECT_F	self,	i_faction,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_S	locus,	target,	temp_1;
	INDIRECT_E	self,	goalentity,	temp_3;
	INDIRECT_S	temp_3,	targetname,	temp_3;
	EQ_S		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	locus,	data_idx,	temp_1;
	INDIRECT_F	self,	client_num,	temp_3;
	EQ_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	goalentity,	temp_1;
	STOREP_ENT	locus,	temp_1;
	INDIRECT_E	locus,	chain,	locus;
	GOTO		-17;
	INDIRECT_E	self,	goalentity,	temp_1;
	RETURN	temp_1;
	DONE;
}

entity() spawnpoint_single = asm
{
	DONE;
}

entity() SelectSpawnPoint = asm
{
local float pcount;
local entity thing;
local entity spot;
local vector temp_0;
local float temp_1;
	STORE_F	world,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"testinfo_player_start",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	spot;
	IFNOT		spot,	2;
	RETURN	spot;
	IFNOT		deathmatch,	32;
	INDIRECT_F	self,	data_type,	temp_1;
	NE_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	29;
	STORE_ENT	lastspawn,	spot;
	STORE_F	spot,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"info_player_deathmatch",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	spot;
	NE_E		spot,	world,	temp_1;
	IFNOT		temp_1,	20;
	EQ_E		spot,	lastspawn,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	lastspawn;
	STORE_F	FALSE,	pcount;
	INDIRECT_V	spot,	origin_x,	parm0;
	STORE_F	FL_MONSTER,	parm1_x;
	CALL2		findradius;
	STORE_ENT	return_x,	thing;
	IFNOT		thing,	7;
	INDIRECT_S	thing,	classname,	temp_1;
	EQ_S		temp_1,	"player",	temp_1;
	IFNOT		temp_1,	2;
	ADD_F		pcount,	TRUE,	pcount;
	INDIRECT_E	thing,	chain,	thing;
	GOTO		-6;
	EQ_F		pcount,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	STORE_ENT	spot,	lastspawn;
	RETURN	spot;
	GOTO		-26;
	IFNOT		serverflags,	8;
	STORE_F	world,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"info_player_start2",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	spot;
	IFNOT		spot,	2;
	RETURN	spot;
	STORE_F	world,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"info_player_start",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	spot;
	IF		spot,	3;
	STORE_F	"PutClientInServer: no info_player_start on level",	parm0_x;
	CALL1		error;
	RETURN	spot;
	DONE;
}

void() spawnpoint_select = asm
{
local entity spot;
local vector temp_0;
local float temp_1;
local vector temp_2;
local vector temp_5;
	INDIRECT_E	self,	goalentity,	temp_1;
	IFNOT		temp_1,	7;
	IFNOT		coop,	4;
	CALL0		spawnpoint_coop;
	STORE_ENT	return_x,	spot;
	GOTO		2;
	INDIRECT_E	self,	goalentity,	spot;
	GOTO		3;
	CALL0		SelectSpawnPoint;
	STORE_ENT	return_x,	spot;
	ADDRESS	self,	origin_x,	temp_0_x;
	ADDRESS	self,	oldorigin_x,	temp_2_x;
	INDIRECT_V	spot,	origin_x,	temp_5;
	ADD_V		temp_5,	'0.000000 0.000000 12.000000',	temp_5;
	STOREP_V	temp_5_x,	temp_2;
	STOREP_V	temp_5_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_V	spot,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	fixangle,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

void() spawnpoint_Random = asm
{
local entity spot;
local vector temp_0;
local float temp_1;
local vector temp_2;
local vector temp_5;
	INDIRECT_E	self,	goalentity,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	self,	goalentity,	spot;
	GOTO		3;
	CALL0		SelectSpawnPoint;
	STORE_ENT	return_x,	spot;
	ADDRESS	self,	origin_x,	temp_0_x;
	ADDRESS	self,	oldorigin_x,	temp_2_x;
	INDIRECT_V	spot,	origin_x,	temp_5;
	ADD_V		temp_5,	'0.000000 0.000000 12.000000',	temp_5;
	STOREP_V	temp_5_x,	temp_2;
	STOREP_V	temp_5_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_V	spot,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	fixangle,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

void() legacy_PlayerDie = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	ADDRESS	self,	items,	temp_1;
	INDIRECT_F	self,	items,	temp_3;
	INDIRECT_F	self,	items,	temp_4;
	BITAND	temp_4,	7864320.000000,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() client_updateWeaponReloads = asm
{
local float wid;
local float delta;
local float idx;
local entity e;
local float temp_1;
	STORE_F	TRUE,	idx;
	INDIRECT_E	self,	w_slot,	e;
	IFNOT		e,	52;
	INDIRECT_F	e,	rl_cur,	delta;
	INDIRECT_F	e,	data_idx,	wid;
	GOTO		28;
	ADDRESS	self,	stat_w1_id,	temp_1;
	STOREP_F	wid,	temp_1;
	GOTO		43;
	ADDRESS	self,	stat_w2_id,	temp_1;
	STOREP_F	wid,	temp_1;
	GOTO		40;
	ADDRESS	self,	stat_w3_id,	temp_1;
	STOREP_F	wid,	temp_1;
	GOTO		37;
	ADDRESS	self,	stat_w4_id,	temp_1;
	STOREP_F	wid,	temp_1;
	GOTO		34;
	ADDRESS	self,	stat_w5_id,	temp_1;
	STOREP_F	wid,	temp_1;
	GOTO		31;
	ADDRESS	self,	stat_w6_id,	temp_1;
	STOREP_F	wid,	temp_1;
	GOTO		28;
	ADDRESS	self,	stat_w7_id,	temp_1;
	STOREP_F	wid,	temp_1;
	GOTO		25;
	ADDRESS	self,	stat_w8_id,	temp_1;
	STOREP_F	wid,	temp_1;
	GOTO		22;
	ADDRESS	self,	stat_w9_id,	temp_1;
	STOREP_F	wid,	temp_1;
	GOTO		19;
	EQ_F		idx,	TRUE,	temp_1;
	IF		temp_1,	-28;
	EQ_F		idx,	FL_SWIM,	temp_1;
	IF		temp_1,	-27;
	EQ_F		idx,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-26;
	EQ_F		idx,	MOVETYPE_STEP,	temp_1;
	IF		temp_1,	-25;
	EQ_F		idx,	MOVETYPE_FLY,	temp_1;
	IF		temp_1,	-24;
	EQ_F		idx,	MOVETYPE_TOSS,	temp_1;
	IF		temp_1,	-23;
	EQ_F		idx,	MOVETYPE_PUSH,	temp_1;
	IF		temp_1,	-22;
	EQ_F		idx,	FL_CLIENT,	temp_1;
	IF		temp_1,	-21;
	EQ_F		idx,	MOVETYPE_FLYMISSILE,	temp_1;
	IF		temp_1,	-20;
	ADD_F		idx,	TRUE,	idx;
	INDIRECT_E	e,	w_slot,	e;
	GOTO		-51;
	DONE;
}

float(entity piece) csqc_updateCompStat = asm
{
local float perc;
local float temp_1;
local float temp_3;
	IFNOT		piece,	11;
	INDIRECT_S	piece,	classname,	temp_1;
	NE_S		temp_1,	"world",	temp_1;
	IFNOT		temp_1,	8;
	INDIRECT_F	piece,	health,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_F	piece,	health,	temp_1;
	INDIRECT_F	piece,	max_health,	temp_3;
	DIV_F		temp_1,	temp_3,	temp_1;
	MUL_F		temp_1,	STAT_PLR_ANG_X,	perc;
	RETURN	perc;
	RETURN	FALSE;
	DONE;
}

void() cycleWeaponGroup = asm
{
	DONE;
}

void() cycleWeaponGroupReverse = asm
{
	DONE;
}

void () switchFireMode;
void() switchFireMode = asm
{
	DONE;
}

void () selectTarget;
void() selectTarget = asm
{
	DONE;
}

void () toggerRadar;
void() toggerRadar = asm
{
	DONE;
}

void() playerAttack = asm
{
local float wgrp;
local float weaponGroup;
local float wep_count;
local entity oself;
local entity wep_chain;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_NOSHOOT,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	STORE_F	FALSE,	weaponGroup;
	INDIRECT_F	self,	button0,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	currentWeaponGroup,	weaponGroup;
	GOTO		21;
	INDIRECT_F	self,	button3,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	w_group1,	temp_1;
	BITOR		weaponGroup,	temp_1,	weaponGroup;
	INDIRECT_F	self,	button4,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	w_group2,	temp_1;
	BITOR		weaponGroup,	temp_1,	weaponGroup;
	INDIRECT_F	self,	button5,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	w_group3,	temp_1;
	BITOR		weaponGroup,	temp_1,	weaponGroup;
	INDIRECT_F	self,	button6,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	w_group4,	temp_1;
	BITOR		weaponGroup,	temp_1,	weaponGroup;
	INDIRECT_F	self,	button7,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	w_group5,	temp_1;
	BITOR		weaponGroup,	temp_1,	weaponGroup;
	STORE_ENT	self,	oself;
	INDIRECT_E	self,	w_slot,	wep_chain;
	INDIRECT_F	wep_chain,	w_group,	wep_count;
	IFNOT		wep_chain,	41;
	INDIRECT_F	wep_chain,	w_group,	wgrp;
	GT		weaponGroup,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	stat_plr_stt,	temp_3;
	EQ_F		temp_3,	MOVETYPE_FLY,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	22;
	BITAND	weaponGroup,	wgrp,	temp_1;
	IFNOT		temp_1,	9;
	INDIRECT_F	wep_chain,	w_state,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	STORE_ENT	wep_chain,	self;
	INDIRECT_FU	self,	w_attack,	temp_1;
	CALL0		temp_1;
	STORE_ENT	oself,	self;
	GOTO		11;
	INDIRECT_F	wep_chain,	w_isburst,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	8;
	INDIRECT_F	wep_chain,	w_state,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	STORE_ENT	wep_chain,	self;
	INDIRECT_FU	self,	w_attack,	temp_1;
	CALL0		temp_1;
	STORE_ENT	oself,	self;
	GOTO		11;
	INDIRECT_F	wep_chain,	w_isburst,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	8;
	INDIRECT_F	wep_chain,	w_state,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	5;
	STORE_ENT	wep_chain,	self;
	INDIRECT_FU	self,	w_attack,	temp_1;
	CALL0		temp_1;
	STORE_ENT	oself,	self;
	INDIRECT_E	wep_chain,	w_slot,	wep_chain;
	GOTO		-40;
	DONE;
}

void() ImpulseCommands = asm
{
local float locked_2932;
local entity e;
local vector temp_0;
local float temp_3;
	INDIRECT_F	self,	impulse,	locked_2932;
	EQ_F		locked_2932,	MOVETYPE_BOUNCE,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	stat_plr_fir,	locked_2932;
	STOREP_F	FL_SWIM,	locked_2932;
	INDIRECT_F	self,	impulse,	locked_2932;
	EQ_F		locked_2932,	MOVETYPE_BOUNCEMISSILE,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	stat_plr_fir,	locked_2932;
	STOREP_F	MOVETYPE_WALK,	locked_2932;
	ADDRESS	self,	currentWeaponGroup,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	INDIRECT_F	self,	impulse,	locked_2932;
	EQ_F		locked_2932,	IMP_FSINGLE,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	stat_plr_fir,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	INDIRECT_F	self,	impulse,	locked_2932;
	EQ_F		locked_2932,	MOVETYPE_FLY,	locked_2932;
	IFNOT		locked_2932,	12;
	ADDRESS	self,	state_1,	locked_2932;
	INDIRECT_F	self,	state_1,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	state_1,	locked_2932;
	LT		locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	state_1,	locked_2932;
	STOREP_F	MOVETYPE_FLY,	locked_2932;
	INDIRECT_F	self,	state_1,	parm0_x;
	CALL1		mpls_groupFire;
	INDIRECT_F	self,	impulse,	locked_2932;
	EQ_F		locked_2932,	MOVETYPE_STEP,	locked_2932;
	IFNOT		locked_2932,	12;
	ADDRESS	self,	state_1,	locked_2932;
	INDIRECT_F	self,	state_1,	temp_3;
	ADD_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	state_1,	locked_2932;
	GT		locked_2932,	MOVETYPE_FLY,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	state_1,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	INDIRECT_F	self,	state_1,	parm0_x;
	CALL1		mpls_groupFire;
	INDIRECT_F	self,	stat_plr_fir,	locked_2932;
	EQ_F		locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	1;
	INDIRECT_F	self,	stat_plr_fir,	locked_2932;
	EQ_F		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	1;
	INDIRECT_F	self,	impulse,	locked_2932;
	EQ_F		locked_2932,	MOVETYPE_PUSH,	locked_2932;
	IFNOT		locked_2932,	2;
	CALL0		server_getTarget;
	INDIRECT_F	self,	impulse,	locked_2932;
	EQ_F		locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	21;
	INDIRECT_F	self,	stat_rdr_mode,	locked_2932;
	EQ_F		locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	7;
	ADDRESS	self,	stat_rdr_mode,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	ADDRESS	self,	stat_rdr_rng,	locked_2932;
	INDIRECT_F	self,	radar_range,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	GOTO		12;
	ADDRESS	self,	stat_rdr_mode,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	INDIRECT_F	self,	stat_rdr_rng,	locked_2932;
	INDIRECT_F	self,	radar_range,	temp_3;
	MUL_F		temp_3,	FL_SWIM,	temp_3;
	NE_F		locked_2932,	temp_3,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	stat_rdr_rng,	locked_2932;
	INDIRECT_F	self,	radar_range,	temp_3;
	MUL_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_F	self,	impulse,	locked_2932;
	EQ_F		locked_2932,	IMP_REPAIR,	locked_2932;
	IFNOT		locked_2932,	7;
	STORE_F	self,	parm0_x;
	CALL1		util_getMechHpAverage;
	LT		return_x,	TRUE,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	repair_request,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	INDIRECT_F	self,	impulse,	locked_2932;
	EQ_F		locked_2932,	SVC_INTERMISSION,	locked_2932;
	IFNOT		locked_2932,	16;
	STORE_F	world,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"map_terrain_model",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	e;
	IFNOT		e,	10;
	ADDRESS	e,	angles_y,	locked_2932;
	INDIRECT_F	e,	angles_y,	temp_3;
	ADD_F		temp_3,	MOVETYPE_BOUNCE,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_V	e,	angles_x,	temp_0;
	STORE_F	"terrain angles",	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		cons_logAVector;
	INDIRECT_F	self,	impulse,	locked_2932;
	EQ_F		locked_2932,	SVC_FINALE,	locked_2932;
	IFNOT		locked_2932,	16;
	STORE_F	world,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	"map_terrain_model",	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	e;
	IFNOT		e,	10;
	ADDRESS	e,	angles_y,	locked_2932;
	INDIRECT_F	e,	angles_y,	temp_3;
	SUB_F		temp_3,	MOVETYPE_BOUNCE,	parm0_x;
	CALL1		anglemod;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_V	e,	angles_x,	temp_0;
	STORE_F	"terrain angles",	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		cons_logAVector;
	ADDRESS	self,	impulse,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	DONE;
}

void() ButtonCommands = asm
{
local float locked_896;
local float locked_916;
local float locked_2932;
local float temp_6;
	INDIRECT_F	self,	button8,	locked_2932;
	IFNOT		locked_2932,	27;
	INDIRECT_F	self,	en_cur,	locked_2932;
	GT		locked_2932,	FALSE,	locked_2932;
	IFNOT		locked_2932,	24;
	INDIRECT_F	self,	stat_plr_stt,	locked_2932;
	EQ_F		locked_2932,	MOVETYPE_FLY,	locked_2932;
	IFNOT		locked_2932,	21;
	ADDRESS	self,	stat_plr_stt,	locked_2932;
	STOREP_F	MOVETYPE_PUSH,	locked_2932;
	INDIRECT_F	self,	m_fspeed,	locked_2932;
	INDIRECT_F	self,	m_maccel,	locked_916;
	MUL_F		locked_2932,	locked_916,	locked_2932;
	INDIRECT_F	self,	m_sspeed,	locked_916;
	INDIRECT_F	self,	m_maccel,	locked_896;
	MUL_F		locked_916,	locked_896,	locked_916;
	INDIRECT_F	self,	m_bspeed,	locked_896;
	INDIRECT_F	self,	m_maccel,	temp_6;
	MUL_F		locked_896,	temp_6,	locked_896;
	INDIRECT_F	self,	m_maccel,	parm0_x;
	CALL1		ftos;
	INDIRECT_S	self,	m_rollangle,	temp_6;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	STORE_F	locked_896,	parm2_x;
	STORE_F	return_x,	parm3_x;
	STORE_F	temp_6,	parm4_x;
	CALL5		client_update_moveSpeed;
	INDIRECT_F	self,	button9,	locked_2932;
	IFNOT		locked_2932,	8;
	INDIRECT_F	self,	viewzoom,	locked_2932;
	GT		locked_2932,	0.250000,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	viewzoom,	locked_2932;
	INDIRECT_F	self,	viewzoom,	locked_916;
	SUB_F		locked_916,	0.250000,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	DONE;
}

void() mpls_singleFire = asm
{
	DONE;
}

void(float selector) mpls_groupFire = asm
{
local float temp_1;
local float temp_3;
	GOTO		56;
	ADDRESS	self,	state_1,	temp_1;
	STOREP_F	TRUE,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	"[Weapon Group 1]",	parm1_x;
	CALL2		centerprint;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	INDIRECT_F	self,	w_group1,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		55;
	ADDRESS	self,	state_1,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	"[Weapon Group 2]",	parm1_x;
	CALL2		centerprint;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	INDIRECT_F	self,	w_group2,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		44;
	ADDRESS	self,	state_1,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	"[Weapon Group 3]",	parm1_x;
	CALL2		centerprint;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	INDIRECT_F	self,	w_group3,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		33;
	ADDRESS	self,	state_1,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	"[Weapon Group 4]",	parm1_x;
	CALL2		centerprint;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	INDIRECT_F	self,	w_group4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		22;
	ADDRESS	self,	state_1,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	"[Weapon Group 5]",	parm1_x;
	CALL2		centerprint;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	INDIRECT_F	self,	w_group5,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		11;
	EQ_F		selector,	TRUE,	temp_1;
	IF		temp_1,	-56;
	EQ_F		selector,	FL_SWIM,	temp_1;
	IF		temp_1,	-47;
	EQ_F		selector,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-38;
	EQ_F		selector,	MOVETYPE_STEP,	temp_1;
	IF		temp_1,	-29;
	EQ_F		selector,	MOVETYPE_FLY,	temp_1;
	IF		temp_1,	-20;
	DONE;
}

void(entity wep) ctrl_wpn_think = asm
{
local entity oself;
local float temp_1;
	STORE_ENT	self,	oself;
	STORE_ENT	wep,	self;
	INDIRECT_F	self,	deadflag,	temp_1;
	GE		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	STORE_ENT	oself,	self;
	RETURN	offset_0;
	INDIRECT_F	self,	deadflag,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	3;
	STORE_ENT	oself,	self;
	RETURN	offset_0;
	INDIRECT_FU	self,	w_think,	temp_1;
	IFNOT		temp_1,	17;
	INDIRECT_F	oself,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_F	self,	w_isready,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_F	self,	stat_wep_rel,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		ctrl_weapon_isReady;
	GOTO		5;
	INDIRECT_F	self,	stat_wep_rel,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		ctrl_weapon_isReload;
	INDIRECT_FU	self,	w_think,	temp_1;
	CALL0		temp_1;
	STORE_ENT	oself,	self;
	DONE;
}

void() ctrl_wpn_think_clip = asm
{
	DONE;
}

void() ctrl_wpn_think_ene = asm
{
	DONE;
}

void(entity wep, float wstate) ctrl_weapon_addState = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	wep,	owner,	temp_1;
	INDIRECT_F	temp_1,	stat_wep_state,	temp_1;
	BITAND	temp_1,	wstate,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	7;
	INDIRECT_E	wep,	owner,	temp_1;
	ADDRESS	temp_1,	stat_wep_state,	temp_1;
	INDIRECT_E	wep,	owner,	temp_3;
	INDIRECT_F	temp_3,	stat_wep_state,	temp_3;
	BITOR		temp_3,	wstate,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void(entity wep, float wstate) ctrl_weapon_subState = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_E	wep,	owner,	temp_1;
	ADDRESS	temp_1,	stat_wep_state,	temp_1;
	INDIRECT_E	wep,	owner,	temp_3;
	INDIRECT_F	temp_3,	stat_wep_state,	temp_3;
	INDIRECT_E	wep,	owner,	temp_4;
	INDIRECT_F	temp_4,	stat_wep_state,	temp_4;
	BITAND	temp_4,	wstate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void(entity wep, float state1, float state2) ctrl_weapon_clearState = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_E	wep,	owner,	temp_1;
	ADDRESS	temp_1,	stat_wep_state,	temp_1;
	INDIRECT_E	wep,	owner,	temp_3;
	INDIRECT_F	temp_3,	stat_wep_state,	temp_3;
	INDIRECT_E	wep,	owner,	temp_4;
	INDIRECT_F	temp_4,	stat_wep_state,	temp_4;
	BITAND	temp_4,	state1,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	wep,	owner,	temp_1;
	ADDRESS	temp_1,	stat_wep_state,	temp_1;
	INDIRECT_E	wep,	owner,	temp_3;
	INDIRECT_F	temp_3,	stat_wep_state,	temp_3;
	INDIRECT_E	wep,	owner,	temp_4;
	INDIRECT_F	temp_4,	stat_wep_state,	temp_4;
	BITAND	temp_4,	state2,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void(entity wep, float wstate) ctrl_weapon_isReload = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_E	wep,	owner,	temp_1;
	INDIRECT_F	temp_1,	stat_wep_rel,	temp_1;
	BITAND	temp_1,	wstate,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	7;
	INDIRECT_E	wep,	owner,	temp_1;
	ADDRESS	temp_1,	stat_wep_rel,	temp_1;
	INDIRECT_E	wep,	owner,	temp_3;
	INDIRECT_F	temp_3,	stat_wep_rel,	temp_3;
	BITOR		temp_3,	wstate,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void(entity wep, float wstate) ctrl_weapon_isReady = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_E	wep,	owner,	temp_1;
	ADDRESS	temp_1,	stat_wep_rel,	temp_1;
	INDIRECT_E	wep,	owner,	temp_3;
	INDIRECT_F	temp_3,	stat_wep_rel,	temp_3;
	INDIRECT_E	wep,	owner,	temp_4;
	INDIRECT_F	temp_4,	stat_wep_rel,	temp_4;
	BITAND	temp_4,	wstate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ctrl_die_weapon = asm
{
local entity oself;
local vector temp_0;
local float temp_1;
local float temp_3;
local float temp_4;
local float temp_6;
	INDIRECT_F	self,	deadflag,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	53;
	STORE_ENT	self,	oself;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	newmis,	self;
	INDIRECT_V	oself,	origin_x,	temp_0;
	STORE_F	newmis,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	CALL0		BecomeExplosion;
	STORE_ENT	oself,	self;
	INDIRECT_F	oself,	currentWeaponGroup,	temp_1;
	INDIRECT_F	self,	w_group,	temp_3;
	BITAND	temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	10;
	ADDRESS	oself,	currentWeaponGroup,	temp_1;
	INDIRECT_F	oself,	currentWeaponGroup,	temp_3;
	INDIRECT_F	oself,	currentWeaponGroup,	temp_4;
	INDIRECT_F	self,	w_group,	temp_6;
	BITAND	temp_4,	temp_6,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_group,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_F	self,	state_1,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		ctrl_weapon_subState;
	INDIRECT_F	self,	state_2,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		ctrl_weapon_addState;
	GOTO		2;
	CALL0		ai_wep_calcranges;
	ADDRESS	self,	w_attack,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	effects,	temp_1;
	STOREP_F	FL_INWATER,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	INDIRECT_F	self,	p_dmgtype,	temp_1;
	BITAND	temp_1,	FL_NOTARGET,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_FU	self,	unit_wep1,	temp_1;
	CALL0		temp_1;
	DONE;
}

void() ctrl_updateCenterTorso = asm
{
local vector v1;
local entity cam;
local float rate;
local float my;
local float mx;
local float diff;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	29;
	INDIRECT_F	self,	laser_sight_timer,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	25;
	INDIRECT_V	self,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_F	cam,	c_ofs_x,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	cam,	c_ofs_y,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	cam,	c_ofs_z,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	v1;
	MUL_VF	v_forward,	DAT_BLD_H_SM_RADAR_RADAR_RANGE,	temp_0;
	ADD_V		v1,	temp_0,	temp_0;
	STORE_V	v1,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	ADDRESS	self,	laser_sight_org_x,	temp_0_x;
	STOREP_V	trace_endpos_x,	temp_0;
	ADDRESS	self,	laser_sight_timer,	temp_1;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		25;
	INDIRECT_V	self,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_F	cam,	c_ofs_x,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	cam,	c_ofs_y,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	temp_0;
	INDIRECT_F	cam,	c_ofs_z,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_2;
	ADD_V		temp_0,	temp_2,	v1;
	MUL_VF	v_forward,	DAT_BLD_H_SM_RADAR_RADAR_RANGE,	temp_0;
	ADD_V		v1,	temp_0,	temp_0;
	STORE_V	v1,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	ADDRESS	self,	laser_sight_org_x,	temp_0_x;
	STOREP_V	trace_endpos_x,	temp_0;
	ADDRESS	self,	laser_sight_timer,	temp_1;
	ADD_F		time,	ARM_LT_MOD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	count4,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	59;
	ADDRESS	self,	count4,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_1;
	GE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	13;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_max,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	24;
	INDIRECT_F	self,	sh_hit,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	21;
	INDIRECT_F	self,	en_cur,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	18;
	ADDRESS	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_cur,	temp_3;
	INDIRECT_F	self,	sh_rate,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_3;
	INDIRECT_F	self,	sh_rate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_1;
	LT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	56;
	INDIRECT_F	self,	movement_x,	mx;
	LT		mx,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	MUL_F		mx,	CONTENT_EMPTY,	mx;
	INDIRECT_F	self,	movement_y,	my;
	LT		my,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	MUL_F		my,	CONTENT_EMPTY,	my;
	NE_F		my,	FALSE,	temp_1;
	IF		temp_1,	2;
	NE_F		mx,	FALSE,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_F	self,	spreadDefault_z,	rate;
	INDIRECT_F	self,	stat_rdr_mode,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	3;
	MUL_F		rate,	0.500000,	temp_1;
	ADD_F		rate,	temp_1,	rate;
	INDIRECT_F	self,	accuracyMod,	temp_1;
	SUB_F		rate,	temp_1,	rate;
	ADDRESS	self,	accuracy,	temp_1;
	INDIRECT_F	self,	accuracy,	temp_3;
	ADD_F		temp_3,	rate,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	accuracy,	temp_1;
	INDIRECT_F	self,	spreadDefault_y,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	accuracy,	temp_1;
	INDIRECT_F	self,	spreadDefault_y,	temp_3;
	STOREP_F	temp_3,	temp_1;
	EQ_F		my,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	EQ_F		mx,	FALSE,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	19;
	INDIRECT_F	self,	spreadDefault_z,	rate;
	INDIRECT_F	self,	stat_rdr_mode,	temp_1;
	IFNOT		temp_1,	3;
	MUL_F		rate,	0.250000,	temp_1;
	ADD_F		rate,	temp_1,	rate;
	INDIRECT_F	self,	accuracyMod,	temp_1;
	ADD_F		rate,	temp_1,	rate;
	ADDRESS	self,	accuracy,	temp_1;
	INDIRECT_F	self,	accuracy,	temp_3;
	SUB_F		temp_3,	rate,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	accuracy,	temp_1;
	INDIRECT_F	self,	spreadDefault_x,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	accuracy,	temp_1;
	INDIRECT_F	self,	spreadDefault_x,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ctrl_die_comp = asm
{
local float locked_2939;
local entity c;
local float compType;
local vector pvel;
local entity tmp;
local entity oself;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_F	self,	deadflag,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	139;
	INDIRECT_F	self,	comp_id,	compType;
	STORE_ENT	self,	oself;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_V	temp_1,	velocity_x,	pvel;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	newmis,	self;
	INDIRECT_V	oself,	origin_x,	locked_2939;
	STORE_F	newmis,	parm0_x;
	STORE_V	locked_2939,	parm1;
	CALL2		setorigin;
	CALL0		BecomeExplosion;
	STORE_ENT	oself,	self;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	newmis,	self;
	ADDRESS	self,	angles_x,	locked_2939;
	INDIRECT_V	oself,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	GT		pvel_x,	FALSE,	temp_1;
	IF		temp_1,	2;
	GT		pvel_y,	FALSE,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IF		temp_1,	2;
	GT		pvel_z,	FALSE,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	19;
	ADDRESS	self,	velocity_x,	locked_2939;
	STORE_F	STAT_PLR_ANG_X,	parm0_x;
	CALL1		VelocityForDamage;
	ADD_V		pvel,	return,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	avelocity_x,	temp_1;
	CALL0		random;
	MUL_F		return_x,	DAT_PRJ_SFGA_RAD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	avelocity_y,	temp_1;
	CALL0		random;
	MUL_F		return_x,	DAT_PRJ_SFGA_RAD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	avelocity_z,	temp_1;
	CALL0		random;
	MUL_F		return_x,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		17;
	ADDRESS	self,	velocity_x,	locked_2939;
	STORE_F	STAT_PLR_ANG_X,	parm0_x;
	CALL1		VelocityForDamage;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	avelocity_x,	temp_1;
	CALL0		random;
	MUL_F		return_x,	DAT_PRJ_SFGA_RAD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	avelocity_y,	temp_1;
	CALL0		random;
	MUL_F		return_x,	DAT_PRJ_SFGA_RAD,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	avelocity_z,	temp_1;
	CALL0		random;
	MUL_F		return_x,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	self,	owner,	temp_1;
	INDIRECT_E	oself,	owner,	temp_3;
	STOREP_ENT	temp_3,	temp_1;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_FLY,	parm1_x;
	STORE_F	MOVETYPE_BOUNCE,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	oself,	model,	temp_1;
	INDIRECT_E	oself,	owner,	temp_3;
	INDIRECT_F	temp_3,	mskin,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	'-3.000000 -3.000000 -3.000000',	parm1;
	STORE_V	'3.000000 3.000000 3.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	oself,	origin_x,	locked_2939;
	STORE_F	self,	parm0_x;
	STORE_V	locked_2939,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	touch_mechPiece,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_ENT	oself,	self;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	effects,	temp_1;
	STOREP_F	FL_INWATER,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	locked_2939;
	STORE_F	self,	parm0_x;
	STORE_V	locked_2939,	parm1;
	CALL2		setorigin;
	EQ_F		compType,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_E	temp_1,	e_arm_l,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		killed;
	GOTO		8;
	EQ_F		compType,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_E	temp_1,	e_arm_r,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		killed;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_E	temp_1,	w_slot,	c;
	IFNOT		c,	10;
	INDIRECT_F	c,	c_parent,	temp_1;
	EQ_F		temp_1,	compType,	temp_1;
	IFNOT		temp_1,	5;
	STORE_F	c,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		killed;
	INDIRECT_E	c,	w_slot,	c;
	GOTO		-9;
	ADDRESS	self,	health,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	1;
	DONE;
}

void() touch_mech = asm
{
local float dif;
local vector temp_0;
local float temp_1;
local float temp_3;
	EQ_E		other,	world,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_MONSTER,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	110;
	INDIRECT_F	self,	vec_size,	temp_1;
	INDIRECT_F	other,	vec_size,	temp_3;
	SUB_F		temp_1,	temp_3,	dif;
	EQ_F		dif,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	27;
	INDIRECT_F	other,	data_type,	temp_1;
	EQ_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_F	other,	max_health,	temp_1;
	INDIRECT_V	other,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	GOTO		12;
	INDIRECT_F	self,	max_health,	temp_1;
	MUL_F		temp_1,	ARM_HV_MOD,	temp_1;
	INDIRECT_V	other,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	GOTO		79;
	EQ_F		dif,	TRUE,	temp_1;
	IFNOT		temp_1,	27;
	INDIRECT_F	other,	data_type,	temp_1;
	EQ_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_F	other,	max_health,	temp_1;
	INDIRECT_V	other,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	GOTO		12;
	INDIRECT_F	self,	max_health,	temp_1;
	MUL_F		temp_1,	ARM_HV_MOD,	temp_1;
	INDIRECT_V	other,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	GOTO		51;
	EQ_F		dif,	FALSE,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	other,	data_type,	temp_1;
	EQ_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_F	other,	max_health,	temp_1;
	DIV_F		temp_1,	MOVETYPE_STEP,	temp_1;
	INDIRECT_V	other,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	GOTO		34;
	EQ_F		dif,	CONTENT_EMPTY,	temp_1;
	IFNOT		temp_1,	16;
	INDIRECT_F	other,	data_type,	temp_1;
	NE_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_F	other,	max_health,	temp_1;
	DIV_F		temp_1,	SHVBAL_EFFRAM_PERCENTAGE,	temp_1;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_F	other,	parm1_x;
	STORE_F	other,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	GOTO		17;
	EQ_F		dif,	CONTENT_SOLID,	temp_1;
	IFNOT		temp_1,	15;
	INDIRECT_F	other,	data_type,	temp_1;
	NE_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_F	other,	max_health,	temp_1;
	DIV_F		temp_1,	FL_SWIM,	temp_1;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_F	other,	parm1_x;
	STORE_F	other,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	STORE_V	temp_0,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	DONE;
}

void() touch_mechPiece = asm
{
local float temp_1;
	EQ_E		other,	world,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_S	other,	classname,	temp_1;
	EQ_S		temp_1,	MECH_PIECE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	CALL0		BecomeExplosion;
	DONE;
}

void() ctrl_updateLegs = asm
{
local float locked_2939;
local vector m;
local float vertic;
local vector angl;
local vector dn;
local vector adj;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	movement_x,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	movement_y,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	21;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_V	temp_1,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_V	temp_1,	origin_x,	locked_2939;
	INDIRECT_F	self,	c_ofs_y,	temp_1;
	MUL_VF	v_up,	temp_1,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_F	self,	c_ofs_x,	temp_1;
	MUL_VF	v_right,	temp_1,	temp_2;
	ADD_V		locked_2939,	temp_2,	locked_2939;
	INDIRECT_F	self,	c_ofs_z,	temp_1;
	MUL_VF	v_forward,	temp_1,	temp_2;
	ADD_V		locked_2939,	temp_2,	adj;
	STORE_F	self,	parm0_x;
	STORE_V	adj,	parm1;
	CALL2		setorigin;
	GOTO		23;
	INDIRECT_F	self,	movetype,	temp_1;
	NE_F		temp_1,	MOVETYPE_FOLLOW,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_FOLLOW,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	14;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_V	temp_1,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_V	temp_1,	movement_x,	m;
	MUL_F		m_y,	CONTENT_EMPTY,	m_y;
	ADDRESS	self,	angles_x,	locked_2939;
	STORE_V	m,	parm0;
	CALL1		vectoangles;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	v_angle_x,	locked_2939;
	INDIRECT_V	self,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	DONE;
}

void() ctrl_dieLegs = asm
{
local float f3;
local float f2;
local float f1;
local vector v2;
local vector v1;
local entity this;
local vector temp_0;
local float temp_1;
local float temp_3;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	STORE_ENT	self,	this;
	INDIRECT_E	this,	owner,	temp_1;
	INDIRECT_V	temp_1,	mins_x,	v1;
	INDIRECT_E	this,	owner,	temp_1;
	INDIRECT_V	temp_1,	maxs_x,	v2;
	DIV_F		v1_z,	FL_SWIM,	temp_1;
	SUB_F		v1_z,	temp_1,	v1_z;
	DIV_F		v2_z,	FL_SWIM,	temp_1;
	SUB_F		v2_z,	temp_1,	v2_z;
	DIV_F		v1_x,	FL_SWIM,	temp_1;
	SUB_F		v1_x,	temp_1,	v1_y;
	STORE_F	v1_y,	v1_x;
	DIV_F		v2_x,	FL_SWIM,	temp_1;
	SUB_F		v2_x,	temp_1,	v2_y;
	STORE_F	v2_y,	v2_x;
	STORE_F	self,	parm0_x;
	STORE_V	v1,	parm1;
	STORE_V	v2,	parm2;
	CALL3		setsize;
	INDIRECT_S	this,	model,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		setmodel;
	INDIRECT_V	this,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	frame,	temp_1;
	INDIRECT_F	this,	walkframe,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	touch_mechPiece,	temp_1;
	CALL0		leg_die1;
	STORE_ENT	this,	self;
	DONE;
}

void() ctrl_updateTurret = asm
{
local float diff;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_F	self,	en_cur,	temp_1;
	GE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	13;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_max,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	24;
	INDIRECT_F	self,	sh_hit,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	21;
	INDIRECT_F	self,	en_cur,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	18;
	ADDRESS	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_cur,	temp_3;
	INDIRECT_F	self,	sh_rate,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_3;
	INDIRECT_F	self,	sh_rate,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	sh_cur,	temp_1;
	INDIRECT_F	self,	sh_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_1;
	LT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		8;
	INDIRECT_F	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_max,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() building_die = asm
{
local float temp_1;
local float temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	takedamage,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	POWERUP_DEBUG,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	BecomeExplosion,	temp_1;
	DONE;
}

.float hit_z;
entity multi_ent;
float multi_damage;
void () ClearMultiDamage;
void () ApplyMultiDamage;
void (entity, float) AddMultiDamage;
void () W_Precache;
vector () wall_velocity;
void (vector, vector) SpawnMeatSpray;
void (vector, vector, float) SpawnBlood;
void (float) spawn_touchblood;
void (vector, vector) SpawnChunk;
void (float, vector) TraceAttack;
void (float, vector, vector) FireBullets;
void (vector, vector, entity, float) LightningDamage;
void () spike_touch;
void () superspike_touch;
void (vector, vector) launch_spike;
void () W_FireAxe;
void () W_FireShotgun;
void () W_FireSuperShotgun;
void () W_FireLightning;
void () GrenadeExplode;
void () GrenadeTouch;
void () W_FireGrenade;
void () W_FireRocket;
void () W_FireSuperSpikes;
void (float) W_FireSpikes;
vector(float dm) VelocityForDamage = asm
{
local vector v;
local vector temp_0;
local float temp_1;
	CALL0		crandom;
	MUL_F		STAT_PLR_ANG_X,	return_x,	v_x;
	CALL0		crandom;
	MUL_F		STAT_PLR_ANG_X,	return_x,	v_y;
	CALL0		random;
	MUL_F		STAT_PLR_ANG_X,	return_x,	temp_1;
	ADD_F		DAT_PRJ_QRFL_VELOCITY,	temp_1,	v_z;
	GT		dm,	-50.000000,	temp_1;
	IFNOT		temp_1,	3;
	MUL_VF	v,	DAT_MNT_SHIELD_RATE,	v;
	GOTO		6;
	GT		dm,	-200.000000,	temp_1;
	IFNOT		temp_1,	3;
	MUL_VF	v,	FL_SWIM,	v;
	GOTO		2;
	MUL_VF	v,	MOVETYPE_BOUNCE,	v;
	RETURN	v_x;
	DONE;
}

void(vector org, vector vel) SpawnMeatSpray = asm
{
local entity mpuff;
local entity missile;
local vector temp_0;
local float temp_1;
local float temp_3;
local float temp_4;
	CALL0		spawn;
	STORE_ENT	return_x,	missile;
	ADDRESS	missile,	owner,	temp_1;
	STOREP_ENT	self,	temp_1;
	ADDRESS	missile,	movetype,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	missile,	solid,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	ADDRESS	missile,	velocity_x,	temp_0_x;
	STOREP_V	vel_x,	temp_0;
	ADDRESS	missile,	velocity_z,	temp_1;
	INDIRECT_F	missile,	velocity_z,	temp_3;
	ADD_F		temp_3,	DAT_PAC_DMG,	temp_3;
	CALL0		random;
	MUL_F		TE_BLOOD,	return_x,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	missile,	avelocity_x,	temp_0_x;
	STOREP_V	'3000.000000 1000.000000 2000.000000',	temp_0;
	ADDRESS	missile,	nextthink,	temp_1;
	ADD_F		time,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	missile,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	STORE_F	missile,	parm0_x;
	STORE_F	"progs/zom_gib.mdl",	parm1_x;
	CALL2		setmodel;
	STORE_F	missile,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	STORE_F	missile,	parm0_x;
	STORE_V	org,	parm1;
	CALL2		setorigin;
	DONE;
}

void(vector org, vector vel, float damage) SpawnBlood = asm
{
local vector temp_0;
local float temp_1;
	MUL_VF	vel,	0.100000,	temp_0;
	MUL_F		damage,	FL_SWIM,	temp_1;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	TE_CUSTOMFLASH,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	CALL4		particle;
	DONE;
}

void(float damage) spawn_touchblood = asm
{
local vector vel;
local vector temp_0;
local vector temp_2;
	CALL0		wall_velocity;
	MUL_VF	return,	DAT_LATC_RL_RATE,	vel;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	vel,	POWERUP_DEBUG,	temp_2;
	ADD_V		temp_0,	temp_2,	parm0;
	STORE_V	vel,	parm1;
	STORE_F	damage,	parm2_x;
	CALL3		SpawnBlood;
	DONE;
}

void(vector org, vector vel) SpawnChunk = asm
{
local vector temp_0;
	MUL_VF	vel,	0.020000,	temp_0;
	STORE_V	org,	parm0;
	STORE_V	temp_0,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	MOVETYPE_BOUNCE,	parm3_x;
	CALL4		particle;
	DONE;
}

void() BecomeExplosion = asm
{
local vector temp_0;
local float temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	"sound/fx_boom.ogg",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	velocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	"progs/s_explod.spr",	parm1_x;
	CALL2		setmodel;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	FALSE,	temp_1;
	CALL0		s_explode1;
	DONE;
}

void () q1_precache_world;
void() q1_precache_world = asm
{
	STORE_F	"progs.dat",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx.wad",	parm0_x;
	CALL1		precache_file;
	STORE_F	"quake.rc",	parm0_x;
	CALL1		precache_file;
	STORE_F	"default.cfg",	parm0_x;
	CALL1		precache_file;
	STORE_F	"end1.bin",	parm0_x;
	CALL1		precache_file;
	STORE_F	"end2.bin",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"demo1.dem",	parm0_x;
	CALL1		precache_file;
	STORE_F	"demo2.dem",	parm0_x;
	CALL1		precache_file;
	STORE_F	"demo3.dem",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/palette.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/colormap.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/pop.lmp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"gfx/complete.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/inter.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/ranking.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/vidmodes.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/finale.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/conback.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/qplaque.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/menudot1.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/menudot2.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/menudot3.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/menudot4.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/menudot5.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/menudot6.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/menuplyr.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/bigbox.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/dim_modm.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/dim_drct.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/dim_ipx.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/dim_tcp.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/dim_mult.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/mainmenu.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/box_tl.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/box_tm.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/box_tr.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/box_ml.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/box_mm.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/box_mm2.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/box_mr.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/box_bl.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/box_bm.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/box_br.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/sp_menu.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/ttl_sgl.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/ttl_main.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/ttl_cstm.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/mp_menu.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/netmen1.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/netmen2.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/netmen3.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/netmen4.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/netmen5.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/sell.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/help0.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/help1.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/help2.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/help3.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/help4.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/help5.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/pause.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/loading.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/p_option.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/p_load.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/p_save.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/p_multi.lmp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"misc/menu1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/menu2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/menu3.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"ambience/water1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"ambience/wind2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"maps/e1m1.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"maps/e1m2.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"maps/e1m3.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"maps/e1m4.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"maps/e1m5.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"maps/e1m6.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"maps/e1m7.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"maps/e1m8.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"gfx/pop.lmp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e2m1.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e2m2.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e2m3.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e2m4.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e2m5.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e2m6.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e2m7.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e3m1.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e3m2.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e3m3.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e3m4.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e3m5.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e3m6.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e3m7.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e4m1.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e4m2.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e4m3.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e4m4.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e4m5.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e4m6.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e4m7.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/e4m8.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/end.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/dm1.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/dm2.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/dm3.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/dm4.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/dm5.bsp",	parm0_x;
	CALL1		precache_file2;
	STORE_F	"maps/dm6.bsp",	parm0_x;
	CALL1		precache_file2;
	DONE;
}

void () q1_precache_sound;
void() q1_precache_sound = asm
{
	STORE_F	"demon/dland2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/h2ohit1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"items/itembk2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/plyrjmp8.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/land.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/land2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/drown1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/drown2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/gasp1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/gasp2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/h2odeath.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/talk.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/teledth1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/r_tele1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/r_tele2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/r_tele3.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/r_tele4.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/r_tele5.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"weapons/lock4.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"weapons/pkup.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"items/armor1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"weapons/lhit.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"weapons/lstart.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"items/damage3.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/power.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/gib.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/udeath.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/tornoff2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/pain1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/pain2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/pain3.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/pain4.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/pain5.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/pain6.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/death1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/death2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/death3.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/death4.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/death5.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"weapons/ax1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/axhit1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/axhit2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/h2ojump.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/slimbrn2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/inh2o.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/inlava.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/outwater.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/lburn1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"player/lburn2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/water1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/water2.wav",	parm0_x;
	CALL1		precache_sound;
	DONE;
}

void () q1_precache_models;
void() q1_precache_models = asm
{
	STORE_F	"progs/s_explod.spr",	parm0_x;
	CALL1		precache_model;
	STORE_F	"progs/lavaball.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	"progs/missile.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	"progs/grenade.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	"progs/spike.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	"progs/s_spike.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	"progs/v_light.mdl",	parm0_x;
	CALL1		precache_model;
	DONE;
}

void () mh_precache_sound;
void() mh_precache_sound = asm
{
	STORE_F	"sound/weapons/mis_fire.ogg",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"sound/weapons/atc_fire.ogg",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"sound/weapons/qrfl_fire.ogg",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"sound/weapons/emp_fire.ogg",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"sound/weapons/laser_fire.ogg",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"sound/weapons/pac_fire.ogg",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"sound/weapons/esr_fire.ogg",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"sound/mech_stomp.ogg",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"sound/fx_boom.ogg",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"sound/fx_shieldhit.ogg",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"sound/fx_armorhit.ogg",	parm0_x;
	CALL1		precache_sound;
	DONE;
}

void () mh_precache_models;
void() mh_precache_models = asm
{
	STORE_F	"progs/v_dpshot.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	"models/terrain/t1m3_exp2.obj",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/base_small.obj",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/base_med.obj",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/base_large.obj",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/buildings/mdl_bld_h_hangar_l.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/buildings/mdl_bld_h_repair.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/buildings/mdl_bld_h_power.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/buildings/mdl_bld_h_radar.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/buildings/mdl_bld_h_shield.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/buildings/mdl_bld_h_fuel.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/buildings/mdl_bld_h_ltur.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/buildings/mdl_bld_h_ltur_base.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/testball.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/notl/mdl_blk_cpt.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/notl/mdl_blk_cpt.obj",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/notl/mdl_blk_t_cent.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/notl/mdl_blk_t_left.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/notl/mdl_blk_t_right.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/notl/mdl_blk_legs.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/notl/mdl_blk_l_arm.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/notl/mdl_blk_r_arm.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/ntmk/mdl_mtk_legs.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/ntmk/mdl_mtk_t_cent.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/ntmk/mdl_mtk_t_left.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/ntmk/mdl_mtk_t_right.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/ntmk/mdl_mtk_l_arm.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/ntmk/mdl_mtk_r_arm.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/ntmk/mdl_mtk_cpt.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/mnt/mdl_mnt_legs.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/mnt/mdl_mnt_t_cent.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/mnt/mdl_mnt_t_left.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/mnt/mdl_mnt_t_right.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/mnt/mdl_mnt_l_arm.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/mnt/mdl_mnt_r_arm.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/mechs/mnt/mdl_mnt_cpt.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/vecs/mdl_tank_chas.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/vecs/mdl_tank_tur.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_arh.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_atc.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_emp.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_esr.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_laser.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_lgm.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_mis.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_pac.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_qrf.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_rpc.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_sfga.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_ion.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_flk.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/w_swrm.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/e_atgm.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/e_enbat.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/e_hsem.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/e_recap.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/e_scap.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/weapons/e_lsar.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/proj_emp.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/proj_mis.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/proj/mdl_proj_swrm.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/proj/mdl_proj_lgm.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/proj/mdl_proj_mis.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/proj/mdl_proj_marh.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/proj/mdl_proj_sfga.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/proj/mdl_proj_rpc.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/proj/mdl_proj_qrfl.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/proj/mdl_proj_emp.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/proj/mdl_proj_ion.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"progs/casing.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/fx_shield.md3",	parm0_x;
	CALL1		precache_model;
	STORE_F	"progs/plasmashot.spr32",	parm0_x;
	CALL1		precache_model;
	STORE_F	"progs/muzzleflash.spr32",	parm0_x;
	CALL1		precache_model;
	STORE_F	"q3mdl/muzzle_laser.spr32",	parm0_x;
	CALL1		precache_model;
	STORE_F	"progs/s_explod.spr",	parm0_x;
	CALL1		precache_model;
	STORE_F	"maps/t1m1.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"maps/t1m2.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"maps/start.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"maps/c1m1.bsp",	parm0_x;
	CALL1		precache_file;
	STORE_F	"maps/t1m3.bsp",	parm0_x;
	CALL1		precache_file;
	DONE;
}

void() main = asm
{
	STORE_F	"main function
",	parm0_x;
	CALL1		dprint;
	DONE;
}

void () worldspawn;
void() worldspawn = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	world,	data_idx,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	STORE_ENT	world,	lastspawn;
	CALL0		InitBodyQue;
	STORE_F	"sv_maxspeed",	parm0_x;
	STORE_F	"800",	parm1_x;
	CALL2		cvar_set;
	STORE_F	FALSE,	CLIENTS;
	INDIRECT_V	world,	c_ofs_x,	WINDDIR;
	INDIRECT_F	world,	m_fspeed,	WINDSPEED;
	INDIRECT_V	world,	c_ofs_x,	parm0;
	CALL1		vtos;
	STORE_F	"c_ofs",	parm0_x;
	STORE_F	return_x,	parm1_x;
	STORE_F	"
",	parm2_x;
	CALL3		strcat;
	STORE_F	return_x,	parm0_x;
	CALL1		dprint;
	INDIRECT_S	self,	model,	temp_1;
	EQ_S		temp_1,	"maps/e1m8.bsp",	temp_1;
	IFNOT		temp_1,	5;
	STORE_F	"sv_gravity",	parm0_x;
	STORE_F	"100",	parm1_x;
	CALL2		cvar_set;
	GOTO		4;
	STORE_F	"sv_gravity",	parm0_x;
	STORE_F	"800",	parm1_x;
	CALL2		cvar_set;
	CALL0		q1_precache_sound;
	CALL0		q1_precache_models;
	CALL0		mh_precache_sound;
	CALL0		mh_precache_models;
	CALL0		mh_world_ini;
	STORE_F	FALSE,	parm0_x;
	STORE_F	"m",	parm1_x;
	CALL2		lightstyle;
	STORE_F	TRUE,	parm0_x;
	STORE_F	"mmnmmommommnonmmonqnmmo",	parm1_x;
	CALL2		lightstyle;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	"abcdefghijklmnopqrstuvwxyzyxwvutsrqponmlkjihgfedcba",	parm1_x;
	CALL2		lightstyle;
	STORE_F	MOVETYPE_WALK,	parm0_x;
	STORE_F	"mmmmmaaaaammmmmaaaaaabcdefgabcdefg",	parm1_x;
	CALL2		lightstyle;
	STORE_F	MOVETYPE_STEP,	parm0_x;
	STORE_F	"mamamamamama",	parm1_x;
	CALL2		lightstyle;
	STORE_F	MOVETYPE_FLY,	parm0_x;
	STORE_F	"jklmnopqrstuvwxyzyxwvutsrqponmlkj",	parm1_x;
	CALL2		lightstyle;
	STORE_F	MOVETYPE_TOSS,	parm0_x;
	STORE_F	"nmonqnmomnmomomno",	parm1_x;
	CALL2		lightstyle;
	STORE_F	MOVETYPE_PUSH,	parm0_x;
	STORE_F	"mmmaaaabcdefgmmmmaaaammmaamm",	parm1_x;
	CALL2		lightstyle;
	STORE_F	FL_CLIENT,	parm0_x;
	STORE_F	"mmmaaammmaaammmabcdefaaaammmmabcdefmmmaaaa",	parm1_x;
	CALL2		lightstyle;
	STORE_F	MOVETYPE_FLYMISSILE,	parm0_x;
	STORE_F	"aaaaaaaazzzzzzzz",	parm1_x;
	CALL2		lightstyle;
	STORE_F	MOVETYPE_BOUNCE,	parm0_x;
	STORE_F	"mmamammmmammamamaaamammma",	parm1_x;
	CALL2		lightstyle;
	STORE_F	MOVETYPE_BOUNCEMISSILE,	parm0_x;
	STORE_F	"abcdefghijklmnopqrrqponmlkjihgfedcba",	parm1_x;
	CALL2		lightstyle;
	STORE_F	STAT_TRG_LT_HP,	parm0_x;
	STORE_F	"a",	parm1_x;
	CALL2		lightstyle;
	DONE;
}

void() StartFrame = asm
{
local float temp_1;
	STORE_F	"teamplay",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	teamplay;
	STORE_F	"skill",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	skill;
	ADD_F		framecount,	TRUE,	framecount;
	DONE;
}

entity bodyque_head;
void () bodyque;
void() bodyque = asm
{
	DONE;
}

void() InitBodyQue = asm
{
local entity e;
local float temp_1;
	CALL0		spawn;
	STORE_ENT	return_x,	bodyque_head;
	ADDRESS	bodyque_head,	classname,	temp_1;
	STOREP_S	"bodyque",	temp_1;
	ADDRESS	bodyque_head,	owner,	temp_1;
	CALL0		spawn;
	STOREP_ENT	return_x,	temp_1;
	INDIRECT_E	bodyque_head,	owner,	temp_1;
	ADDRESS	temp_1,	classname,	temp_1;
	STOREP_S	"bodyque",	temp_1;
	INDIRECT_E	bodyque_head,	owner,	temp_1;
	ADDRESS	temp_1,	owner,	temp_1;
	CALL0		spawn;
	STOREP_ENT	return_x,	temp_1;
	INDIRECT_E	bodyque_head,	owner,	temp_1;
	INDIRECT_E	temp_1,	owner,	temp_1;
	ADDRESS	temp_1,	classname,	temp_1;
	STOREP_S	"bodyque",	temp_1;
	INDIRECT_E	bodyque_head,	owner,	temp_1;
	INDIRECT_E	temp_1,	owner,	temp_1;
	ADDRESS	temp_1,	owner,	temp_1;
	CALL0		spawn;
	STOREP_ENT	return_x,	temp_1;
	INDIRECT_E	bodyque_head,	owner,	temp_1;
	INDIRECT_E	temp_1,	owner,	temp_1;
	INDIRECT_E	temp_1,	owner,	temp_1;
	ADDRESS	temp_1,	classname,	temp_1;
	STOREP_S	"bodyque",	temp_1;
	INDIRECT_E	bodyque_head,	owner,	temp_1;
	INDIRECT_E	temp_1,	owner,	temp_1;
	INDIRECT_E	temp_1,	owner,	temp_1;
	ADDRESS	temp_1,	owner,	temp_1;
	STOREP_ENT	bodyque_head,	temp_1;
	DONE;
}

void(entity ent) CopyToBodyQue = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	ADDRESS	bodyque_head,	effects,	temp_1;
	INDIRECT_F	ent,	effects,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	bodyque_head,	angles_x,	temp_0_x;
	INDIRECT_V	ent,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	bodyque_head,	model,	temp_1;
	INDIRECT_S	ent,	model,	temp_3;
	STOREP_S	temp_3,	temp_1;
	ADDRESS	bodyque_head,	modelindex,	temp_1;
	INDIRECT_F	ent,	modelindex,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	bodyque_head,	frame,	temp_1;
	INDIRECT_F	ent,	frame,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	bodyque_head,	colormap,	temp_1;
	INDIRECT_F	ent,	colormap,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	bodyque_head,	movetype,	temp_1;
	INDIRECT_F	ent,	movetype,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	bodyque_head,	velocity_x,	temp_0_x;
	INDIRECT_V	ent,	velocity_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	bodyque_head,	flags,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_V	ent,	origin_x,	temp_0;
	STORE_F	bodyque_head,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	INDIRECT_V	ent,	mins_x,	temp_0;
	INDIRECT_V	ent,	maxs_x,	temp_2;
	STORE_F	bodyque_head,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_2,	parm2;
	CALL3		setsize;
	INDIRECT_E	bodyque_head,	owner,	bodyque_head;
	DONE;
}

void () info_player_observer_start;
void() info_player_observer_start = asm
{
	DONE;
}

void () info_intermission;
void() info_intermission = asm
{
	DONE;
}

void () trigger_changelevel;
void() trigger_changelevel = asm
{
local float temp_1;
	INDIRECT_S	self,	map,	temp_1;
	NOT_S		temp_1,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	"changelevel trigger doesn't have map",	parm0_x;
	CALL1		objerror;
	CALL0		InitTrigger;
	INDIRECT_F	self,	isActive,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	changelevel_touch,	temp_1;
	GOTO		3;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	changelevel_use,	temp_1;
	DONE;
}

void () info_player_deathmatch_activate;
void() info_player_deathmatch_activate = asm
{
local float temp_1;
local float temp_3;
	ADDRESS	self,	classname,	temp_1;
	INDIRECT_S	self,	mdl,	temp_3;
	STOREP_S	temp_3,	temp_1;
	ADDRESS	self,	mdl,	temp_1;
	STOREP_S	"",	temp_1;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	DONE;
}

void () info_player_deathmatch_setup;
void() info_player_deathmatch_setup = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_S	self,	targetname,	temp_1;
	IFNOT		temp_1,	8;
	ADDRESS	self,	use,	temp_1;
	STOREP_FNC	info_player_deathmatch_activate,	temp_1;
	ADDRESS	self,	mdl,	temp_1;
	INDIRECT_S	self,	classname,	temp_3;
	STOREP_S	temp_3,	temp_1;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"",	temp_1;
	DONE;
}

void() info_player_start = asm
{
local vector temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_HULL_MIN,	parm1;
	STORE_V	'16.000000 16.000000 24.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	DONE;
}

void () info_player_start2;
void() info_player_start2 = asm
{
	DONE;
}

void () testplayerstart;
void() testplayerstart = asm
{
	DONE;
}

void () info_player_deathmatch;
void() info_player_deathmatch = asm
{
	DONE;
}

void () info_player_coop;
void() info_player_coop = asm
{
local vector temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_HULL_MIN,	parm1;
	STORE_V	'16.000000 16.000000 24.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	DONE;
}

void () info_player_team1;
void() info_player_team1 = asm
{
	CALL0		info_player_deathmatch_setup;
	DONE;
}

void () info_player_team2;
void() info_player_team2 = asm
{
	CALL0		info_player_deathmatch_setup;
	DONE;
}

void () info_player_team3;
void() info_player_team3 = asm
{
	CALL0		info_player_deathmatch_setup;
	DONE;
}

void () unit_hs_truck_cargo;
void() unit_hs_truck_cargo = asm
{
local vector temp_0;
local float temp_1;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	ai_rank,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	STORE_F	ai_noncom_tank,	parm0_x;
	CALL1		ai_unit_setup;
	DONE;
}

void () unit_hs_truck_hab;
void() unit_hs_truck_hab = asm
{
local vector temp_0;
local float temp_1;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	ai_rank,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	STORE_F	ai_noncom_tank,	parm0_x;
	CALL1		ai_unit_setup;
	DONE;
}

void () unit_hs_truck_const;
void() unit_hs_truck_const = asm
{
local vector temp_0;
local float temp_1;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	ai_rank,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	STORE_F	ai_noncom_tank,	parm0_x;
	CALL1		ai_unit_setup;
	DONE;
}

void () unit_hs_dozer;
void() unit_hs_dozer = asm
{
local vector temp_0;
local float temp_1;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	ai_rank,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	STORE_F	ai_noncom_tank,	parm0_x;
	CALL1		ai_unit_setup;
	DONE;
}

void () unit_hs_loader;
void() unit_hs_loader = asm
{
local vector temp_0;
local float temp_1;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	ai_rank,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	STORE_F	ai_noncom_tank,	parm0_x;
	CALL1		ai_unit_setup;
	DONE;
}

void () unit_hs_excavat;
void() unit_hs_excavat = asm
{
local vector temp_0;
local float temp_1;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	ai_rank,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	STORE_F	ai_noncom_tank,	parm0_x;
	CALL1		ai_unit_setup;
	DONE;
}

void () unit_hs_tank_l;
void() unit_hs_tank_l = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	MOVETYPE_PUSH,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	FL_TURRET,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	ACCURACY_SKIRMISH_x,	temp_0;
	STORE_F	ai_tank_skirmish,	parm0_x;
	CALL1		ai_unit_setup;
	DONE;
}

void () unit_hs_tank_h;
void() unit_hs_tank_h = asm
{
local float temp_1;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	DONE;
}

void () unit_hs_tnkdest_l;
void() unit_hs_tnkdest_l = asm
{
local vector temp_0;
local float temp_1;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	ACCURACY_SNIPER_x,	temp_0;
	STORE_F	ai_vec_dest,	parm0_x;
	CALL1		ai_unit_setup;
	DONE;
}

void () unit_hs_tnkdest_h;
void() unit_hs_tnkdest_h = asm
{
local float temp_1;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	DONE;
}

void () unit_hs_scout;
void() unit_hs_scout = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	flags,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	MOVETYPE_BOUNCEMISSILE,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	ACCURACY_LOWTECH_x,	temp_0;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	STORE_F	ai_gev,	parm0_x;
	CALL1		ai_unit_setup;
	IFNOT		return_x,	2;
	CALL0		ai_gev;
	DONE;
}

void () unit_hs_mech_skirmisher;
void() unit_hs_mech_skirmisher = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	FL_TURRET,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	mskin,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	ACCURACY_SKIRMISH_x,	temp_0;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	6;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_F	"ai_unit - outside of game mode",	parm0_x;
	CALL1		objerror;
	RETURN	offset_0;
	STORE_F	ai_mech_skirmish,	parm0_x;
	CALL1		ai_unit_setup;
	IFNOT		return_x,	2;
	CALL0		ai_mech_skirmish;
	DONE;
}

void () unit_hs_mech_sniper;
void() unit_hs_mech_sniper = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	flags,	temp_1;
	STOREP_F	FL_TURRET,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	mskin,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	ACCURACY_SNIPER_x,	temp_0;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	STORE_F	ai_mech_sniper,	parm0_x;
	CALL1		ai_unit_setup;
	IFNOT		return_x,	2;
	CALL0		ai_mech_sniper;
	DONE;
}

void () building_turret_light;
void() building_turret_light = asm
{
local vector temp_0;
local float temp_1;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	next_wepn1,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	next_wepn2,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	flags,	temp_1;
	STOREP_F	FL_TURRET,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	mskin,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	ACCURACY_LOWTECH_x,	temp_0;
	CALL0		ai_can_spawn;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	STORE_F	ai_turret,	parm0_x;
	CALL1		ai_unit_setup;
	IFNOT		return_x,	2;
	CALL0		ai_turret;
	DONE;
}

void () unit_hr_tank_l;
void() unit_hr_tank_l = asm
{
	DONE;
}

void () unit_hr_tank_m;
void() unit_hr_tank_m = asm
{
	DONE;
}

void () unit_hr_tank_h;
void() unit_hr_tank_h = asm
{
	DONE;
}

void () unit_hr_tank_mis;
void() unit_hr_tank_mis = asm
{
	DONE;
}

void () unit_hr_tankdest;
void() unit_hr_tankdest = asm
{
	DONE;
}

void () unit_hr_gev_l;
void() unit_hr_gev_l = asm
{
	DONE;
}

void () unit_hr_gev_m;
void() unit_hr_gev_m = asm
{
	DONE;
}

void () unit_hr_arty_m;
void() unit_hr_arty_m = asm
{
	DONE;
}

void () unit_hr_arty_c;
void() unit_hr_arty_c = asm
{
	DONE;
}

void () unit_psc_vtol_l;
void() unit_psc_vtol_l = asm
{
local float temp_1;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	STAT_PLR_HITDIR,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	STORE_F	ai_vtol,	parm0_x;
	CALL1		ai_unit_setup;
	DONE;
}

void (string) SV_ParseClientCommand;
void(string str) SV_ParseClientCommand = asm
{
local float argc;
local float temp_1;
	STORE_F	str,	parm0_x;
	CALL1		tokenize;
	STORE_F	return_x,	argc;
	STORE_F	FALSE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	"mech",	temp_1;
	IFNOT		temp_1,	5;
	STORE_F	str,	parm0_x;
	STORE_F	argc,	parm1_x;
	CALL2		client_ParseMechCommand;
	GOTO		16;
	STORE_F	FALSE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	"savegame",	temp_1;
	IFNOT		temp_1,	3;
	CALL0		savefile_save;
	GOTO		10;
	STORE_F	FALSE,	parm0_x;
	CALL1		argv;
	EQ_S		return_x,	"loadgame",	temp_1;
	IFNOT		temp_1,	3;
	CALL0		savefile_load;
	GOTO		4;
	STORE_F	self,	parm0_x;
	STORE_F	str,	parm1_x;
	CALL2		clientcommand;
	DONE;
}

void() ClientConnect = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	INDIRECT_S	self,	netname,	parm0_x;
	CALL1		bprint;
	STORE_F	" has deployed to the combat zone
",	parm0_x;
	CALL1		bprint;
	ADDRESS	self,	weaponmodel,	temp_1;
	STOREP_S	"",	temp_1;
	ADDRESS	self,	viewzoom,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	nextVecChoice,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	vec_size,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	data_idx,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	INDIRECT_F	self,	currentWeaponGroup,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	i_faction,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	en_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_cur,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_max,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	sh_rate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_cofs_x,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_cofs_y,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_cofs_z,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_w1_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w2_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w3_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w4_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w5_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w6_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w7_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w8_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w9_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	w_group1,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_group2,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_group3,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_group4,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_group5,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	state_1,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	state_2,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_wep_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_wep_rel,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_trg_dataidx,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_trg_sh,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_trg_ddflg,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_trg_dist,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_trg_face,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_trg_faction,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	radar_range,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	was_hit,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	hitdir_buffer,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_proj,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_hit_dirs,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_rdr_mode,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_rdr_rng,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_spr_x,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_spr_y,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	spreadDefault_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	accuracy,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	accuracyMod,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_plr_fir,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	stat_lck_stt,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	next_wepn1,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn2,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn3,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn4,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn5,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn6,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn7,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn8,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	next_wepn9,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	repair_request,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	stat_plr_stt,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	i_reserve,	temp_1;
	INDIRECT_F	world,	i_reserve,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	enemy,	temp_1;
	STOREP_ENT	world,	temp_1;
	ADDRESS	self,	stat_plr_rep,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	STORE_F	MOVETYPE_TOSS,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		client_playTrack;
	ADD_F		CLIENTS,	TRUE,	CLIENTS;
	ADDRESS	self,	client_num,	temp_1;
	STOREP_F	CLIENTS,	temp_1;
	ADDRESS	self,	stat_plr_stt,	temp_1;
	STOREP_F	TRUE,	temp_1;
	CALL0		client_push_player_info;
	IFNOT		intermission_running,	2;
	CALL0		ExitIntermission;
	DONE;
}

void() PutClientInServer = asm
{
local entity spot;
local float gamemode;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
local vector temp_5;
	ADDRESS	self,	flags,	temp_1;
	STOREP_F	FL_CLIENT,	temp_1;
	ADDRESS	self,	velocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	air_finished,	temp_1;
	ADD_F		time,	MOVETYPE_FOLLOW,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	dmg,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	effects,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	fixangle,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"player",	temp_1;
	ADDRESS	self,	attack_finished,	temp_1;
	STOREP_F	time,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	PlayerDie,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	pausetime,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	view_ofs_x,	temp_0_x;
	STOREP_V	'0.000000 0.000000 1.000000',	temp_0;
	STORE_F	"mechdev",	parm0_x;
	CALL1		cvar;
	NE_F		return_x,	FALSE,	temp_1;
	IF		temp_1,	4;
	IFNOT		coop,	3;
	CALL0		spawnpoint_coop;
	STORE_ENT	return_x,	spot;
	CALL0		SelectSpawnPoint;
	STORE_ENT	return_x,	spot;
	ADDRESS	self,	i_faction,	temp_1;
	INDIRECT_F	spot,	i_faction,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	origin_x,	temp_0_x;
	ADDRESS	self,	oldorigin_x,	temp_2_x;
	INDIRECT_V	spot,	origin_x,	temp_5;
	ADD_V		temp_5,	'0.000000 0.000000 1.000000',	temp_5;
	STOREP_V	temp_5_x,	temp_2;
	STOREP_V	temp_5_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_V	spot,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	STORE_F	"gamemode",	parm0_x;
	CALL1		cvar;
	STORE_F	return_x,	gamemode;
	CALL0		client_sendMissionFileName;
	STORE_F	gamemode,	parm0_x;
	CALL1		client_sendGameMode;
	GOTO		15;
	INDIRECT_S	world,	model,	temp_1;
	EQ_S		temp_1,	"maps/start.bsp",	temp_1;
	IFNOT		temp_1,	2;
	CALL0		savefile_default;
	CALL0		savefile_load;
	ADDRESS	self,	i_faction,	temp_1;
	INDIRECT_F	world,	i_faction,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		12;
	CALL0		mapfile_coop_load;
	GOTO		10;
	INDIRECT_F	self,	i_faction,	parm0_x;
	CALL1		mapfile_pvp_load;
	GOTO		7;
	EQ_F		gamemode,	TRUE,	temp_1;
	IF		temp_1,	-15;
	EQ_F		gamemode,	FL_SWIM,	temp_1;
	IF		temp_1,	-8;
	EQ_F		gamemode,	MOVETYPE_WALK,	temp_1;
	IF		temp_1,	-8;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	46;
	CALL0		player_makeObserver;
	CALL0		client_push_mapobjects;
	STORE_F	SAVE_MECHS_LIGHT,	parm0_x;
	CALL1		client_sendAvailableLightMechs;
	STORE_F	SAVE_MECHS_MEDIM,	parm0_x;
	CALL1		client_sendAvailableMediumMechs;
	STORE_F	SAVE_MECHS_HEAVY,	parm0_x;
	CALL1		client_sendAvailableHeavyMechs;
	STORE_F	SAVE_ITEMS_ALL,	parm0_x;
	CALL1		client_sendAvailableItems;
	NOT_F		coop,	temp_1;
	IFNOT		temp_1,	2;
	NOT_F		deathmatch,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	26;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	TRUE,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	STORE_F	"0",	parm3_x;
	STORE_F	"0",	parm4_x;
	CALL5		client_update_moveSpeed;
	STORE_F	"0",	parm0_x;
	STORE_F	"0",	parm1_x;
	STORE_F	"0",	parm2_x;
	CALL3		client_update_viewBob;
	STORE_F	"0",	parm0_x;
	STORE_F	"0",	parm1_x;
	STORE_F	"0",	parm2_x;
	CALL3		client_update_modelBob;
	ADDRESS	self,	stat_plr_stt,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	GOTO		3;
	ADDRESS	self,	stat_plr_stt,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	power_timer,	temp_1;
	STOREP_F	FALSE,	temp_1;
	GOTO		25;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	22;
	ADDRESS	self,	trigOnSpawn,	temp_1;
	INDIRECT_S	spot,	trigOnSpawn,	temp_3;
	STOREP_S	temp_3,	temp_1;
	ADDRESS	self,	trigOnDeath,	temp_1;
	INDIRECT_S	spot,	trigOnDeath,	temp_3;
	STOREP_S	temp_3,	temp_1;
	ADDRESS	self,	trigOnAttack,	temp_1;
	INDIRECT_S	spot,	trigOnAttack,	temp_3;
	STOREP_S	temp_3,	temp_1;
	ADDRESS	self,	trigOnDamage,	temp_1;
	INDIRECT_S	spot,	trigOnDamage,	temp_3;
	STOREP_S	temp_3,	temp_1;
	ADDRESS	self,	trigOnPanic,	temp_1;
	INDIRECT_S	spot,	trigOnPanic,	temp_3;
	STOREP_S	temp_3,	temp_1;
	ADDRESS	self,	trigOnTarget,	temp_1;
	INDIRECT_S	spot,	trigOnTarget,	temp_3;
	STOREP_S	temp_3,	temp_1;
	CALL0		player_makeMech;
	ADDRESS	self,	count4,	temp_1;
	STOREP_F	FALSE,	temp_1;
	IF		deathmatch,	1;
	OR		deathmatch,	coop,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_V	self,	angles_x,	parm0;
	CALL1		makevectors;
	DONE;
}

void() ClientKill = asm
{
local entity wep;
local float temp_1;
local float temp_3;
	INDIRECT_F	self,	deadflag,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	IFNOT		intermission_running,	3;
	IF		coop,	1;
	OR		coop,	deathmatch,	temp_1;
	AND		intermission_running,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_S	self,	netname,	parm0_x;
	CALL1		bprint;
	INDIRECT_F	self,	data_type,	temp_1;
	NE_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	" cowardly ejects!
",	parm0_x;
	CALL1		bprint;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	15;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	TRUE,	temp_1;
	CALL0		mech_clearWeaponGroups;
	INDIRECT_E	self,	w_slot,	wep;
	IFNOT		wep,	9;
	INDIRECT_F	wep,	state_1,	temp_1;
	INDIRECT_F	wep,	state_2,	temp_3;
	STORE_F	wep,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	CALL3		ctrl_weapon_clearState;
	INDIRECT_E	wep,	w_slot,	wep;
	GOTO		-8;
	CALL0		mech_cleanupMech;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	alpha,	temp_1;
	STOREP_F	FALSE,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	'-3.000000 -3.000000 -3.000000',	parm1;
	STORE_V	'3.000000 3.000000 3.000000',	parm2;
	CALL3		setsize;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	INDIRECT_F	self,	data_type,	temp_1;
	NE_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	self,	frags,	temp_1;
	INDIRECT_F	self,	frags,	temp_3;
	SUB_F		temp_3,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	CALL0		respawn;
	DONE;
}

void() ClientDisconnect = asm
{
local float clnum;
local entity client;
local float temp_1;
local float temp_3;
	IFNOT		gameover,	2;
	RETURN	offset_0;
	INDIRECT_S	self,	netname,	parm0_x;
	CALL1		bprint;
	STORE_F	" has fled the field of battle!
",	parm0_x;
	CALL1		bprint;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	4;
	CALL0		mech_player_die;
	CALL0		player_unmakeMech;
	CALL0		mech_cleanupMech;
	SUB_F		CLIENTS,	TRUE,	CLIENTS;
	STORE_F	flags,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	CALL2		findchainflags;
	STORE_ENT	return_x,	client;
	IFNOT		client,	11;
	INDIRECT_F	client,	client_num,	clnum;
	INDIRECT_F	self,	client_num,	temp_1;
	GT		clnum,	temp_1,	temp_1;
	IFNOT		temp_1,	5;
	ADDRESS	client,	client_num,	temp_1;
	INDIRECT_F	client,	client_num,	temp_3;
	SUB_F		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	client,	chain,	client;
	GOTO		-10;
	DONE;
}

void() PlayerPreThink = asm
{
local float locked_896;
local float locked_916;
local float locked_2932;
local vector temp_0;
local float temp_6;
	IFNOT		intermission_running,	3;
	CALL0		IntermissionThink;
	RETURN	offset_0;
	INDIRECT_V	self,	view_ofs_x,	temp_0;
	EQ_V		temp_0,	VEC_ORIGIN,	locked_2932;
	IFNOT		locked_2932,	2;
	RETURN	offset_0;
	INDIRECT_V	self,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_F	self,	deadflag,	locked_2932;
	GE		locked_2932,	FL_SWIM,	locked_2932;
	IFNOT		locked_2932,	3;
	CALL0		PlayerDeathThink;
	RETURN	offset_0;
	INDIRECT_F	self,	deadflag,	locked_2932;
	EQ_F		locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	pausetime,	locked_2932;
	LT		time,	locked_2932,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	velocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	INDIRECT_F	self,	button8,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	18;
	INDIRECT_F	self,	stat_plr_stt,	locked_2932;
	EQ_F		locked_2932,	MOVETYPE_PUSH,	locked_2932;
	IFNOT		locked_2932,	15;
	ADDRESS	self,	stat_plr_stt,	locked_2932;
	STOREP_F	MOVETYPE_FLY,	locked_2932;
	INDIRECT_F	self,	m_fspeed,	locked_2932;
	INDIRECT_F	self,	m_sspeed,	locked_916;
	INDIRECT_F	self,	m_bspeed,	locked_896;
	INDIRECT_F	self,	m_maccel,	parm0_x;
	CALL1		ftos;
	INDIRECT_S	self,	m_rollangle,	temp_6;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	locked_916,	parm1_x;
	STORE_F	locked_896,	parm2_x;
	STORE_F	return_x,	parm3_x;
	STORE_F	temp_6,	parm4_x;
	CALL5		client_update_moveSpeed;
	INDIRECT_F	self,	button9,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	11;
	INDIRECT_F	self,	viewzoom,	locked_2932;
	LT		locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	6;
	ADDRESS	self,	viewzoom,	locked_2932;
	INDIRECT_F	self,	viewzoom,	locked_916;
	ADD_F		locked_916,	0.250000,	locked_916;
	STOREP_F	locked_916,	locked_2932;
	GOTO		3;
	ADDRESS	self,	viewzoom,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	DONE;
}

void() PlayerPostThink = asm
{
local vector v;
local entity wep_chain;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local float temp_4;
local vector temp_5;
local float temp_6;
	INDIRECT_F	self,	stat_plr_stt,	temp_1;
	GOTO		11;
	INDIRECT_F	self,	count2,	temp_3;
	GE		time,	temp_3,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	stat_plr_stt,	temp_3;
	INDIRECT_F	self,	count1,	temp_4;
	STOREP_F	temp_4,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	INDIRECT_F	self,	count3,	temp_4;
	STOREP_F	temp_4,	temp_3;
	GOTO		3;
	EQ_F		temp_1,	MOVETYPE_TOSS,	temp_3;
	IF		temp_3,	-11;
	INDIRECT_V	self,	view_ofs_x,	temp_0;
	EQ_V		temp_0,	VEC_ORIGIN,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	deadflag,	temp_1;
	GE		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	data_type,	temp_1;
	NE_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	47;
	INDIRECT_F	self,	power_timer,	temp_1;
	LT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	6;
	INDIRECT_F	self,	movetype,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_F	self,	power_timer_segment,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	stat_plr_stt,	temp_1;
	STOREP_F	MOVETYPE_STEP,	temp_1;
	INDIRECT_F	self,	power_timer,	temp_1;
	GT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	10;
	INDIRECT_F	self,	stat_plr_stt,	temp_1;
	EQ_F		temp_1,	MOVETYPE_STEP,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	power_timer,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	ADDRESS	self,	stat_plr_stt,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	stat_hit_dirs,	temp_1;
	INDIRECT_F	self,	hitdir_buffer,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	w_proj,	temp_1;
	GE		time,	temp_1,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	stat_hit_dirs,	temp_1;
	INDIRECT_F	self,	stat_hit_dirs,	temp_3;
	INDIRECT_F	self,	stat_hit_dirs,	temp_4;
	BITAND	temp_4,	FL_INWATER,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_F	self,	was_hit,	temp_1;
	GE		time,	temp_1,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	stat_hit_dirs,	temp_1;
	INDIRECT_F	self,	stat_hit_dirs,	temp_3;
	INDIRECT_F	self,	stat_hit_dirs,	temp_4;
	BITAND	temp_4,	DPCONTENTS_LIQUIDSMASK,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	CALL0		server_make_sweep;
	ADDRESS	self,	stat_cofs_x,	temp_1;
	INDIRECT_F	self,	origin_x,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	stat_cofs_y,	temp_1;
	INDIRECT_F	self,	origin_y,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	stat_cofs_z,	temp_1;
	INDIRECT_F	self,	origin_z,	temp_3;
	STOREP_F	temp_3,	temp_1;
	CALL0		server_updateTargetInfo;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	58;
	INDIRECT_V	self,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	MUL_VF	v_forward,	DAT_MTK_RADAR_RANGE,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	FALSE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	ADDRESS	self,	stat_ret_dist,	temp_1;
	MUL_F		DAT_MTK_RADAR_RANGE,	trace_fraction,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	stat_plr_camx,	temp_1;
	INDIRECT_E	self,	e_cam,	temp_3;
	INDIRECT_F	temp_3,	c_ofs_x,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	stat_plr_camy,	temp_1;
	INDIRECT_E	self,	e_cam,	temp_3;
	INDIRECT_F	temp_3,	c_ofs_y,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	stat_plr_camz,	temp_1;
	INDIRECT_E	self,	e_cam,	temp_3;
	INDIRECT_F	temp_3,	c_ofs_z,	temp_3;
	STOREP_F	temp_3,	temp_1;
	CALL0		client_updateWeaponReloads;
	CALL0		ctrl_update_mechplayer;
	INDIRECT_E	self,	w_slot,	wep_chain;
	IFNOT		wep_chain,	5;
	STORE_F	wep_chain,	parm0_x;
	CALL1		ctrl_wpn_think;
	INDIRECT_E	wep_chain,	w_slot,	wep_chain;
	GOTO		-4;
	INDIRECT_F	self,	stat_plr_stt,	temp_1;
	EQ_F		temp_1,	MOVETYPE_PUSH,	temp_1;
	IFNOT		temp_1,	11;
	INDIRECT_F	self,	en_cur,	temp_1;
	GT		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	8;
	ADDRESS	self,	en_cur,	temp_1;
	INDIRECT_F	self,	en_cur,	temp_3;
	INDIRECT_F	self,	en_rate,	temp_4;
	INDIRECT_F	self,	m_maccel,	temp_6;
	SUB_F		temp_4,	temp_6,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	repair_request,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_F	self,	repair_request,	temp_1;
	IFNOT		temp_1,	7;
	STORE_F	self,	parm0_x;
	CALL1		util_getMechHpAverage;
	EQ_F		return_x,	TRUE,	temp_1;
	IFNOT		temp_1,	3;
	ADDRESS	self,	repair_request,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_F	self,	impulse,	temp_1;
	IFNOT		temp_1,	2;
	CALL0		ImpulseCommands;
	CALL0		ButtonCommands;
	STORE_F	"mechdev",	parm0_x;
	CALL1		cvar;
	EQ_F		return_x,	TRUE,	temp_1;
	IFNOT		temp_1,	36;
	INDIRECT_F	self,	button0,	temp_1;
	IFNOT		temp_1,	19;
	INDIRECT_V	self,	v_angle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	MUL_VF	v_forward,	DAT_BLD_H_SM_RADAR_RADAR_RANGE,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	TRUE,	parm2_x;
	STORE_F	self,	parm3_x;
	CALL4		traceline;
	ADDRESS	self,	c_ofs_x,	temp_0_x;
	STOREP_V	trace_endpos_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_0;
	MUL_VF	v_up,	CONTENT_SLIME,	temp_2;
	ADD_V		temp_0,	temp_2,	parm0;
	STORE_V	trace_endpos,	parm1;
	CALL2		te_beam_esr;
	ADDRESS	self,	stat_cofs_x,	temp_1;
	INDIRECT_F	self,	origin_x,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	stat_cofs_y,	temp_1;
	INDIRECT_F	self,	origin_y,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	stat_cofs_z,	temp_1;
	INDIRECT_F	self,	origin_z,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	stat_plr_ang_x,	temp_1;
	STOREP_F	trace_endpos_x,	temp_1;
	ADDRESS	self,	stat_plr_ang_y,	temp_1;
	STOREP_F	trace_endpos_y,	temp_1;
	ADDRESS	self,	stat_plr_ang_z,	temp_1;
	STOREP_F	trace_endpos_z,	temp_1;
	CALL0		playerAttack;
	CALL0		client_push_player_info;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	13;
	ADDRESS	self,	stat_plr_camx,	temp_1;
	INDIRECT_E	self,	e_cam,	temp_3;
	INDIRECT_F	temp_3,	c_ofs_x,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	stat_plr_camy,	temp_1;
	INDIRECT_E	self,	e_cam,	temp_3;
	INDIRECT_F	temp_3,	c_ofs_y,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	stat_plr_camz,	temp_1;
	INDIRECT_E	self,	e_cam,	temp_3;
	INDIRECT_F	temp_3,	c_ofs_z,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() PlayerDie = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_F	self,	deadflag,	temp_1;
	IFNOT		temp_1,	4;
	STORE_F	"warning: PlayerDie called twice
",	parm0_x;
	CALL1		bprint;
	RETURN	offset_0;
	CALL0		legacy_PlayerDie;
	ADDRESS	self,	effects,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	view_ofs_x,	temp_0_x;
	STOREP_V	'0.000000 0.000000 1.000000',	temp_0;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	FL_ONGROUND,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_TOSS,	temp_1;
	INDIRECT_F	self,	velocity_z,	temp_1;
	LT		temp_1,	MOVETYPE_BOUNCE,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	velocity_z,	temp_1;
	INDIRECT_F	self,	velocity_z,	temp_3;
	CALL0		random;
	MUL_F		return_x,	DAT_PRJ_ABT_CLST_VELOCITY,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	angles_x,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	angles_z,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	avelocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	INDIRECT_F	self,	data_type,	temp_1;
	NE_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	6;
	CALL0		mech_clearWeaponGroups;
	INDIRECT_F	self,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	2;
	CALL0		mech_player_die;
	DONE;
}

void() PlayerDead = asm
{
local float temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	data_type,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

void() PlayerDeathThink = asm
{
local float locked_2939;
local float forward;
local float temp_1;
local vector temp_2;
local float temp_3;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_ONGROUND,	temp_1;
	IFNOT		temp_1,	15;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		vlen;
	STORE_F	return_x,	forward;
	SUB_F		forward,	20.000000,	forward;
	LE		forward,	FALSE,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	velocity_x,	locked_2939;
	STOREP_V	VEC_ORIGIN_x,	locked_2939;
	GOTO		6;
	ADDRESS	self,	velocity_x,	locked_2939;
	INDIRECT_V	self,	velocity_x,	parm0;
	CALL1		normalize;
	MUL_FV	forward,	return,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	INDIRECT_F	self,	deadflag,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	25;
	INDIRECT_F	self,	button2,	temp_1;
	IF		temp_1,	2;
	INDIRECT_F	self,	button0,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IF		temp_1,	2;
	INDIRECT_F	self,	button3,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IF		temp_1,	2;
	INDIRECT_F	self,	button4,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IF		temp_1,	2;
	INDIRECT_F	self,	button5,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IF		temp_1,	2;
	INDIRECT_F	self,	button6,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IF		temp_1,	2;
	INDIRECT_F	self,	button7,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	RETURN	offset_0;
	INDIRECT_F	self,	button2,	temp_1;
	NOT_F		temp_1,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	button0,	temp_3;
	NOT_F		temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	button3,	temp_3;
	NOT_F		temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	button4,	temp_3;
	NOT_F		temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	button5,	temp_3;
	NOT_F		temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	button6,	temp_3;
	NOT_F		temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	button7,	temp_3;
	NOT_F		temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_F	self,	button8,	temp_3;
	NOT_F		temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	ADDRESS	self,	button0,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	button1,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	button2,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	button3,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	button4,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	button5,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	button6,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	button7,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	button8,	temp_1;
	STOREP_F	FALSE,	temp_1;
	CALL0		player_unmakeMech;
	CALL0		mech_cleanupMech;
	CALL0		player_makeObserver;
	CALL0		spawnpoint_select;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_FLY,	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	CALL0		respawn;
	DONE;
}

void() PlayerJump = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_WATERJUMP,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	waterlevel,	temp_1;
	GE		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	38;
	INDIRECT_F	self,	watertype,	temp_1;
	EQ_F		temp_1,	CONTENT_WATER,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	velocity_z,	temp_1;
	STOREP_F	STAT_PLR_ANG_X,	temp_1;
	GOTO		9;
	INDIRECT_F	self,	watertype,	temp_1;
	EQ_F		temp_1,	CONTENT_SLIME,	temp_1;
	IFNOT		temp_1,	4;
	ADDRESS	self,	velocity_z,	temp_1;
	STOREP_F	STAT_WEP_REL,	temp_1;
	GOTO		3;
	ADDRESS	self,	velocity_z,	temp_1;
	STOREP_F	TE_BLOOD,	temp_1;
	INDIRECT_F	self,	swim_flag,	temp_1;
	LT		temp_1,	time,	temp_1;
	IFNOT		temp_1,	20;
	ADDRESS	self,	swim_flag,	temp_1;
	ADD_F		time,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	CALL0		random;
	LT		return_x,	0.500000,	temp_1;
	IFNOT		temp_1,	8;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	"misc/water1.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	GOTO		7;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	"misc/water2.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	RETURN	offset_0;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_ONGROUND,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_JUMPRELEASED,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	2;
	RETURN	offset_0;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_4;
	BITAND	temp_4,	FL_JUMPRELEASED,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	SUB_F		temp_3,	FL_ONGROUND,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	button2,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	velocity_z,	temp_1;
	INDIRECT_F	self,	velocity_z,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void(void () func, entity own) build_unit_component = asm
{
local entity follow;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local vector temp_5;
	CALL0		func;
	INDIRECT_F	self,	c_parent,	parm0_x;
	STORE_F	own,	parm1_x;
	CALL2		util_getPartFromName;
	STORE_ENT	return_x,	follow;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	MECH_PIECE,	temp_1;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	MOVETYPE_FOLLOW,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	temp_1;
	INDIRECT_F	own,	mskin,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	'-1.000000 -1.000000 -1.000000',	parm1;
	STORE_V	'1.000000 1.000000 1.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	c_ofs_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_F	own,	parm1_x;
	STORE_V	temp_0,	parm2;
	CALL3		util_setOffsetOrigin;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	own,	temp_1;
	ADDRESS	self,	aiment,	temp_1;
	STOREP_ENT	follow,	temp_1;
	ADDRESS	self,	punchangle_x,	temp_0_x;
	INDIRECT_V	follow,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	view_ofs_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_V	follow,	origin_x,	temp_5;
	SUB_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_V	follow,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	v_angle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_2;
	INDIRECT_V	follow,	angles_x,	temp_5;
	SUB_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	ctrl_die_comp,	temp_1;
	DONE;
}

entity(void () func) build_unit_camera = asm
{
local entity cam;
local entity this;
local vector temp_0;
local float temp_1;
local vector temp_2;
local vector temp_5;
	CALL0		spawn;
	STORE_ENT	return_x,	cam;
	STORE_ENT	self,	this;
	STORE_ENT	cam,	self;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	"camera",	temp_1;
	ADDRESS	self,	scale,	temp_1;
	STOREP_F	ARM_LT_MOD,	temp_1;
	CALL0		func;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	MOVETYPE_FOLLOW,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	ADDRESS	self,	alpha,	temp_1;
	STOREP_F	FALSE,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	'-1.000000 -1.000000 -1.000000',	parm1;
	STORE_V	'1.000000 1.000000 1.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	c_ofs_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_F	this,	parm1_x;
	STORE_V	temp_0,	parm2;
	CALL3		util_setOffsetOrigin;
	ADDRESS	self,	aiment,	temp_1;
	STOREP_ENT	this,	temp_1;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	this,	temp_1;
	ADDRESS	self,	punchangle_x,	temp_0_x;
	INDIRECT_V	this,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	view_ofs_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_V	this,	origin_x,	temp_5;
	SUB_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_V	this,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	v_angle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_2;
	INDIRECT_V	this,	angles_x,	temp_5;
	SUB_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	STORE_ENT	this,	self;
	RETURN	cam;
	DONE;
}

void() build_unit_weapon_list = asm
{
local float locked_2932;
local entity wslot;
local float temp_3;
local float temp_4;
	STORE_ENT	self,	wslot;
	INDIRECT_FU	self,	unit_wep1,	locked_2932;
	IFNOT		locked_2932,	21;
	INDIRECT_F	self,	next_wepn1,	locked_2932;
	IFNOT		locked_2932,	19;
	ADDRESS	wslot,	w_slot,	locked_2932;
	INDIRECT_FU	self,	unit_wep1,	temp_3;
	INDIRECT_F	self,	next_wepn1,	temp_4;
	STORE_F	temp_3,	parm0_x;
	STORE_F	temp_4,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	FL_SWIM,	parm4_x;
	STORE_F	TRUE,	parm5_x;
	STORE_F	stat_w1_id,	parm6_x;
	CALL7		build_unit_weapon;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_E	wslot,	w_slot,	wslot;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	stat_w1_rel,	locked_2932;
	STOREP_F	STAT_PLR_ANG_X,	locked_2932;
	INDIRECT_FU	self,	unit_wep2,	locked_2932;
	IFNOT		locked_2932,	21;
	INDIRECT_F	self,	next_wepn2,	locked_2932;
	IFNOT		locked_2932,	19;
	ADDRESS	wslot,	w_slot,	locked_2932;
	INDIRECT_FU	self,	unit_wep2,	temp_3;
	INDIRECT_F	self,	next_wepn2,	temp_4;
	STORE_F	temp_3,	parm0_x;
	STORE_F	temp_4,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	MOVETYPE_STEP,	parm3_x;
	STORE_F	FL_CLIENT,	parm4_x;
	STORE_F	FL_SWIM,	parm5_x;
	STORE_F	stat_w2_id,	parm6_x;
	CALL7		build_unit_weapon;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_E	wslot,	w_slot,	wslot;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	stat_w2_rel,	locked_2932;
	STOREP_F	STAT_PLR_ANG_X,	locked_2932;
	INDIRECT_FU	self,	unit_wep3,	locked_2932;
	IFNOT		locked_2932,	21;
	INDIRECT_F	self,	next_wepn3,	locked_2932;
	IFNOT		locked_2932,	19;
	ADDRESS	wslot,	w_slot,	locked_2932;
	INDIRECT_FU	self,	unit_wep3,	temp_3;
	INDIRECT_F	self,	next_wepn3,	temp_4;
	STORE_F	temp_3,	parm0_x;
	STORE_F	temp_4,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	FL_INWATER,	parm3_x;
	STORE_F	FL_MONSTER,	parm4_x;
	STORE_F	MOVETYPE_STEP,	parm5_x;
	STORE_F	stat_w3_id,	parm6_x;
	CALL7		build_unit_weapon;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_E	wslot,	w_slot,	wslot;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	stat_w3_rel,	locked_2932;
	STOREP_F	STAT_PLR_ANG_X,	locked_2932;
	INDIRECT_FU	self,	unit_wep4,	locked_2932;
	IFNOT		locked_2932,	21;
	INDIRECT_F	self,	next_wepn4,	locked_2932;
	IFNOT		locked_2932,	19;
	ADDRESS	wslot,	w_slot,	locked_2932;
	INDIRECT_FU	self,	unit_wep4,	temp_3;
	INDIRECT_F	self,	next_wepn4,	temp_4;
	STORE_F	temp_3,	parm0_x;
	STORE_F	temp_4,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	FL_GODMODE,	parm3_x;
	STORE_F	FL_NOTARGET,	parm4_x;
	STORE_F	FL_CLIENT,	parm5_x;
	STORE_F	stat_w4_id,	parm6_x;
	CALL7		build_unit_weapon;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_E	wslot,	w_slot,	wslot;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	stat_w4_rel,	locked_2932;
	STOREP_F	STAT_PLR_ANG_X,	locked_2932;
	INDIRECT_FU	self,	unit_wep5,	locked_2932;
	IFNOT		locked_2932,	21;
	INDIRECT_F	self,	next_wepn5,	locked_2932;
	IFNOT		locked_2932,	19;
	ADDRESS	wslot,	w_slot,	locked_2932;
	INDIRECT_FU	self,	unit_wep5,	temp_3;
	INDIRECT_F	self,	next_wepn5,	temp_4;
	STORE_F	temp_3,	parm0_x;
	STORE_F	temp_4,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	FL_ITEM,	parm3_x;
	STORE_F	FL_ONGROUND,	parm4_x;
	STORE_F	FL_INWATER,	parm5_x;
	STORE_F	stat_w5_id,	parm6_x;
	CALL7		build_unit_weapon;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_E	wslot,	w_slot,	wslot;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	stat_w5_rel,	locked_2932;
	STOREP_F	STAT_PLR_ANG_X,	locked_2932;
	INDIRECT_FU	self,	unit_wep6,	locked_2932;
	IFNOT		locked_2932,	21;
	INDIRECT_F	self,	next_wepn6,	locked_2932;
	IFNOT		locked_2932,	19;
	ADDRESS	wslot,	w_slot,	locked_2932;
	INDIRECT_FU	self,	unit_wep6,	temp_3;
	INDIRECT_F	self,	next_wepn6,	temp_4;
	STORE_F	temp_3,	parm0_x;
	STORE_F	temp_4,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	FL_PARTIALGROUND,	parm3_x;
	STORE_F	FL_WATERJUMP,	parm4_x;
	STORE_F	FL_MONSTER,	parm5_x;
	STORE_F	stat_w6_id,	parm6_x;
	CALL7		build_unit_weapon;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_E	wslot,	w_slot,	wslot;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	stat_w6_rel,	locked_2932;
	STOREP_F	STAT_PLR_ANG_X,	locked_2932;
	INDIRECT_FU	self,	unit_wep7,	locked_2932;
	IFNOT		locked_2932,	21;
	INDIRECT_F	self,	next_wepn7,	locked_2932;
	IFNOT		locked_2932,	19;
	ADDRESS	wslot,	w_slot,	locked_2932;
	INDIRECT_FU	self,	unit_wep7,	temp_3;
	INDIRECT_F	self,	next_wepn7,	temp_4;
	STORE_F	temp_3,	parm0_x;
	STORE_F	temp_4,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	FL_JUMPRELEASED,	parm3_x;
	STORE_F	FL_SKIPTHINK,	parm4_x;
	STORE_F	FL_GODMODE,	parm5_x;
	STORE_F	stat_w7_id,	parm6_x;
	CALL7		build_unit_weapon;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_E	wslot,	w_slot,	wslot;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	stat_w7_rel,	locked_2932;
	STOREP_F	STAT_PLR_ANG_X,	locked_2932;
	INDIRECT_FU	self,	unit_wep8,	locked_2932;
	IFNOT		locked_2932,	21;
	INDIRECT_F	self,	next_wepn8,	locked_2932;
	IFNOT		locked_2932,	19;
	ADDRESS	wslot,	w_slot,	locked_2932;
	INDIRECT_FU	self,	unit_wep8,	temp_3;
	INDIRECT_F	self,	next_wepn8,	temp_4;
	STORE_F	temp_3,	parm0_x;
	STORE_F	temp_4,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	FL_UNIT,	parm3_x;
	STORE_F	FL_NOSHOOT,	parm4_x;
	STORE_F	FL_NOTARGET,	parm5_x;
	STORE_F	stat_w8_id,	parm6_x;
	CALL7		build_unit_weapon;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_E	wslot,	w_slot,	wslot;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	stat_w8_rel,	locked_2932;
	STOREP_F	STAT_PLR_ANG_X,	locked_2932;
	INDIRECT_FU	self,	unit_wep9,	locked_2932;
	IFNOT		locked_2932,	21;
	INDIRECT_F	self,	next_wepn9,	locked_2932;
	IFNOT		locked_2932,	19;
	ADDRESS	wslot,	w_slot,	locked_2932;
	INDIRECT_FU	self,	unit_wep9,	temp_3;
	INDIRECT_F	self,	next_wepn9,	temp_4;
	STORE_F	temp_3,	parm0_x;
	STORE_F	temp_4,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	FL_TURRET,	parm3_x;
	STORE_F	FL_NODE,	parm4_x;
	STORE_F	FL_ITEM,	parm5_x;
	STORE_F	stat_w9_id,	parm6_x;
	CALL7		build_unit_weapon;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_E	wslot,	w_slot,	wslot;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	stat_w9_rel,	locked_2932;
	STOREP_F	STAT_PLR_ANG_X,	locked_2932;
	DONE;
}

entity(void () func, float nex_wep, entity own, float state1, float state2, float state3, .float stat) build_unit_weapon = asm
{
local float locked_2932;
local vector ofs;
local entity prt;
local entity this;
local entity wep;
local vector temp_0;
local vector temp_2;
local float temp_3;
local float temp_4;
local vector temp_5;
	STORE_ENT	self,	this;
	CALL0		spawn;
	STORE_ENT	return_x,	wep;
	STORE_ENT	wep,	self;
	CALL0		func;
	ADDRESS	self,	data_idx,	locked_2932;
	STOREP_F	nex_wep,	locked_2932;
	ADDRESS	this,	stat,	locked_2932;
	INDIRECT_F	self,	data_idx,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	STORE_F	nex_wep,	parm0_x;
	CALL1		data_iniWep;
	ADDRESS	self,	rl_cur,	locked_2932;
	STOREP_F	STAT_PLR_ANG_X,	locked_2932;
	ADDRESS	self,	deadflag,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	ADDRESS	self,	classname,	locked_2932;
	STOREP_S	MECH_PIECE,	locked_2932;
	ADDRESS	self,	comp_id,	locked_2932;
	STOREP_F	CONTENT_SOLID,	locked_2932;
	INDIRECT_F	own,	flags,	locked_2932;
	BITAND	locked_2932,	FL_MONSTER,	locked_2932;
	IFNOT		locked_2932,	15;
	ADDRESS	self,	p_damage,	locked_2932;
	INDIRECT_F	own,	ai_rank,	temp_3;
	INDIRECT_F	self,	p_damage,	temp_4;
	STORE_F	temp_3,	parm0_x;
	STORE_F	temp_4,	parm1_x;
	CALL2		ai_pilot_mod_damage;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	w_clipsize,	locked_2932;
	GT		locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	w_firerate,	locked_2932;
	INDIRECT_F	self,	w_firerate,	temp_3;
	MUL_F		temp_3,	DAT_PRJ_EMP_VELOCITY,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	MOVETYPE_FOLLOW,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	'-1.000000 -1.000000 -1.000000',	parm1;
	STORE_V	'1.000000 1.000000 1.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	c_ofs_x,	temp_0;
	INDIRECT_V	self,	c_alt_ofs_x,	temp_2;
	ADD_V		temp_0,	temp_2,	ofs;
	STORE_F	self,	parm0_x;
	STORE_F	own,	parm1_x;
	STORE_V	ofs,	parm2;
	CALL3		util_setOffsetOrigin;
	INDIRECT_F	self,	c_parent,	parm0_x;
	STORE_F	own,	parm1_x;
	CALL2		util_getPartFromName;
	STORE_ENT	return_x,	prt;
	ADDRESS	self,	punchangle_x,	temp_0_x;
	ADDRESS	self,	angles_x,	temp_2_x;
	STOREP_V	VEC_ORIGIN_x,	temp_2;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	aiment,	locked_2932;
	STOREP_ENT	prt,	locked_2932;
	ADDRESS	self,	owner,	locked_2932;
	STOREP_ENT	own,	locked_2932;
	ADDRESS	self,	punchangle_x,	temp_0_x;
	INDIRECT_V	prt,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	view_ofs_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_V	prt,	origin_x,	temp_5;
	SUB_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_V	prt,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	v_angle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_2;
	INDIRECT_V	prt,	angles_x,	temp_5;
	SUB_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	c_part,	locked_2932;
	INDIRECT_F	self,	c_parent,	parm0_x;
	STORE_F	own,	parm1_x;
	CALL2		util_getPartFromName;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_F	self,	p_dmgtype,	locked_2932;
	BITAND	locked_2932,	FL_NOTARGET,	locked_2932;
	IFNOT		locked_2932,	5;
	INDIRECT_FU	self,	w_think,	locked_2932;
	CALL0		locked_2932;
	ADDRESS	self,	w_think,	locked_2932;
	STOREP_FNC	SUB_Null,	locked_2932;
	ADDRESS	self,	th_die,	locked_2932;
	STOREP_FNC	ctrl_die_weapon,	locked_2932;
	ADDRESS	self,	state_1,	locked_2932;
	STOREP_F	state1,	locked_2932;
	ADDRESS	self,	state_2,	locked_2932;
	STOREP_F	state2,	locked_2932;
	ADDRESS	self,	stat_wep_rel,	locked_2932;
	STOREP_F	state3,	locked_2932;
	INDIRECT_F	self,	state_1,	locked_2932;
	STORE_F	self,	parm0_x;
	STORE_F	locked_2932,	parm1_x;
	CALL2		ctrl_weapon_addState;
	STORE_ENT	this,	self;
	RETURN	wep;
	DONE;
}

void(void () data_ini) build_mech_unit = asm
{
local float locked_2932;
local entity part_chain;
local float temp_3;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	4;
	STORE_F	data_ini,	parm0_x;
	CALL1		build_mech_bot;
	RETURN	offset_0;
	ADDRESS	self,	data_type,	locked_2932;
	STOREP_F	FL_SWIM,	locked_2932;
	ADDRESS	self,	flags,	locked_2932;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	FL_UNIT,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	CALL0		data_ini;
	INDIRECT_FU	self,	unit_ctor,	parm0_x;
	CALL1		build_mech_torsoCenter;
	ADDRESS	self,	sh_hit,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	ADDRESS	self,	chain_timer,	locked_2932;
	STOREP_F	time,	locked_2932;
	ADDRESS	self,	lock_timer,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_FU	self,	unit_cam,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	e_cam,	locked_2932;
	INDIRECT_FU	self,	unit_cam,	parm0_x;
	CALL1		build_unit_camera;
	STOREP_ENT	return_x,	locked_2932;
	STORE_ENT	self,	part_chain;
	INDIRECT_FU	self,	unit_rtor,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_tor_r,	locked_2932;
	INDIRECT_FU	self,	unit_rtor,	parm0_x;
	CALL1		build_mech_torsoRight;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_tor_r,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	INDIRECT_FU	self,	unit_ltor,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_tor_l,	locked_2932;
	INDIRECT_FU	self,	unit_ltor,	parm0_x;
	CALL1		build_mech_torsoLeft;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_tor_l,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	INDIRECT_FU	self,	unit_rarm,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_arm_r,	locked_2932;
	INDIRECT_FU	self,	unit_rarm,	parm0_x;
	CALL1		build_mech_armRight;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_arm_r,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	INDIRECT_FU	self,	unit_larm,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_arm_l,	locked_2932;
	INDIRECT_FU	self,	unit_larm,	parm0_x;
	CALL1		build_mech_armLeft;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_arm_l,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	INDIRECT_FU	self,	unit_legs,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_legs,	locked_2932;
	INDIRECT_FU	self,	unit_legs,	parm0_x;
	CALL1		build_mech_legs;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_legs,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	CALL0		build_unit_weapon_list;
	DONE;
}

void(void () func) build_mech_torsoCenter = asm
{
local vector hmaxs;
local vector hmins;
local entity ctor;
local entity this;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local vector temp_5;
	CALL0		func;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	6;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	MOVETYPE_WALK,	parm2_x;
	CALL3		util_setCollider;
	GOTO		5;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	MOVETYPE_STEP,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_V	self,	mins_x,	hmins;
	INDIRECT_V	self,	maxs_x,	hmaxs;
	STORE_F	"q3mdl/testball.md3",	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	hmins,	parm1;
	STORE_V	hmaxs,	parm2;
	CALL3		setsize;
	ADDRESS	self,	alpha,	temp_1;
	STOREP_F	TRUE,	temp_1;
	CALL0		spawn;
	STORE_ENT	return_x,	ctor;
	STORE_ENT	self,	this;
	STORE_ENT	ctor,	self;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	MOVETYPE_FOLLOW,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	this,	c_model,	temp_1;
	INDIRECT_F	this,	mskin,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	'-1.000000 -1.000000 -1.000000',	parm1;
	STORE_V	'1.000000 1.000000 1.000000',	parm2;
	CALL3		setsize;
	STORE_F	self,	parm0_x;
	STORE_F	this,	parm1_x;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		util_setOffsetOrigin;
	ADDRESS	self,	punchangle_x,	temp_0_x;
	ADDRESS	self,	angles_x,	temp_2_x;
	STOREP_V	VEC_ORIGIN_x,	temp_2;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	aiment,	temp_1;
	STOREP_ENT	this,	temp_1;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	this,	temp_1;
	ADDRESS	self,	punchangle_x,	temp_0_x;
	INDIRECT_V	this,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	view_ofs_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_V	this,	origin_x,	temp_5;
	SUB_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_V	this,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	v_angle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_2;
	INDIRECT_V	this,	angles_x,	temp_5;
	SUB_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	this,	e_tor_c,	temp_1;
	STOREP_ENT	self,	temp_1;
	STORE_ENT	this,	self;
	CALL0		ctor_stand;
	DONE;
}

void(void () data_ini) build_mech_bot = asm
{
local float locked_2932;
local vector hmaxs;
local vector hmins;
local entity part_chain;
local vector temp_0;
local float temp_3;
	ADDRESS	self,	flags,	locked_2932;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	16416.000000,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	CALL0		data_ini;
	INDIRECT_V	self,	maxs_x,	hmaxs;
	INDIRECT_V	self,	mins_x,	hmins;
	INDIRECT_F	self,	mskin,	locked_2932;
	STORE_F	"q3mdl/testball.md3",	parm0_x;
	STORE_F	locked_2932,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	hmins,	parm1;
	STORE_V	hmaxs,	parm2;
	CALL3		setsize;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	MOVETYPE_STEP,	parm2_x;
	CALL3		util_setCollider;
	ADDRESS	self,	alpha,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	ADDRESS	self,	sh_hit,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	ADDRESS	self,	chain_timer,	locked_2932;
	STOREP_F	time,	locked_2932;
	ADDRESS	self,	lock_timer,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_FU	self,	unit_cam,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	e_cam,	locked_2932;
	INDIRECT_FU	self,	unit_cam,	parm0_x;
	CALL1		build_unit_camera;
	STOREP_ENT	return_x,	locked_2932;
	STORE_ENT	self,	part_chain;
	ADDRESS	self,	e_tor_c,	locked_2932;
	INDIRECT_FU	self,	unit_ctor,	parm0_x;
	CALL1		build_unit_turret;
	STOREP_ENT	return_x,	locked_2932;
	INDIRECT_E	self,	e_tor_c,	locked_2932;
	ADDRESS	locked_2932,	yaw_speed,	locked_2932;
	INDIRECT_F	self,	m_rot_speed,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_tor_c,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	INDIRECT_FU	self,	unit_rtor,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_tor_r,	locked_2932;
	INDIRECT_FU	self,	unit_rtor,	parm0_x;
	CALL1		build_mech_torsoRight;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_tor_r,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	INDIRECT_FU	self,	unit_ltor,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_tor_l,	locked_2932;
	INDIRECT_FU	self,	unit_ltor,	parm0_x;
	CALL1		build_mech_torsoLeft;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_tor_l,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	INDIRECT_FU	self,	unit_larm,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_arm_l,	locked_2932;
	INDIRECT_FU	self,	unit_larm,	parm0_x;
	CALL1		build_mech_torsoLeft;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_arm_l,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	INDIRECT_FU	self,	unit_rarm,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_arm_r,	locked_2932;
	INDIRECT_FU	self,	unit_rarm,	parm0_x;
	CALL1		build_mech_torsoLeft;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_arm_r,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	INDIRECT_FU	self,	unit_legs,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_legs,	locked_2932;
	INDIRECT_FU	self,	unit_legs,	parm0_x;
	CALL1		build_mech_legs;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_legs,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	CALL0		build_unit_weapon_list;
	DONE;
}

entity(void () func) build_unit_turret = asm
{
local entity comp;
local entity this;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
	STORE_ENT	self,	this;
	CALL0		spawn;
	STORE_ENT	return_x,	comp;
	STORE_ENT	comp,	self;
	CALL0		func;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	MECH_PIECE,	temp_1;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	temp_1;
	INDIRECT_F	this,	mskin,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	'-1.000000 -1.000000 -1.000000',	parm1;
	STORE_V	'1.000000 1.000000 1.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	c_ofs_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_F	this,	parm1_x;
	STORE_V	temp_0,	parm2;
	CALL3		util_setOffsetOrigin;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_V	this,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	this,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	ctrl_die_comp,	temp_1;
	ADDRESS	self,	attack_state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	STORE_ENT	this,	self;
	RETURN	comp;
	DONE;
}

entity(void () func) build_mech_torsoLeft = asm
{
local entity comp;
local entity this;
	STORE_ENT	self,	this;
	CALL0		spawn;
	STORE_ENT	return_x,	comp;
	STORE_ENT	comp,	self;
	STORE_F	func,	parm0_x;
	STORE_F	this,	parm1_x;
	CALL2		build_unit_component;
	STORE_ENT	this,	self;
	RETURN	comp;
	DONE;
}

entity(void () func) build_mech_torsoRight = asm
{
local entity comp;
local entity this;
	STORE_ENT	self,	this;
	CALL0		spawn;
	STORE_ENT	return_x,	comp;
	STORE_ENT	comp,	self;
	STORE_F	func,	parm0_x;
	STORE_F	this,	parm1_x;
	CALL2		build_unit_component;
	STORE_ENT	this,	self;
	RETURN	comp;
	DONE;
}

entity(void () func) build_mech_armLeft = asm
{
local entity comp;
local entity this;
local float temp_1;
local float temp_3;
	STORE_ENT	self,	this;
	CALL0		spawn;
	STORE_ENT	return_x,	comp;
	STORE_ENT	comp,	self;
	STORE_F	func,	parm0_x;
	STORE_F	this,	parm1_x;
	CALL2		build_unit_component;
	ADDRESS	self,	c_part,	temp_1;
	INDIRECT_E	this,	e_tor_l,	temp_3;
	STOREP_ENT	temp_3,	temp_1;
	STORE_ENT	this,	self;
	RETURN	comp;
	DONE;
}

entity(void () func) build_mech_armRight = asm
{
local entity comp;
local entity this;
local float temp_1;
local float temp_3;
	STORE_ENT	self,	this;
	CALL0		spawn;
	STORE_ENT	return_x,	comp;
	STORE_ENT	comp,	self;
	STORE_F	func,	parm0_x;
	STORE_F	this,	parm1_x;
	CALL2		build_unit_component;
	ADDRESS	self,	c_part,	temp_1;
	INDIRECT_E	this,	e_tor_r,	temp_3;
	STOREP_ENT	temp_3,	temp_1;
	STORE_ENT	this,	self;
	RETURN	comp;
	DONE;
}

entity(void () func) build_mech_legs = asm
{
local entity leg_ent;
local entity this;
local vector temp_0;
local float temp_1;
local vector temp_2;
local float temp_3;
local vector temp_5;
	STORE_ENT	self,	this;
	CALL0		spawn;
	STORE_ENT	return_x,	leg_ent;
	STORE_ENT	leg_ent,	self;
	CALL0		func;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	classname,	temp_1;
	STOREP_S	MECH_PIECE,	temp_1;
	ADDRESS	self,	walkframe,	temp_1;
	STOREP_F	TRUE,	temp_1;
	STORE_F	FALSE,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	MOVETYPE_FOLLOW,	parm2_x;
	CALL3		util_setCollider;
	INDIRECT_S	self,	c_model,	temp_1;
	INDIRECT_F	this,	mskin,	temp_3;
	STORE_F	temp_1,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	'-1.000000 -1.000000 -1.000000',	parm1;
	STORE_V	'1.000000 1.000000 1.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	c_ofs_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_F	this,	parm1_x;
	STORE_V	temp_0,	parm2;
	CALL3		util_setOffsetOrigin;
	ADDRESS	self,	aiment,	temp_1;
	STOREP_ENT	this,	temp_1;
	ADDRESS	self,	owner,	temp_1;
	STOREP_ENT	this,	temp_1;
	ADDRESS	self,	punchangle_x,	temp_0_x;
	INDIRECT_V	this,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	view_ofs_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_V	this,	origin_x,	temp_5;
	SUB_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	INDIRECT_V	this,	angles_x,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	v_angle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_2;
	INDIRECT_V	this,	angles_x,	temp_5;
	SUB_V		temp_2,	temp_5,	temp_2;
	STOREP_V	temp_2_x,	temp_0;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	ctrl_dieLegs,	temp_1;
	ADDRESS	self,	laser_sight_org_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	laser_sight_timer,	temp_1;
	ADD_F		time,	0.500000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	w_firerate,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	th_stand,	temp_1;
	STOREP_FNC	leg_stand1,	temp_1;
	ADDRESS	self,	th_walk,	temp_1;
	STOREP_FNC	leg_walk1,	temp_1;
	ADDRESS	self,	th_die,	temp_1;
	STOREP_FNC	leg_die1,	temp_1;
	INDIRECT_F	this,	data_type,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	2;
	CALL0		leg_stand1;
	STORE_ENT	this,	self;
	RETURN	leg_ent;
	DONE;
}

void(void () data_ini) build_vehicle_unit = asm
{
local float locked_2932;
local vector hmaxs;
local vector hmins;
local entity part_chain;
local vector temp_0;
local float temp_3;
	ADDRESS	self,	flags,	locked_2932;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	16416.000000,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	CALL0		data_ini;
	INDIRECT_V	self,	maxs_x,	hmaxs;
	INDIRECT_V	self,	mins_x,	hmins;
	INDIRECT_S	self,	c_model,	locked_2932;
	INDIRECT_F	self,	mskin,	temp_3;
	STORE_F	locked_2932,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	FALSE,	parm2_x;
	CALL3		util_setModel;
	STORE_F	self,	parm0_x;
	STORE_V	hmins,	parm1;
	STORE_V	hmaxs,	parm2;
	CALL3		setsize;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	MOVETYPE_STEP,	parm2_x;
	CALL3		util_setCollider;
	ADDRESS	self,	alpha,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	ADDRESS	self,	sh_hit,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	ADDRESS	self,	chain_timer,	locked_2932;
	STOREP_F	time,	locked_2932;
	ADDRESS	self,	lock_timer,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_FU	self,	unit_cam,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	e_cam,	locked_2932;
	INDIRECT_FU	self,	unit_cam,	parm0_x;
	CALL1		build_unit_camera;
	STOREP_ENT	return_x,	locked_2932;
	STORE_ENT	self,	part_chain;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_TURRET,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_tor_c,	locked_2932;
	INDIRECT_FU	self,	unit_ctor,	parm0_x;
	CALL1		build_unit_turret;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_tor_c,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	INDIRECT_FU	self,	unit_rtor,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_tor_r,	locked_2932;
	INDIRECT_FU	self,	unit_rtor,	parm0_x;
	CALL1		build_mech_torsoRight;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_tor_r,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	INDIRECT_FU	self,	unit_ltor,	locked_2932;
	IFNOT		locked_2932,	9;
	ADDRESS	self,	e_tor_l,	locked_2932;
	INDIRECT_FU	self,	unit_ltor,	parm0_x;
	CALL1		build_mech_torsoLeft;
	STOREP_ENT	return_x,	locked_2932;
	ADDRESS	part_chain,	c_part,	locked_2932;
	INDIRECT_E	self,	e_tor_l,	temp_3;
	STOREP_ENT	temp_3,	locked_2932;
	INDIRECT_E	part_chain,	c_part,	part_chain;
	CALL0		build_unit_weapon_list;
	DONE;
}

void(void () data_ini) build_vtol_unit = asm
{
local float temp_1;
local float temp_3;
	ADDRESS	self,	flags,	temp_1;
	INDIRECT_F	self,	flags,	temp_3;
	BITOR		temp_3,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_F	data_ini,	parm0_x;
	CALL1		build_vehicle_unit;
	DONE;
}

void(void () data_ini) build_turret_unit = asm
{
local vector temp_0;
local float temp_1;
local vector temp_2;
	STORE_F	data_ini,	parm0_x;
	CALL1		build_vehicle_unit;
	INDIRECT_V	self,	angles_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_2;
	INDIRECT_F	self,	mins_z,	temp_1;
	ADD_F		temp_1,	MOVETYPE_STEP,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_2,	parm1;
	STORE_F	temp_1,	parm2_x;
	CALL3		util_dropToGround;
	STORE_F	self,	parm0_x;
	STORE_V	return,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	STORE_F	self,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	CALL2		util_cornerSlopeCheck;
	IFNOT		return_x,	3;
	STORE_F	self,	parm0_x;
	CALL1		util_generateBuildingFoundation;
	DONE;
}

void() mech_clearWeaponGroups = asm
{
local float temp_1;
	ADDRESS	self,	w_group1,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_group2,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_group3,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_group4,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	w_group5,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	self,	currentWeaponGroup,	temp_1;
	STOREP_F	FALSE,	temp_1;
	DONE;
}

void() ctrl_update_mechplayer = asm
{
local entity oself;
local float temp_1;
local float temp_3;
	STORE_ENT	self,	oself;
	CALL0		ctrl_updateCenterTorso;
	INDIRECT_E	oself,	e_legs,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_E	oself,	e_legs,	temp_1;
	NE_E		temp_1,	world,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_E	oself,	e_legs,	temp_3;
	INDIRECT_E	temp_3,	owner,	temp_3;
	EQ_E		temp_3,	oself,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_E	oself,	e_legs,	self;
	CALL0		ctrl_updateLegs;
	STORE_ENT	oself,	self;
	DONE;
}

void() mech_cleanupMech = asm
{
local entity this;
local entity lstp;
local entity next;
local entity w_chain;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_E	self,	e_tor_c,	parm0_x;
	CALL1		mech_player_removecomp;
	INDIRECT_E	self,	e_tor_l,	parm0_x;
	CALL1		mech_player_removecomp;
	INDIRECT_E	self,	e_tor_r,	parm0_x;
	CALL1		mech_player_removecomp;
	INDIRECT_E	self,	e_arm_l,	parm0_x;
	CALL1		mech_player_removecomp;
	INDIRECT_E	self,	e_arm_r,	parm0_x;
	CALL1		mech_player_removecomp;
	INDIRECT_E	self,	e_legs,	temp_1;
	IFNOT		temp_1,	19;
	INDIRECT_E	self,	e_legs,	temp_1;
	NE_E		temp_1,	world,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_E	self,	e_legs,	temp_3;
	INDIRECT_E	temp_3,	owner,	temp_3;
	EQ_E		temp_3,	self,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	11;
	STORE_ENT	self,	this;
	INDIRECT_E	self,	e_legs,	self;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	leg_die1,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_ENT	this,	self;
	INDIRECT_E	self,	e_legs,	parm0_x;
	CALL1		mech_player_removecomp;
	INDIRECT_E	self,	w_slot,	w_chain;
	IFNOT		w_chain,	22;
	INDIRECT_E	w_chain,	w_slot,	next;
	INDIRECT_E	w_chain,	lst_p,	lstp;
	IFNOT		lstp,	3;
	ADDRESS	lstp,	w_slot,	temp_1;
	STOREP_ENT	next,	temp_1;
	NE_E		w_chain,	world,	temp_1;
	IFNOT		temp_1,	9;
	INDIRECT_F	w_chain,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	NOT_F		temp_3,	temp_3;
	IF		temp_3,	4;
	INDIRECT_F	w_chain,	flags,	temp_4;
	BITAND	temp_4,	FL_MONSTER,	temp_4;
	NOT_F		temp_4,	temp_4;
	OR		temp_3,	temp_4,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	w_chain,	parm0_x;
	CALL1		remove;
	STORE_ENT	next,	w_chain;
	GOTO		-21;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	20;
	CALL0		mech_player_removecamera;
	ADDRESS	self,	stat_w1_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w2_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w3_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w4_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w5_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w6_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w7_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w8_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	ADDRESS	self,	stat_w9_id,	temp_1;
	STOREP_F	CONTENT_EMPTY,	temp_1;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	5;
	INDIRECT_E	self,	e_cam,	parm0_x;
	CALL1		mech_player_removecomp;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void() mech_player_die = asm
{
local entity w_chain;
local float temp_1;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	2;
	CALL0		mech_player_cameradie;
	INDIRECT_E	self,	w_slot,	w_chain;
	IFNOT		w_chain,	5;
	STORE_F	w_chain,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	w_chain,	w_slot,	w_chain;
	GOTO		-4;
	INDIRECT_E	self,	e_tor_c,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_tor_l,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_tor_r,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_arm_l,	parm0_x;
	CALL1		mech_player_compdie;
	INDIRECT_E	self,	e_arm_r,	parm0_x;
	CALL1		mech_player_compdie;
	ADDRESS	self,	stat_ctor_hp,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_E	self,	e_legs,	parm0_x;
	CALL1		mech_player_compdie;
	CALL0		ctor_die1;
	DONE;
}

void(entity comp) mech_player_compdie = asm
{
local entity this;
local float temp_1;
local float temp_3;
	INDIRECT_S	comp,	model,	temp_1;
	IFNOT		temp_1,	20;
	NE_E		comp,	world,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	comp,	owner,	temp_3;
	EQ_E		temp_3,	self,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	14;
	STORE_ENT	self,	this;
	STORE_ENT	comp,	self;
	INDIRECT_FU	self,	th_die,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_FU	self,	th_die,	temp_1;
	CALL0		temp_1;
	GOTO		6;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	0.100000,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_ENT	this,	self;
	DONE;
}

void() mech_player_cameradie = asm
{
local vector temp_0;
	ADDRESS	self,	view_ofs_x,	temp_0_x;
	STOREP_V	'0.000000 0.000000 1.000000',	temp_0;
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	MOVETYPE_FLY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	self,	parm1_x;
	CALL2		WriteEntity;
	DONE;
}

void() mech_player_removecamera = asm
{
local vector temp_0;
local float temp_1;
	INDIRECT_E	self,	e_cam,	temp_1;
	INDIRECT_S	temp_1,	classname,	temp_1;
	IFNOT		temp_1,	12;
	ADDRESS	self,	view_ofs_x,	temp_0_x;
	STOREP_V	'0.000000 0.000000 1.000000',	temp_0;
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	MOVETYPE_FLY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	self,	parm1_x;
	CALL2		WriteEntity;
	INDIRECT_E	self,	e_cam,	parm0_x;
	CALL1		remove;
	DONE;
}

void(entity comp) mech_player_removecomp = asm
{
local entity this;
local float temp_1;
local float temp_3;
	INDIRECT_S	comp,	model,	temp_1;
	IFNOT		temp_1,	12;
	NE_E		comp,	world,	temp_1;
	IFNOT		temp_1,	3;
	INDIRECT_E	comp,	owner,	temp_3;
	EQ_E		temp_3,	self,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	6;
	STORE_ENT	self,	this;
	STORE_ENT	comp,	self;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	STORE_ENT	this,	self;
	DONE;
}

void() leg_stand1 = asm
{
local float temp_1;
local float temp_3;
	STATE		FL_CLIENT,	leg_stand1;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	velocity_x,	temp_1;
	IF		temp_1,	3;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	velocity_y,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	CALL0		leg_walk1;
	RETURN	offset_0;
	DONE;
}

void() leg_walk1 = asm
{
local float temp_1;
local float temp_3;
	STATE		FALSE,	leg_walk2;
	ADDRESS	self,	walkframe,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	velocity_x,	temp_1;
	NOT_F		temp_1,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	velocity_y,	temp_3;
	NOT_F		temp_3,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	CALL0		leg_stand1;
	RETURN	offset_0;
	DONE;
}

void() leg_walk2 = asm
{
	STATE		TRUE,	leg_walk3;
	DONE;
}

void() leg_walk3 = asm
{
local vector ofs;
local entity player;
local vector temp_0;
local float temp_1;
local vector temp_2;
local vector temp_5;
	STATE		FL_SWIM,	leg_walk4;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_ONGROUND,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_V	player,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	player,	origin_x,	temp_0;
	MUL_VF	v_up,	-44.000000,	temp_2;
	MUL_VF	v_forward,	FL_CLIENT,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	MUL_VF	v_right,	MOVETYPE_BOUNCE,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	ADD_V		temp_0,	temp_2,	ofs;
	STORE_V	ofs,	parm0;
	STORE_V	'0.000000 0.000000 25.000000',	parm1;
	STORE_F	IMP_SWEAPON3,	parm2_x;
	CALL3		te_spark;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	"sound/mech_stomp.ogg",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

void() leg_walk4 = asm
{
	STATE		MOVETYPE_WALK,	leg_walk5;
	DONE;
}

void() leg_walk5 = asm
{
	STATE		MOVETYPE_STEP,	leg_walk6;
	DONE;
}

void() leg_walk6 = asm
{
local vector ofs;
local entity player;
local vector temp_0;
local float temp_1;
local vector temp_2;
local vector temp_5;
	STATE		MOVETYPE_FLY,	leg_walk7;
	INDIRECT_E	self,	owner,	player;
	INDIRECT_F	player,	flags,	temp_1;
	BITAND	temp_1,	FL_ONGROUND,	temp_1;
	IFNOT		temp_1,	20;
	INDIRECT_V	player,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	player,	origin_x,	temp_0;
	MUL_VF	v_up,	-44.000000,	temp_2;
	MUL_VF	v_forward,	FL_CLIENT,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	MUL_VF	v_right,	-10.000000,	temp_5;
	ADD_V		temp_2,	temp_5,	temp_2;
	ADD_V		temp_0,	temp_2,	ofs;
	STORE_V	ofs,	parm0;
	STORE_V	'0.000000 0.000000 25.000000',	parm1;
	STORE_F	IMP_SWEAPON3,	parm2_x;
	CALL3		te_spark;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	"sound/mech_stomp.ogg",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

void() leg_walk7 = asm
{
	STATE		MOVETYPE_TOSS,	leg_walk1;
	DONE;
}

void() leg_die1 = asm
{
local float temp_1;
	STATE		MOVETYPE_FLYMISSILE,	leg_die2;
	ADDRESS	self,	movetype,	temp_1;
	STOREP_F	MOVETYPE_BOUNCE,	temp_1;
	ADDRESS	self,	solid,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	DONE;
}

void() leg_die2 = asm
{
	STATE		MOVETYPE_BOUNCE,	leg_die3;
	DONE;
}

void() leg_die3 = asm
{
	STATE		MOVETYPE_BOUNCEMISSILE,	leg_die4;
	DONE;
}

void() leg_die4 = asm
{
local float temp_1;
local float temp_3;
	STATE		MOVETYPE_FOLLOW,	leg_die4;
	ADDRESS	self,	deadflag,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	SUB_Remove,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	ADD_F		time,	STAT_PLR_ANG_X,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () player_movestart;
void() player_movestart = asm
{
local float temp_1;
local float temp_3;
	ADDRESS	self,	walkframe,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	velocity_x,	temp_1;
	IF		temp_1,	3;
	INDIRECT_E	self,	owner,	temp_3;
	INDIRECT_F	temp_3,	velocity_y,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	3;
	CALL0		leg_walk1;
	GOTO		2;
	CALL0		leg_stand1;
	DONE;
}

void() ctor_stand = asm
{
	STATE		IMP_SWEAPON1,	ctor_stand;
	DONE;
}

void() ctor_die1 = asm
{
local float locked_2939;
local vector pvel;
local entity oself;
local entity e;
local float temp_1;
local vector temp_2;
local float temp_3;
	STATE		DPCONTENTS_LIQUIDSMASK,	ctor_die2;
	INDIRECT_V	self,	velocity_x,	pvel;
	CALL0		spawn;
	STORE_ENT	return_x,	e;
	STORE_ENT	self,	oself;
	STORE_ENT	e,	self;
	INDIRECT_V	oself,	origin_x,	locked_2939;
	STORE_F	self,	parm0_x;
	STORE_V	locked_2939,	parm1;
	CALL2		setorigin;
	CALL0		BecomeExplosion;
	STORE_ENT	oself,	self;
	INDIRECT_V	self,	mins_x,	locked_2939;
	INDIRECT_V	self,	maxs_x,	temp_2;
	STORE_F	self,	parm0_x;
	STORE_V	locked_2939,	parm1;
	STORE_V	temp_2,	parm2;
	CALL3		setsize;
	GT		pvel_x,	FALSE,	temp_1;
	IF		temp_1,	2;
	GT		pvel_y,	FALSE,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IF		temp_1,	2;
	GT		pvel_z,	FALSE,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	19;
	ADDRESS	self,	velocity_x,	locked_2939;
	STORE_F	STAT_PLR_ANG_X,	parm0_x;
	CALL1		VelocityForDamage;
	ADD_V		pvel,	return,	temp_2;
	STOREP_V	temp_2_x,	locked_2939;
	ADDRESS	self,	avelocity_x,	temp_1;
	CALL0		random;
	MUL_F		return_x,	DAT_MTK_LTOR_HP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	avelocity_y,	temp_1;
	CALL0		random;
	MUL_F		return_x,	DAT_MTK_LTOR_HP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	avelocity_z,	temp_1;
	CALL0		random;
	MUL_F		return_x,	DAT_MTK_LTOR_HP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	GOTO		17;
	ADDRESS	self,	velocity_x,	locked_2939;
	STORE_F	STAT_PLR_ANG_X,	parm0_x;
	CALL1		VelocityForDamage;
	STOREP_V	return_x,	locked_2939;
	ADDRESS	self,	avelocity_x,	temp_1;
	CALL0		random;
	MUL_F		return_x,	DAT_MTK_LTOR_HP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	avelocity_y,	temp_1;
	CALL0		random;
	MUL_F		return_x,	DAT_MTK_LTOR_HP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	avelocity_z,	temp_1;
	CALL0		random;
	MUL_F		return_x,	DAT_MTK_LTOR_HP,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void() ctor_die2 = asm
{
	STATE		IMP_SWEAPON3,	ctor_die3;
	DONE;
}

void() ctor_die3 = asm
{
local float temp_1;
	STATE		FL_INWATER,	ctor_die3;
	INDIRECT_F	self,	flags,	temp_1;
	BITAND	temp_1,	FL_CLIENT,	temp_1;
	IFNOT		temp_1,	2;
	CALL0		PlayerDead;
	DONE;
}

void(vector org, vector end) te_beam_laser = asm
{
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	STAT_PLR_PTC,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_z,	parm1_x;
	CALL2		WriteCoord;
	DONE;
}

void(vector org, vector end) te_beam_esr = asm
{
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	STAT_PLR_ANG,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_z,	parm1_x;
	CALL2		WriteCoord;
	DONE;
}

void(vector org, vector end) te_beam_pac = asm
{
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	STAT_TRG_DDFLG,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_z,	parm1_x;
	CALL2		WriteCoord;
	DONE;
}

void(vector org, vector vel, float total) te_smoke_test = asm
{
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	STAT_TRG_ORGX,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	vel_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	vel_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	vel_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	total,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void(vector org, vector angl) te_shield_test = asm
{
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	STAT_TRG_ORGY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	angl_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	angl_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	angl_z,	parm1_x;
	CALL2		WriteCoord;
	DONE;
}

void(vector org, float total) te_heat_small = asm
{
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	STAT_PLR_ANG_X,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	total,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void(vector org, vector end, float total) te_mis_trail = asm
{
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	STAT_PLR_ANG_Z,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	end_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	total,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void(vector org, float total) te_mis_flame = asm
{
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	STAT_PLR_REP,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	total,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void(vector org) te_mis_expl = asm
{
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	TE_MIS_EXPL,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	DONE;
}

void(vector org, float total, float armor) te_laser_hit = asm
{
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	TE_LAS_HIT,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	total,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	armor,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void(vector org, vector angl, vector vel, float teType, float total) te_muzzle_generic = asm
{
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	teType,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	angl_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	angl_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	angl_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	vel_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	vel_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	vel_z,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	total,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void() te_nav_reach = asm
{
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	TE_NAV_REACH,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void(float type) te_objective_complete = asm
{
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	TE_OBJECTIVE_COMPLETE,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	type,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void() te_objective_failed = asm
{
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	TE_OBJECTIVE_FAILED,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void() te_mission_win = asm
{
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	TE_MISSION_WIN,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void() te_mission_lose = asm
{
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	TE_MISSION_LOSE,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

void() te_msn_boundary = asm
{
	STORE_ENT	self,	msg_entity;
	STORE_F	TRUE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	TRUE,	parm0_x;
	STORE_F	TE_MSN_BOUND,	parm1_x;
	CALL2		WriteByte;
	DONE;
}

float DOOR_START_OPEN;
float DOOR_DONT_LINK;
float DOOR_GOLD_KEY;
float DOOR_SILVER_KEY;
float DOOR_TOGGLE;
void () door_go_down;
void () door_go_up;
void () door_blocked;
void() door_blocked = asm
{
local float temp_1;
	INDIRECT_F	self,	dmg,	temp_1;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	temp_1,	parm3_x;
	CALL4		T_Damage;
	INDIRECT_F	self,	wait,	temp_1;
	GE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	7;
	INDIRECT_F	self,	state,	temp_1;
	EQ_F		temp_1,	MOVETYPE_WALK,	temp_1;
	IFNOT		temp_1,	3;
	CALL0		door_go_up;
	GOTO		2;
	CALL0		door_go_down;
	DONE;
}

void () door_hit_top;
void() door_hit_top = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_S	self,	noise1,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	state,	temp_1;
	STOREP_F	FALSE,	temp_1;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	ADDRESS	self,	think,	temp_1;
	STOREP_FNC	door_go_down,	temp_1;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	ltime,	temp_3;
	INDIRECT_F	self,	wait,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	DONE;
}

void () door_hit_bottom;
void() door_hit_bottom = asm
{
local float temp_1;
	INDIRECT_S	self,	noise1,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	state,	temp_1;
	STOREP_F	TRUE,	temp_1;
	DONE;
}

void() door_go_down = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
	INDIRECT_S	self,	noise2,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_F	self,	max_health,	temp_1;
	IFNOT		temp_1,	6;
	ADDRESS	self,	takedamage,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	self,	health,	temp_1;
	INDIRECT_F	self,	max_health,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	state,	temp_1;
	STOREP_F	MOVETYPE_WALK,	temp_1;
	INDIRECT_V	self,	pos1_x,	temp_0;
	INDIRECT_F	self,	speed,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_1,	parm1_x;
	STORE_F	door_hit_bottom,	parm2_x;
	CALL3		SUB_CalcMove;
	DONE;
}

void() door_go_up = asm
{
local vector temp_0;
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_F	self,	state,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	state,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	7;
	ADDRESS	self,	nextthink,	temp_1;
	INDIRECT_F	self,	ltime,	temp_3;
	INDIRECT_F	self,	wait,	temp_4;
	ADD_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	RETURN	offset_0;
	INDIRECT_S	self,	noise2,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	state,	temp_1;
	STOREP_F	FL_SWIM,	temp_1;
	INDIRECT_V	self,	pos2_x,	temp_0;
	INDIRECT_F	self,	speed,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_1,	parm1_x;
	STORE_F	door_hit_top,	parm2_x;
	CALL3		SUB_CalcMove;
	CALL0		SUB_UseTargets;
	DONE;
}

void () door_fire;
void() door_fire = asm
{
local entity starte;
local entity oself;
local float temp_1;
local float temp_3;
	INDIRECT_E	self,	owner,	temp_1;
	NE_E		temp_1,	self,	temp_1;
	IFNOT		temp_1,	3;
	STORE_F	"door_fire: self.owner != self",	parm0_x;
	CALL1		objerror;
	INDIRECT_F	self,	items,	temp_1;
	IFNOT		temp_1,	8;
	INDIRECT_S	self,	noise4,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	message,	temp_1;
	STOREP_S	string_null,	temp_1;
	STORE_ENT	self,	oself;
	INDIRECT_F	self,	spawnflags,	temp_1;
	BITAND	temp_1,	FL_MONSTER,	temp_1;
	IFNOT		temp_1,	18;
	INDIRECT_F	self,	state,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IF		temp_1,	3;
	INDIRECT_F	self,	state,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	OR		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	11;
	STORE_ENT	self,	starte;
	CALL0		door_go_down;
	INDIRECT_E	self,	enemy,	self;
	NE_E		self,	starte,	temp_1;
	IFNOT		temp_1,	2;
	NE_E		self,	world,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IF		temp_1,	-6;
	STORE_ENT	oself,	self;
	RETURN	offset_0;
	STORE_ENT	self,	starte;
	CALL0		door_go_up;
	INDIRECT_E	self,	enemy,	self;
	NE_E		self,	starte,	temp_1;
	IFNOT		temp_1,	2;
	NE_E		self,	world,	temp_3;
	AND		temp_1,	temp_3,	temp_1;
	IF		temp_1,	-6;
	STORE_ENT	oself,	self;
	DONE;
}

void () door_use;
void() door_use = asm
{
local entity oself;
local float temp_1;
	ADDRESS	self,	message,	temp_1;
	STOREP_S	"",	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	message,	temp_1;
	STOREP_S	"",	temp_1;
	INDIRECT_E	self,	enemy,	temp_1;
	ADDRESS	temp_1,	message,	temp_1;
	STOREP_S	"",	temp_1;
	STORE_ENT	self,	oself;
	INDIRECT_E	self,	owner,	self;
	CALL0		door_fire;
	STORE_ENT	oself,	self;
	DONE;
}

void () door_trigger_touch;
void() door_trigger_touch = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_F	other,	health,	temp_1;
	LE		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	attack_finished,	temp_1;
	LT		time,	temp_1,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	ADDRESS	self,	attack_finished,	temp_1;
	ADD_F		time,	TRUE,	temp_3;
	STOREP_F	temp_3,	temp_1;
	STORE_ENT	other,	activator;
	INDIRECT_E	self,	owner,	self;
	CALL0		door_use;
	DONE;
}

void () door_killed;
void() door_killed = asm
{
local entity oself;
local float temp_1;
local float temp_3;
	STORE_ENT	self,	oself;
	INDIRECT_E	self,	owner,	self;
	ADDRESS	self,	health,	temp_1;
	INDIRECT_F	self,	max_health,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	takedamage,	temp_1;
	STOREP_F	FALSE,	temp_1;
	CALL0		door_use;
	STORE_ENT	oself,	self;
	DONE;
}

void () door_touch;
void() door_touch = asm
{
local float temp_1;
local float temp_3;
local float temp_4;
	INDIRECT_S	other,	classname,	temp_1;
	NE_S		temp_1,	"player",	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	attack_finished,	temp_1;
	GT		temp_1,	time,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_E	self,	owner,	temp_1;
	ADDRESS	temp_1,	attack_finished,	temp_1;
	ADD_F		time,	FL_SWIM,	temp_3;
	STOREP_F	temp_3,	temp_1;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_S	temp_1,	message,	temp_1;
	NE_S		temp_1,	"",	temp_1;
	IFNOT		temp_1,	12;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_S	temp_1,	message,	temp_1;
	STORE_F	other,	parm0_x;
	STORE_F	temp_1,	parm1_x;
	CALL2		centerprint;
	STORE_F	other,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	"misc/talk.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_F	self,	items,	temp_1;
	NE_F		temp_1,	FALSE,	temp_1;
	IF		temp_1,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	items,	temp_1;
	INDIRECT_F	other,	items,	temp_3;
	BITAND	temp_1,	temp_3,	temp_1;
	INDIRECT_F	self,	items,	temp_3;
	NE_F		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	89;
	INDIRECT_E	self,	owner,	temp_1;
	INDIRECT_F	temp_1,	items,	temp_1;
	EQ_F		temp_1,	FL_NODE,	temp_1;
	IFNOT		temp_1,	43;
	INDIRECT_F	world,	worldtype,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	12;
	STORE_F	other,	parm0_x;
	STORE_F	"You need the silver keycard",	parm1_x;
	CALL2		centerprint;
	INDIRECT_S	self,	noise3,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	GOTO		28;
	INDIRECT_F	world,	worldtype,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	12;
	STORE_F	other,	parm0_x;
	STORE_F	"You need the silver runekey",	parm1_x;
	CALL2		centerprint;
	INDIRECT_S	self,	noise3,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	GOTO		14;
	INDIRECT_F	world,	worldtype,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_F	other,	parm0_x;
	STORE_F	"You need the silver key",	parm1_x;
	CALL2		centerprint;
	INDIRECT_S	self,	noise3,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	GOTO		42;
	INDIRECT_F	world,	worldtype,	temp_1;
	EQ_F		temp_1,	FL_SWIM,	temp_1;
	IFNOT		temp_1,	12;
	STORE_F	other,	parm0_x;
	STORE_F	"You need the gold keycard",	parm1_x;
	CALL2		centerprint;
	INDIRECT_S	self,	noise3,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	GOTO		28;
	INDIRECT_F	world,	worldtype,	temp_1;
	EQ_F		temp_1,	TRUE,	temp_1;
	IFNOT		temp_1,	12;
	STORE_F	other,	parm0_x;
	STORE_F	"You need the gold runekey",	parm1_x;
	CALL2		centerprint;
	INDIRECT_S	self,	noise3,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	GOTO		14;
	INDIRECT_F	world,	worldtype,	temp_1;
	EQ_F		temp_1,	FALSE,	temp_1;
	IFNOT		temp_1,	11;
	STORE_F	other,	parm0_x;
	STORE_F	"You need the gold key",	parm1_x;
	CALL2		centerprint;
	INDIRECT_S	self,	noise3,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_1,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	RETURN	offset_0;
	ADDRESS	other,	items,	temp_1;
	INDIRECT_F	other,	items,	temp_3;
	INDIRECT_F	self,	items,	temp_4;
	SUB_F		temp_3,	temp_4,	temp_3;
	STOREP_F	temp_3,	temp_1;
	ADDRESS	self,	touch,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	INDIRECT_E	self,	enemy,	temp_1;
	IFNOT		temp_1,	4;
	INDIRECT_E	self,	enemy,	temp_1;
	ADDRESS	temp_1,	touch,	temp_1;
	STOREP_FNC	SUB_Null,	temp_1;
	CALL0		door_use;
	DONE;
}

entity (vector, vector) spawn_field;
entity(vector fmins, vector fmaxs) spawn_field = asm
{
local vector t2;
local vector t1;
local entity trigger;
local vector temp_0;
local float temp_1;
local vector temp_2;
	CALL0		spawn;
	STORE_ENT	return_x,	trigger;
	ADDRESS	trigger,	movetype,	temp_1;
	STOREP_F	FALSE,	temp_1;
	ADDRESS	trigger,	solid,	temp_1;
	STOREP_F	TRUE,	temp_1;
	ADDRESS	trigger,	owner,	temp_1;
	STOREP_ENT	self,	temp_1;
	ADDRESS	trigger,	touch,	temp_1;
	STOREP_FNC	door_trigger_touch,	temp_1;
	STORE_V	fmins,	t1;
	STORE_V	fmaxs,	t2;
	SUB_V		t1,	'60.000000 60.000000 8.000000',	temp_0;
	ADD_V		t2,	'60.000000 60.000000 8.000000',	temp_2;
	STORE_F	trigger,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_2,	parm2;
	CALL3		setsize;
	RETURN	trigger;
	DONE;
}

float (entity, entity) EntitiesTouching;
float(entity e1, entity e2) EntitiesTouching = asm
{
local float temp_1;
local float temp_3;
	INDIRECT_F	e1,	mins_x,	temp_1;
	INDIRECT_F	e2,	maxs_x,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	INDIRECT_F	e1,	mins_y,	temp_1;
	INDIRECT_F	e2,	maxs_y,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	INDIRECT_F	e1,	mins_z,	temp_1;
	INDIRECT_F	e2,	maxs_z,	temp_3;
	GT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	INDIRECT_F	e1,	maxs_x,	temp_1;
	INDIRECT_F	e2,	mins_x,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	INDIRECT_F	e1,	maxs_y,	temp_1;
	INDIRECT_F	e2,	mins_y,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	INDIRECT_F	e1,	maxs_z,	temp_1;
	INDIRECT_F	e2,	mins_z,	temp_3;
	LT		temp_1,	temp_3,	temp_1;
	IFNOT		temp_1,	2;
	RETURN	FALSE;
	RETURN	TRUE;
	DONE;
}

void () LinkDoors;
void() LinkDoors = asm
{
local float locked_2932;
local vector cmaxs;
local vector cmins;
local entity starte;
local entity t;
local vector temp_0;
local float temp_3;
	INDIRECT_E	self,	enemy,	locked_2932;
	IFNOT		locked_2932,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	MOVETYPE_STEP,	locked_2932;
	IFNOT		locked_2932,	6;
	ADDRESS	self,	owner,	locked_2932;
	ADDRESS	self,	enemy,	temp_3;
	STOREP_ENT	self,	temp_3;
	STOREP_ENT	self,	locked_2932;
	RETURN	offset_0;
	INDIRECT_V	self,	mins_x,	cmins;
	INDIRECT_V	self,	maxs_x,	cmaxs;
	STORE_ENT	self,	starte;
	STORE_ENT	self,	t;
	ADDRESS	self,	owner,	locked_2932;
	STOREP_ENT	starte,	locked_2932;
	INDIRECT_F	self,	health,	locked_2932;
	IFNOT		locked_2932,	4;
	ADDRESS	starte,	health,	locked_2932;
	INDIRECT_F	self,	health,	temp_3;
	STOREP_F	temp_3,	locked_2932;
	INDIRECT_S	self,	targetname,	locked_2932;
	IFNOT		locked_2932,	4;
	ADDRESS	starte,	targetname,	locked_2932;
	INDIRECT_S	self,	targetname,	temp_3;
	STOREP_S	temp_3,	locked_2932;
	INDIRECT_S	self,	message,	locked_2932;
	NE_S		locked_2932,	"",	locked_2932;
	IFNOT		locked_2932,	4;
	ADDRESS	starte,	message,	locked_2932;
	INDIRECT_S	self,	message,	temp_3;
	STOREP_S	temp_3,	locked_2932;
	INDIRECT_S	self,	classname,	locked_2932;
	STORE_F	t,	parm0_x;
	STORE_F	classname,	parm1_x;
	STORE_F	locked_2932,	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	t;
	IF		t,	20;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	starte,	locked_2932;
	INDIRECT_E	self,	owner,	self;
	INDIRECT_F	self,	health,	locked_2932;
	IFNOT		locked_2932,	2;
	RETURN	offset_0;
	INDIRECT_S	self,	targetname,	locked_2932;
	IFNOT		locked_2932,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	items,	locked_2932;
	IFNOT		locked_2932,	2;
	RETURN	offset_0;
	INDIRECT_E	self,	owner,	locked_2932;
	ADDRESS	locked_2932,	trigger_field,	locked_2932;
	STORE_V	cmins,	parm0;
	STORE_V	cmaxs,	parm1;
	CALL2		spawn_field;
	STOREP_ENT	return_x,	locked_2932;
	RETURN	offset_0;
	STORE_F	self,	parm0_x;
	STORE_F	t,	parm1_x;
	CALL2		EntitiesTouching;
	IFNOT		return_x,	32;
	INDIRECT_E	t,	enemy,	locked_2932;
	IFNOT		locked_2932,	3;
	STORE_F	"cross connected doors",	parm0_x;
	CALL1		objerror;
	ADDRESS	self,	enemy,	locked_2932;
	STOREP_ENT	t,	locked_2932;
	STORE_ENT	t,	self;
	INDIRECT_F	t,	mins_x,	locked_2932;
	LT		locked_2932,	cmins_x,	locked_2932;
	IFNOT		locked_2932,	2;
	INDIRECT_F	t,	mins_x,	cmins_x;
	INDIRECT_F	t,	mins_y,	locked_2932;
	LT		locked_2932,	cmins_y,	locked_2932;
	IFNOT		locked_2932,	2;
	INDIRECT_F	t,	mins_y,	cmins_y;
	INDIRECT_F	t,	mins_z,	locked_2932;
	LT		locked_2932,	cmins_z,	locked_2932;
	IFNOT		locked_2932,	2;
	INDIRECT_F	t,	mins_z,	cmins_z;
	INDIRECT_F	t,	maxs_x,	locked_2932;
	GT		locked_2932,	cmaxs_x,	locked_2932;
	IFNOT		locked_2932,	2;
	INDIRECT_F	t,	maxs_x,	cmaxs_x;
	INDIRECT_F	t,	maxs_y,	locked_2932;
	GT		locked_2932,	cmaxs_y,	locked_2932;
	IFNOT		locked_2932,	2;
	INDIRECT_F	t,	maxs_y,	cmaxs_y;
	INDIRECT_F	t,	maxs_z,	locked_2932;
	GT		locked_2932,	cmaxs_z,	locked_2932;
	IFNOT		locked_2932,	2;
	INDIRECT_F	t,	maxs_z,	cmaxs_z;
	GOTO		-79;
	DONE;
}

void () func_door;
void() func_door = asm
{
local float locked_427;
local float locked_2790;
local float locked_2939;
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	INDIRECT_F	world,	worldtype,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	10;
	STORE_F	"doors/medtry.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"doors/meduse.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise3,	temp_3;
	STOREP_S	"doors/medtry.wav",	temp_3;
	ADDRESS	self,	noise4,	temp_3;
	STOREP_S	"doors/meduse.wav",	temp_3;
	GOTO		27;
	INDIRECT_F	world,	worldtype,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	10;
	STORE_F	"doors/runetry.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"doors/runeuse.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise3,	temp_3;
	STOREP_S	"doors/runetry.wav",	temp_3;
	ADDRESS	self,	noise4,	temp_3;
	STOREP_S	"doors/runeuse.wav",	temp_3;
	GOTO		15;
	INDIRECT_F	world,	worldtype,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	10;
	STORE_F	"doors/basetry.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"doors/baseuse.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise3,	temp_3;
	STOREP_S	"doors/basetry.wav",	temp_3;
	ADDRESS	self,	noise4,	temp_3;
	STOREP_S	"doors/baseuse.wav",	temp_3;
	GOTO		3;
	STORE_F	"no worldtype set!
",	parm0_x;
	CALL1		dprint;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	9;
	STORE_F	"misc/null.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"misc/null.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"misc/null.wav",	temp_3;
	ADDRESS	self,	noise2,	temp_3;
	STOREP_S	"misc/null.wav",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	9;
	STORE_F	"doors/drclos4.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"doors/doormv1.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"doors/drclos4.wav",	temp_3;
	ADDRESS	self,	noise2,	temp_3;
	STOREP_S	"doors/doormv1.wav",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	9;
	STORE_F	"doors/hydro1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"doors/hydro2.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise2,	temp_3;
	STOREP_S	"doors/hydro1.wav",	temp_3;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"doors/hydro2.wav",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	MOVETYPE_WALK,	temp_3;
	IFNOT		temp_3,	9;
	STORE_F	"doors/stndr1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"doors/stndr2.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise2,	temp_3;
	STOREP_S	"doors/stndr1.wav",	temp_3;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"doors/stndr2.wav",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	9;
	STORE_F	"doors/ddoor1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"doors/ddoor2.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"doors/ddoor2.wav",	temp_3;
	ADDRESS	self,	noise2,	temp_3;
	STOREP_S	"doors/ddoor1.wav",	temp_3;
	CALL0		SetMovedir;
	ADDRESS	self,	max_health,	temp_3;
	INDIRECT_F	self,	health,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	MOVETYPE_STEP,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_PUSH,	temp_3;
	INDIRECT_V	self,	origin_x,	locked_2939;
	STORE_F	self,	parm0_x;
	STORE_V	locked_2939,	parm1;
	CALL2		setorigin;
	INDIRECT_S	self,	model,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		setmodel;
	ADDRESS	self,	classname,	temp_3;
	STOREP_S	"door",	temp_3;
	ADDRESS	self,	blocked,	temp_3;
	STOREP_FNC	door_blocked,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	door_use,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_INWATER,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	items,	temp_3;
	STOREP_F	FL_NODE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	items,	temp_3;
	STOREP_F	IT_KEY2,	temp_3;
	INDIRECT_F	self,	speed,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	speed,	temp_3;
	STOREP_F	STAT_PLR_ANG_X,	temp_3;
	INDIRECT_F	self,	wait,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	MOVETYPE_WALK,	temp_3;
	INDIRECT_F	self,	lip,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	lip,	temp_3;
	STOREP_F	FL_CLIENT,	temp_3;
	INDIRECT_F	self,	dmg,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	dmg,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	ADDRESS	self,	pos1_x,	locked_2939;
	INDIRECT_V	self,	origin_x,	locked_2790;
	STOREP_V	locked_2790,	locked_2939;
	ADDRESS	self,	pos2_x,	locked_2939;
	INDIRECT_V	self,	pos1_x,	locked_2790;
	INDIRECT_V	self,	movedir_x,	locked_427;
	INDIRECT_V	self,	movedir_x,	temp_1;
	INDIRECT_V	self,	size_x,	temp_0;
	MUL_V		temp_1,	temp_0,	parm0_x;
	CALL1		fabs;
	INDIRECT_F	self,	lip,	temp_3;
	SUB_F		return_x,	temp_3,	temp_3;
	MUL_VF	locked_427,	temp_3,	temp_0;
	ADD_V		locked_2790,	temp_0,	temp_0;
	STOREP_V	temp_0_x,	locked_2939;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	11;
	INDIRECT_V	self,	pos2_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	pos2_x,	temp_0_x;
	INDIRECT_V	self,	pos1_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	self,	pos1_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	health,	temp_3;
	IFNOT		temp_3,	5;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	th_die,	temp_3;
	STOREP_FNC	door_killed,	temp_3;
	INDIRECT_F	self,	items,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	CONTENT_EMPTY,	temp_3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	door_touch,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	LinkDoors,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	ADD_F		temp_5,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () fd_secret_move1;
void () fd_secret_move2;
void () fd_secret_move3;
void () fd_secret_move4;
void () fd_secret_move5;
void () fd_secret_move6;
void () fd_secret_done;
float SECRET_OPEN_ONCE;
float SECRET_1ST_LEFT;
float SECRET_1ST_DOWN;
float SECRET_NO_SHOOT;
float SECRET_YES_SHOOT;
void () fd_secret_use;
void() fd_secret_use = asm
{
local float locked_2932;
local float temp;
local vector temp_0;
local vector temp_1;
local vector temp_2;
local float temp_5;
	ADDRESS	self,	health,	locked_2932;
	STOREP_F	DAT_BLD_H_SM_RADAR_RADAR_RANGE,	locked_2932;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	self,	oldorigin_x,	temp_1;
	NE_V		temp_0,	temp_1,	locked_2932;
	IFNOT		locked_2932,	2;
	RETURN	offset_0;
	ADDRESS	self,	message,	locked_2932;
	STOREP_S	string_null,	locked_2932;
	CALL0		SUB_UseTargets;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	FL_CLIENT,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	5;
	ADDRESS	self,	th_pain,	locked_2932;
	STOREP_FNC	SUB_Null,	locked_2932;
	ADDRESS	self,	takedamage,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	ADDRESS	self,	velocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	INDIRECT_S	self,	noise1,	locked_2932;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	locked_2932,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	nextthink,	locked_2932;
	INDIRECT_F	self,	ltime,	temp_5;
	ADD_F		temp_5,	0.100000,	temp_5;
	STOREP_F	temp_5,	locked_2932;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	FL_SWIM,	locked_2932;
	SUB_F		TRUE,	locked_2932,	temp;
	INDIRECT_V	self,	mangle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_F	self,	t_width,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	15;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	MOVETYPE_STEP,	locked_2932;
	IFNOT		locked_2932,	7;
	ADDRESS	self,	t_width,	locked_2932;
	INDIRECT_V	self,	size_x,	temp_0;
	MUL_V		v_up,	temp_0,	parm0_x;
	CALL1		fabs;
	STOREP_F	return_x,	locked_2932;
	GOTO		6;
	ADDRESS	self,	t_width,	locked_2932;
	INDIRECT_V	self,	size_x,	temp_0;
	MUL_V		v_right,	temp_0,	parm0_x;
	CALL1		fabs;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	t_length,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	6;
	ADDRESS	self,	t_length,	locked_2932;
	INDIRECT_V	self,	size_x,	temp_0;
	MUL_V		v_forward,	temp_0,	parm0_x;
	CALL1		fabs;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	MOVETYPE_STEP,	locked_2932;
	IFNOT		locked_2932,	8;
	ADDRESS	self,	dest1_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_1;
	INDIRECT_F	self,	t_width,	locked_2932;
	MUL_VF	v_up,	locked_2932,	temp_2;
	SUB_V		temp_1,	temp_2,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	GOTO		8;
	ADDRESS	self,	dest1_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_1;
	INDIRECT_F	self,	t_width,	locked_2932;
	MUL_F		locked_2932,	temp,	locked_2932;
	MUL_VF	v_right,	locked_2932,	temp_2;
	ADD_V		temp_1,	temp_2,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	self,	dest2_x,	temp_0_x;
	INDIRECT_V	self,	dest1_x,	temp_1;
	INDIRECT_F	self,	t_length,	locked_2932;
	MUL_VF	v_forward,	locked_2932,	temp_2;
	ADD_V		temp_1,	temp_2,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	INDIRECT_V	self,	dest1_x,	temp_0;
	INDIRECT_F	self,	speed,	locked_2932;
	STORE_V	temp_0,	parm0;
	STORE_F	locked_2932,	parm1_x;
	STORE_F	fd_secret_move1,	parm2_x;
	CALL3		SUB_CalcMove;
	INDIRECT_S	self,	noise2,	locked_2932;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	locked_2932,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

void() fd_secret_move1 = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	ADD_F		temp_5,	TRUE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	fd_secret_move2,	temp_3;
	INDIRECT_S	self,	noise3,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

void() fd_secret_move2 = asm
{
local vector temp_0;
local float temp_3;
	INDIRECT_S	self,	noise2,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_V	self,	dest2_x,	temp_0;
	INDIRECT_F	self,	speed,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_3,	parm1_x;
	STORE_F	fd_secret_move3,	parm2_x;
	CALL3		SUB_CalcMove;
	DONE;
}

void() fd_secret_move3 = asm
{
local float temp_3;
local float temp_5;
local float temp_6;
	INDIRECT_S	self,	noise3,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	8;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	INDIRECT_F	self,	wait,	temp_6;
	ADD_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	fd_secret_move4,	temp_3;
	DONE;
}

void() fd_secret_move4 = asm
{
local vector temp_0;
local float temp_3;
	INDIRECT_S	self,	noise2,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_V	self,	dest1_x,	temp_0;
	INDIRECT_F	self,	speed,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_3,	parm1_x;
	STORE_F	fd_secret_move5,	parm2_x;
	CALL3		SUB_CalcMove;
	DONE;
}

void() fd_secret_move5 = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	ADD_F		temp_5,	TRUE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	fd_secret_move6,	temp_3;
	INDIRECT_S	self,	noise3,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

void() fd_secret_move6 = asm
{
local vector temp_0;
local float temp_3;
	INDIRECT_S	self,	noise2,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_V	self,	oldorigin_x,	temp_0;
	INDIRECT_F	self,	speed,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_3,	parm1_x;
	STORE_F	fd_secret_done,	parm2_x;
	CALL3		SUB_CalcMove;
	DONE;
}

void() fd_secret_done = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_S	self,	targetname,	temp_3;
	NOT_S		temp_3,	temp_3;
	IF		temp_3,	3;
	INDIRECT_F	self,	spawnflags,	temp_5;
	BITAND	temp_5,	FL_INWATER,	temp_5;
	OR		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	health,	temp_3;
	STOREP_F	DAT_BLD_H_SM_RADAR_RADAR_RANGE,	temp_3;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	th_pain,	temp_3;
	STOREP_FNC	fd_secret_use,	temp_3;
	INDIRECT_S	self,	noise3,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

void () secret_blocked;
void() secret_blocked = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	attack_finished,	temp_3;
	LT		time,	temp_3,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	ADDRESS	self,	attack_finished,	temp_3;
	ADD_F		time,	0.500000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	dmg,	temp_3;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	CALL4		T_Damage;
	DONE;
}

void () secret_touch;
void() secret_touch = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_S	other,	classname,	temp_3;
	NE_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	attack_finished,	temp_3;
	GT		temp_3,	time,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	ADDRESS	self,	attack_finished,	temp_3;
	ADD_F		time,	FL_SWIM,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_S	self,	message,	temp_3;
	IFNOT		temp_3,	11;
	INDIRECT_S	self,	message,	temp_3;
	STORE_F	other,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		centerprint;
	STORE_F	other,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	"misc/talk.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

void () func_door_secret;
void() func_door_secret = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	sounds,	temp_3;
	STOREP_F	MOVETYPE_WALK,	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	13;
	STORE_F	"doors/latch2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"doors/winch2.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"doors/drclos4.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"doors/latch2.wav",	temp_3;
	ADDRESS	self,	noise2,	temp_3;
	STOREP_S	"doors/winch2.wav",	temp_3;
	ADDRESS	self,	noise3,	temp_3;
	STOREP_S	"doors/drclos4.wav",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	11;
	STORE_F	"doors/airdoor1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"doors/airdoor2.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise2,	temp_3;
	STOREP_S	"doors/airdoor1.wav",	temp_3;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"doors/airdoor2.wav",	temp_3;
	ADDRESS	self,	noise3,	temp_3;
	STOREP_S	"doors/airdoor2.wav",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	MOVETYPE_WALK,	temp_3;
	IFNOT		temp_3,	11;
	STORE_F	"doors/basesec1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"doors/basesec2.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise2,	temp_3;
	STOREP_S	"doors/basesec1.wav",	temp_3;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"doors/basesec2.wav",	temp_3;
	ADDRESS	self,	noise3,	temp_3;
	STOREP_S	"doors/basesec2.wav",	temp_3;
	INDIRECT_F	self,	dmg,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	dmg,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	ADDRESS	self,	mangle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	MOVETYPE_STEP,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_PUSH,	temp_3;
	ADDRESS	self,	classname,	temp_3;
	STOREP_S	"door",	temp_3;
	INDIRECT_S	self,	model,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		setmodel;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	secret_touch,	temp_3;
	ADDRESS	self,	blocked,	temp_3;
	STOREP_FNC	secret_blocked,	temp_3;
	ADDRESS	self,	speed,	temp_3;
	STOREP_F	TE_BLOOD,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	fd_secret_use,	temp_3;
	INDIRECT_S	self,	targetname,	temp_3;
	NOT_S		temp_3,	temp_3;
	IF		temp_3,	3;
	INDIRECT_F	self,	spawnflags,	temp_5;
	BITAND	temp_5,	FL_INWATER,	temp_5;
	OR		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	9;
	ADDRESS	self,	health,	temp_3;
	STOREP_F	DAT_BLD_H_SM_RADAR_RADAR_RANGE,	temp_3;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	th_pain,	temp_3;
	STOREP_FNC	fd_secret_use,	temp_3;
	ADDRESS	self,	th_die,	temp_3;
	STOREP_FNC	fd_secret_use,	temp_3;
	ADDRESS	self,	oldorigin_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	INDIRECT_F	self,	wait,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	MOVETYPE_FLY,	temp_3;
	DONE;
}

void () button_wait;
void () button_return;
void() button_wait = asm
{
local float temp_3;
local float temp_5;
local float temp_6;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	INDIRECT_F	self,	wait,	temp_6;
	ADD_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	button_return,	temp_3;
	INDIRECT_E	self,	enemy,	activator;
	CALL0		SUB_UseTargets;
	ADDRESS	self,	frame,	temp_3;
	STOREP_F	TRUE,	temp_3;
	DONE;
}

void () button_done;
void() button_done = asm
{
local float temp_3;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	TRUE,	temp_3;
	DONE;
}

void() button_return = asm
{
local vector temp_0;
local float temp_3;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	MOVETYPE_WALK,	temp_3;
	INDIRECT_V	self,	pos1_x,	temp_0;
	INDIRECT_F	self,	speed,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_3,	parm1_x;
	STORE_F	button_done,	parm2_x;
	CALL3		SUB_CalcMove;
	ADDRESS	self,	frame,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_F	self,	health,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	TRUE,	temp_3;
	DONE;
}

void () button_blocked;
void() button_blocked = asm
{
	DONE;
}

void () button_fire;
void() button_fire = asm
{
local vector temp_0;
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	state,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IF		temp_3,	3;
	INDIRECT_F	self,	state,	temp_5;
	EQ_F		temp_5,	FALSE,	temp_5;
	OR		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_S	self,	noise,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	INDIRECT_V	self,	pos2_x,	temp_0;
	INDIRECT_F	self,	speed,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_3,	parm1_x;
	STORE_F	button_wait,	parm2_x;
	CALL3		SUB_CalcMove;
	DONE;
}

void () button_use;
void() button_use = asm
{
local float temp_3;
	ADDRESS	self,	enemy,	temp_3;
	STOREP_ENT	activator,	temp_3;
	CALL0		button_fire;
	DONE;
}

void () button_touch;
void() button_touch = asm
{
local float temp_3;
	INDIRECT_S	other,	classname,	temp_3;
	NE_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	ADDRESS	self,	enemy,	temp_3;
	STOREP_ENT	other,	temp_3;
	CALL0		button_fire;
	DONE;
}

void () button_killed;
void() button_killed = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	enemy,	temp_3;
	STOREP_ENT	damage_attacker,	temp_3;
	ADDRESS	self,	health,	temp_3;
	INDIRECT_F	self,	max_health,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	FALSE,	temp_3;
	CALL0		button_fire;
	DONE;
}

void () func_button;
void() func_button = asm
{
local float locked_2939;
local float locked_5666;
local float locked_5669;
local float ftemp;
local float gtemp;
local float temp_3;
local vector temp_4;
local float temp_5;
local vector temp_7;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	5;
	STORE_F	"buttons/airbut1.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"buttons/airbut1.wav",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	5;
	STORE_F	"buttons/switch21.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"buttons/switch21.wav",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	5;
	STORE_F	"buttons/switch02.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"buttons/switch02.wav",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	MOVETYPE_WALK,	temp_3;
	IFNOT		temp_3,	5;
	STORE_F	"buttons/switch04.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"buttons/switch04.wav",	temp_3;
	CALL0		SetMovedir;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_PUSH,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	MOVETYPE_STEP,	temp_3;
	INDIRECT_S	self,	model,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		setmodel;
	ADDRESS	self,	blocked,	temp_3;
	STOREP_FNC	button_blocked,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	button_use,	temp_3;
	INDIRECT_F	self,	health,	temp_3;
	IFNOT		temp_3,	9;
	ADDRESS	self,	max_health,	temp_3;
	INDIRECT_F	self,	health,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	th_die,	temp_3;
	STOREP_FNC	button_killed,	temp_3;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	TRUE,	temp_3;
	GOTO		3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	button_touch,	temp_3;
	INDIRECT_F	self,	speed,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	speed,	temp_3;
	STOREP_F	STAT_PLR_ORG_X,	temp_3;
	INDIRECT_F	self,	wait,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	lip,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	lip,	temp_3;
	STOREP_F	MOVETYPE_STEP,	temp_3;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	pos1_x,	locked_5669;
	INDIRECT_V	self,	origin_x,	locked_5666;
	STOREP_V	locked_5666,	locked_5669;
	ADDRESS	self,	pos2_x,	locked_5669;
	INDIRECT_V	self,	pos1_x,	locked_5666;
	INDIRECT_V	self,	movedir_x,	locked_2939;
	INDIRECT_V	self,	movedir_x,	temp_4;
	INDIRECT_V	self,	size_x,	temp_7;
	MUL_V		temp_4,	temp_7,	parm0_x;
	CALL1		fabs;
	INDIRECT_F	self,	lip,	temp_3;
	SUB_F		return_x,	temp_3,	temp_3;
	MUL_VF	locked_2939,	temp_3,	locked_2939;
	ADD_V		locked_5666,	locked_2939,	locked_5666;
	STOREP_V	locked_5666,	locked_5669;
	DONE;
}

void(entity active, .string event) trigger_event = asm
{
local entity hold;
local string oldTarget;
local float temp_3;
local float temp_5;
	NE_E		active,	self,	temp_3;
	IFNOT		temp_3,	3;
	STORE_ENT	self,	hold;
	STORE_ENT	active,	self;
	INDIRECT_S	self,	event,	temp_3;
	IFNOT		temp_3,	9;
	INDIRECT_S	self,	target,	oldTarget;
	ADDRESS	self,	target,	temp_3;
	INDIRECT_S	self,	event,	temp_5;
	STOREP_S	temp_5,	temp_3;
	STORE_ENT	hold,	activator;
	CALL0		SUB_UseTargets;
	ADDRESS	self,	event,	temp_3;
	STOREP_S	string_null,	temp_3;
	ADDRESS	self,	target,	temp_3;
	STOREP_S	oldTarget,	temp_3;
	NE_E		active,	self,	temp_3;
	IFNOT		temp_3,	2;
	STORE_ENT	hold,	self;
	DONE;
}

void() trigger_activate_node = asm
{
	DONE;
}

void() trigger_reactivate = asm
{
local float temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	DONE;
}

void() multi_wait = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	max_health,	temp_3;
	IFNOT		temp_3,	8;
	ADDRESS	self,	health,	temp_3;
	INDIRECT_F	self,	max_health,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	DONE;
}

void() multi_trigger = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	nextthink,	temp_3;
	GT		temp_3,	time,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_S	self,	classname,	temp_3;
	EQ_S		temp_3,	"trigger_secret",	temp_3;
	IFNOT		temp_3,	10;
	INDIRECT_E	self,	enemy,	temp_3;
	INDIRECT_S	temp_3,	classname,	temp_3;
	NE_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	ADD_F		found_secrets,	TRUE,	found_secrets;
	STORE_F	FL_SWIM,	parm0_x;
	STORE_F	SVC_FOUNDSECRET,	parm1_x;
	CALL2		WriteByte;
	INDIRECT_S	self,	noise,	temp_3;
	IFNOT		temp_3,	8;
	INDIRECT_S	self,	noise,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_E	self,	enemy,	activator;
	CALL0		SUB_UseTargets;
	INDIRECT_F	self,	wait,	temp_3;
	GT		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	8;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	multi_wait,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	wait,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	GOTO		8;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	SUB_Null,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	DONE;
}

void() multi_killed = asm
{
local float temp_3;
	ADDRESS	self,	enemy,	temp_3;
	STOREP_ENT	damage_attacker,	temp_3;
	CALL0		multi_trigger;
	DONE;
}

void() multi_use = asm
{
local float temp_3;
	ADDRESS	self,	enemy,	temp_3;
	STOREP_ENT	activator,	temp_3;
	CALL0		multi_trigger;
	DONE;
}

void() multi_touch = asm
{
local vector temp_0;
local float temp_3;
	INDIRECT_S	other,	classname,	temp_3;
	NE_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_V	self,	movedir_x,	temp_0;
	NE_V		temp_0,	VEC_ORIGIN,	temp_3;
	IFNOT		temp_3,	8;
	INDIRECT_V	other,	angles_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	self,	movedir_x,	temp_0;
	MUL_V		v_forward,	temp_0,	temp_3;
	LT		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	ADDRESS	self,	enemy,	temp_3;
	STOREP_ENT	other,	temp_3;
	CALL0		multi_trigger;
	DONE;
}

void() trigger_multiple = asm
{
local vector temp_0;
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	6;
	STORE_F	"misc/secret.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/secret.wav",	temp_3;
	GOTO		16;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	6;
	STORE_F	"misc/talk.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/talk.wav",	temp_3;
	GOTO		8;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	MOVETYPE_WALK,	temp_3;
	IFNOT		temp_3,	5;
	STORE_F	"misc/trigger1.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/trigger1.wav",	temp_3;
	INDIRECT_F	self,	wait,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	DAT_LATC_RL_RATE,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	multi_use,	temp_3;
	CALL0		InitTrigger;
	INDIRECT_F	self,	health,	temp_3;
	IFNOT		temp_3,	20;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	"health and notouch don't make sense
",	parm0_x;
	CALL1		objerror;
	ADDRESS	self,	max_health,	temp_3;
	INDIRECT_F	self,	health,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	th_die,	temp_3;
	STOREP_FNC	multi_killed,	temp_3;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	GOTO		7;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	multi_touch,	temp_3;
	DONE;
}

void() trigger_once = asm
{
local float temp_3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	CONTENT_EMPTY,	temp_3;
	CALL0		trigger_multiple;
	DONE;
}

void() trigger_relay = asm
{
local float temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	SUB_UseTargets,	temp_3;
	DONE;
}

void() trigger_secret = asm
{
local float temp_3;
	ADD_F		total_secrets,	TRUE,	total_secrets;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	CONTENT_EMPTY,	temp_3;
	INDIRECT_S	self,	message,	temp_3;
	NOT_S		temp_3,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	message,	temp_3;
	STOREP_S	"You found a secret area!",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	sounds,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	6;
	STORE_F	"misc/secret.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/secret.wav",	temp_3;
	GOTO		8;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	5;
	STORE_F	"misc/talk.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/talk.wav",	temp_3;
	CALL0		trigger_multiple;
	DONE;
}

void() counter_use = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	count,	temp_3;
	INDIRECT_F	self,	count,	temp_5;
	SUB_F		temp_5,	TRUE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	count,	temp_3;
	LT		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	count,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	34;
	INDIRECT_S	activator,	classname,	temp_3;
	EQ_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	4;
	INDIRECT_F	self,	spawnflags,	temp_5;
	BITAND	temp_5,	TRUE,	temp_5;
	EQ_F		temp_5,	FALSE,	temp_5;
	AND		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	25;
	INDIRECT_F	self,	count,	temp_3;
	GE		temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	5;
	STORE_F	activator,	parm0_x;
	STORE_F	"There are more to go...",	parm1_x;
	CALL2		centerprint;
	GOTO		18;
	INDIRECT_F	self,	count,	temp_3;
	EQ_F		temp_3,	MOVETYPE_WALK,	temp_3;
	IFNOT		temp_3,	5;
	STORE_F	activator,	parm0_x;
	STORE_F	"Only 3 more to go...",	parm1_x;
	CALL2		centerprint;
	GOTO		11;
	INDIRECT_F	self,	count,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	5;
	STORE_F	activator,	parm0_x;
	STORE_F	"Only 2 more to go...",	parm1_x;
	CALL2		centerprint;
	GOTO		4;
	STORE_F	activator,	parm0_x;
	STORE_F	"Only 1 more to go...",	parm1_x;
	CALL2		centerprint;
	RETURN	offset_0;
	INDIRECT_S	activator,	classname,	temp_3;
	EQ_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	4;
	INDIRECT_F	self,	spawnflags,	temp_5;
	BITAND	temp_5,	TRUE,	temp_5;
	EQ_F		temp_5,	FALSE,	temp_5;
	AND		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	4;
	STORE_F	activator,	parm0_x;
	STORE_F	"Sequence completed!",	parm1_x;
	CALL2		centerprint;
	ADDRESS	self,	enemy,	temp_3;
	STOREP_ENT	activator,	temp_3;
	CALL0		multi_trigger;
	DONE;
}

void() trigger_counter = asm
{
local float temp_3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	CONTENT_EMPTY,	temp_3;
	INDIRECT_F	self,	count,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	count,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	counter_use,	temp_3;
	DONE;
}

void() play_teleport = asm
{
local string tmpstr;
local float v;
local float temp_3;
	CALL0		random;
	MUL_F		return_x,	MOVETYPE_FLY,	v;
	LT		v,	TRUE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_S	"misc/r_tele1.wav",	tmpstr;
	GOTO		14;
	LT		v,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	3;
	STORE_S	"misc/r_tele2.wav",	tmpstr;
	GOTO		10;
	LT		v,	MOVETYPE_WALK,	temp_3;
	IFNOT		temp_3,	3;
	STORE_S	"misc/r_tele3.wav",	tmpstr;
	GOTO		6;
	LT		v,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	3;
	STORE_S	"misc/r_tele4.wav",	tmpstr;
	GOTO		2;
	STORE_S	"misc/r_tele5.wav",	tmpstr;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	tmpstr,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void(vector org) spawn_tfog = asm
{
local vector temp_0;
local float temp_3;
local float temp_5;
	CALL0		spawn;
	STORE_ENT	return_x,	s;
	ADDRESS	s,	origin_x,	temp_0_x;
	STOREP_V	org_x,	temp_0;
	ADDRESS	s,	nextthink,	temp_3;
	ADD_F		time,	DAT_LATC_RL_RATE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	s,	think,	temp_3;
	STOREP_FNC	play_teleport,	temp_3;
	STORE_F	FALSE,	parm0_x;
	STORE_F	SVC_TEMPENTITY,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	MOVETYPE_BOUNCEMISSILE,	parm1_x;
	CALL2		WriteByte;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_x,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_y,	parm1_x;
	CALL2		WriteCoord;
	STORE_F	FALSE,	parm0_x;
	STORE_F	org_z,	parm1_x;
	CALL2		WriteCoord;
	DONE;
}

void() tdeath_touch = asm
{
local float temp_3;
	INDIRECT_E	self,	owner,	temp_3;
	EQ_E		other,	temp_3,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	health,	temp_3;
	IFNOT		temp_3,	6;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	50000.000000,	parm3_x;
	CALL4		T_Damage;
	DONE;
}

void(vector org, entity death_owner) spawn_tdeath = asm
{
local entity death;
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	CALL0		spawn;
	STORE_ENT	return_x,	death;
	ADDRESS	death,	classname,	temp_3;
	STOREP_S	"teledeath",	temp_3;
	ADDRESS	death,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	death,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	death,	angles_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	INDIRECT_V	death_owner,	mins_x,	temp_0;
	SUB_V		temp_0,	'1.000000 1.000000 1.000000',	temp_0;
	INDIRECT_V	death_owner,	maxs_x,	temp_1;
	ADD_V		temp_1,	'1.000000 1.000000 1.000000',	temp_1;
	STORE_F	death,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_1,	parm2;
	CALL3		setsize;
	STORE_F	death,	parm0_x;
	STORE_V	org,	parm1;
	CALL2		setorigin;
	ADDRESS	death,	touch,	temp_3;
	STOREP_FNC	tdeath_touch,	temp_3;
	ADDRESS	death,	nextthink,	temp_3;
	ADD_F		time,	DAT_LATC_RL_RATE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	death,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	death,	owner,	temp_3;
	STOREP_ENT	death_owner,	temp_3;
	STORE_F	FL_SWIM,	force_retouch;
	DONE;
}

void() teleport_touch = asm
{
local vector org;
local entity t;
local vector temp_0;
local vector temp_1;
local vector temp_2;
local float temp_3;
local float temp_5;
local float temp_6;
	INDIRECT_S	self,	targetname,	temp_3;
	IFNOT		temp_3,	5;
	INDIRECT_F	self,	nextthink,	temp_3;
	LT		temp_3,	time,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	5;
	INDIRECT_S	other,	classname,	temp_3;
	NE_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	health,	temp_3;
	LE		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	INDIRECT_F	other,	solid,	temp_5;
	NE_F		temp_5,	MOVETYPE_WALK,	temp_5;
	OR		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	CALL0		SUB_UseTargets;
	INDIRECT_V	other,	origin_x,	parm0;
	CALL1		spawn_tfog;
	INDIRECT_S	self,	target,	temp_3;
	STORE_F	world,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	t;
	IF		t,	3;
	STORE_F	"couldn't find target",	parm0_x;
	CALL1		objerror;
	INDIRECT_V	t,	mangle_x,	parm0;
	CALL1		makevectors;
	INDIRECT_V	t,	origin_x,	temp_0;
	MUL_FV	FL_MONSTER,	v_forward,	temp_1;
	ADD_V		temp_0,	temp_1,	org;
	STORE_V	org,	parm0;
	CALL1		spawn_tfog;
	INDIRECT_V	t,	origin_x,	parm0;
	STORE_F	other,	parm1_x;
	CALL2		spawn_tdeath;
	INDIRECT_F	other,	health,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	12;
	ADDRESS	other,	origin_x,	temp_0_x;
	INDIRECT_V	t,	origin_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	other,	velocity_x,	temp_0_x;
	INDIRECT_F	other,	velocity_x,	temp_3;
	MUL_VF	v_forward,	temp_3,	temp_1;
	INDIRECT_F	other,	velocity_y,	temp_3;
	MUL_VF	v_forward,	temp_3,	temp_2;
	ADD_V		temp_1,	temp_2,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	RETURN	offset_0;
	INDIRECT_V	t,	origin_x,	temp_0;
	STORE_F	other,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	other,	angles_x,	temp_0_x;
	INDIRECT_V	t,	mangle_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	INDIRECT_S	other,	classname,	temp_3;
	EQ_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	16;
	ADDRESS	other,	fixangle,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	other,	teleport_time,	temp_3;
	ADD_F		time,	DAT_MNT_SHIELD_RATE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_ONGROUND,	temp_3;
	IFNOT		temp_3,	5;
	ADDRESS	other,	flags,	temp_3;
	INDIRECT_F	other,	flags,	temp_5;
	SUB_F		temp_5,	FL_ONGROUND,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	other,	velocity_x,	temp_0_x;
	MUL_VF	v_forward,	DAT_PRJ_ABT_CLST_VELOCITY,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	other,	flags,	temp_3;
	INDIRECT_F	other,	flags,	temp_5;
	INDIRECT_F	other,	flags,	temp_6;
	BITAND	temp_6,	FL_ONGROUND,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void() info_teleport_destination = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
	ADDRESS	self,	mangle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	model,	temp_3;
	STOREP_S	"",	temp_3;
	ADDRESS	self,	origin_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_1;
	ADD_V		temp_1,	'0.000000 0.000000 27.000000',	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	INDIRECT_S	self,	targetname,	temp_3;
	NOT_S		temp_3,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	"no targetname",	parm0_x;
	CALL1		objerror;
	DONE;
}

void() teleport_use = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	DAT_LATC_RL_RATE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	STORE_F	FL_SWIM,	force_retouch;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Null,	temp_3;
	DONE;
}

void() trigger_teleport = asm
{
local vector o;
local vector temp_0;
local vector temp_1;
local float temp_3;
	CALL0		InitTrigger;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	teleport_touch,	temp_3;
	INDIRECT_S	self,	target,	temp_3;
	NOT_S		temp_3,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	"no target",	parm0_x;
	CALL1		objerror;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	teleport_use,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	12;
	STORE_F	"ambience/hum1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	ADD_V		temp_0,	temp_1,	temp_0;
	MUL_VF	temp_0,	0.500000,	o;
	STORE_V	o,	parm0;
	STORE_F	"ambience/hum1.wav",	parm1_x;
	STORE_F	0.500000,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void() trigger_skill_touch = asm
{
local float temp_3;
	INDIRECT_S	other,	classname,	temp_3;
	NE_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_S	self,	message,	temp_3;
	STORE_F	"skill",	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		cvar_set;
	DONE;
}

void() trigger_setskill = asm
{
local float temp_3;
	CALL0		InitTrigger;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	trigger_skill_touch,	temp_3;
	DONE;
}

void() trigger_onlyregistered_touch = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_S	other,	classname,	temp_3;
	NE_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	attack_finished,	temp_3;
	GT		temp_3,	time,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	ADDRESS	self,	attack_finished,	temp_3;
	ADD_F		time,	FL_SWIM,	temp_5;
	STOREP_F	temp_5,	temp_3;
	STORE_F	"registered",	parm0_x;
	CALL1		cvar;
	IFNOT		return_x,	7;
	ADDRESS	self,	message,	temp_3;
	STOREP_S	"",	temp_3;
	CALL0		SUB_UseTargets;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	GOTO		14;
	INDIRECT_S	self,	message,	temp_3;
	NE_S		temp_3,	"",	temp_3;
	IFNOT		temp_3,	11;
	INDIRECT_S	self,	message,	temp_3;
	STORE_F	other,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		centerprint;
	STORE_F	other,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	"misc/talk.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

void() trigger_onlyregistered = asm
{
local float temp_3;
	STORE_F	"misc/talk.wav",	parm0_x;
	CALL1		precache_sound;
	CALL0		InitTrigger;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	trigger_onlyregistered_touch,	temp_3;
	DONE;
}

void() hurt_on = asm
{
local float temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	STOREP_F	CONTENT_EMPTY,	temp_3;
	DONE;
}

void() hurt_touch = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	other,	takedamage,	temp_3;
	IFNOT		temp_3,	14;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_F	self,	dmg,	temp_3;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	CALL4		T_Damage;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	hurt_on,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	TRUE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	DONE;
}

void() trigger_hurt = asm
{
local float temp_3;
	CALL0		InitTrigger;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	hurt_touch,	temp_3;
	INDIRECT_F	self,	dmg,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	dmg,	temp_3;
	STOREP_F	MOVETYPE_FLY,	temp_3;
	DONE;
}

void() trigger_push_touch = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	INDIRECT_S	other,	classname,	temp_3;
	EQ_S		temp_3,	"grenade",	temp_3;
	IFNOT		temp_3,	8;
	ADDRESS	other,	velocity_x,	temp_0_x;
	INDIRECT_F	self,	speed,	temp_3;
	INDIRECT_V	self,	movedir_x,	temp_1;
	MUL_FV	temp_3,	temp_1,	temp_1;
	MUL_VF	temp_1,	MOVETYPE_BOUNCE,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	GOTO		25;
	INDIRECT_F	other,	health,	temp_3;
	GT		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	22;
	ADDRESS	other,	velocity_x,	temp_0_x;
	INDIRECT_F	self,	speed,	temp_3;
	INDIRECT_V	self,	movedir_x,	temp_1;
	MUL_FV	temp_3,	temp_1,	temp_1;
	MUL_VF	temp_1,	MOVETYPE_BOUNCE,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	INDIRECT_S	other,	classname,	temp_3;
	EQ_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	13;
	INDIRECT_F	other,	fly_sound,	temp_3;
	LT		temp_3,	time,	temp_3;
	IFNOT		temp_3,	10;
	ADDRESS	other,	fly_sound,	temp_3;
	ADD_F		time,	SHVBAL_EFFRAM_PERCENTAGE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	STORE_F	other,	parm0_x;
	STORE_F	FALSE,	parm1_x;
	STORE_F	"ambience/windfly.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void() trigger_push = asm
{
local float temp_3;
	CALL0		InitTrigger;
	STORE_F	"ambience/windfly.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	trigger_push_touch,	temp_3;
	INDIRECT_F	self,	speed,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	speed,	temp_3;
	STOREP_F	DAT_PRJ_ABT_VELOCITY,	temp_3;
	DONE;
}

void() trigger_monsterjump_touch = asm
{
local float temp_3;
local float temp_5;
local float temp_6;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	STAT_TARG_EID,	temp_3;
	NE_F		temp_3,	FL_MONSTER,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	ADDRESS	other,	velocity_x,	temp_3;
	INDIRECT_F	self,	movedir_x,	temp_5;
	INDIRECT_F	self,	speed,	temp_6;
	MUL_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	other,	velocity_y,	temp_3;
	INDIRECT_F	self,	movedir_y,	temp_5;
	INDIRECT_F	self,	speed,	temp_6;
	MUL_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_ONGROUND,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	2;
	RETURN	offset_0;
	ADDRESS	other,	flags,	temp_3;
	INDIRECT_F	other,	flags,	temp_5;
	SUB_F		temp_5,	FL_ONGROUND,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	other,	velocity_z,	temp_3;
	INDIRECT_F	self,	height,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void() trigger_monsterjump = asm
{
local vector temp_0;
local float temp_3;
	INDIRECT_F	self,	speed,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	speed,	temp_3;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_3;
	INDIRECT_F	self,	height,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	height,	temp_3;
	STOREP_F	DAT_PRJ_QRFL_VELOCITY,	temp_3;
	INDIRECT_V	self,	angles_x,	temp_0;
	EQ_V		temp_0,	VEC_ORIGIN,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	angles_x,	temp_0_x;
	STOREP_V	'0.000000 360.000000 0.000000',	temp_0;
	CALL0		InitTrigger;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	trigger_monsterjump_touch,	temp_3;
	DONE;
}

void() map_initTrigger = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
	INDIRECT_V	self,	movedir_x,	temp_0;
	EQ_V		temp_0,	VEC_ORIGIN,	temp_3;
	IFNOT		temp_3,	5;
	INDIRECT_V	self,	angles_x,	temp_0;
	NE_V		temp_0,	VEC_ORIGIN,	temp_3;
	IFNOT		temp_3,	2;
	CALL0		SetMovedir;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_1,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	modelindex,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	model,	temp_3;
	STOREP_S	"",	temp_3;
	DONE;
}

void() map_trigger_changelevel = asm
{
local float temp_3;
	CALL0		map_initTrigger;
	INDIRECT_S	self,	map,	temp_3;
	NOT_S		temp_3,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	"changelevel trigger doesn't have map",	parm0_x;
	CALL1		objerror;
	INDIRECT_F	self,	isActive,	temp_3;
	IFNOT		temp_3,	4;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	changelevel_touch,	temp_3;
	GOTO		3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	changelevel_use,	temp_3;
	DONE;
}

void() map_trigger_highlighthud = asm
{
local float temp_3;
	CALL0		map_initTrigger;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/talk.wav",	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	wait,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	DAT_LATC_RL_RATE,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	multi_use,	temp_3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	highlight_hud_touch,	temp_3;
	INDIRECT_F	self,	nextthink,	temp_3;
	GT		temp_3,	time,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	DONE;
}

void() map_trigger_multiple = asm
{
local vector temp_0;
local float temp_3;
local float temp_5;
	CALL0		map_initTrigger;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	6;
	STORE_F	"misc/secret.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/secret.wav",	temp_3;
	GOTO		16;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	6;
	STORE_F	"misc/talk.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/talk.wav",	temp_3;
	GOTO		8;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	MOVETYPE_WALK,	temp_3;
	IFNOT		temp_3,	5;
	STORE_F	"misc/trigger1.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/trigger1.wav",	temp_3;
	INDIRECT_F	self,	wait,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	DAT_LATC_RL_RATE,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	multi_use,	temp_3;
	INDIRECT_F	self,	health,	temp_3;
	IFNOT		temp_3,	20;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	"health and notouch don't make sense
",	parm0_x;
	CALL1		objerror;
	ADDRESS	self,	max_health,	temp_3;
	INDIRECT_F	self,	health,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	th_die,	temp_3;
	STOREP_FNC	multi_killed,	temp_3;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	GOTO		7;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	multi_touch,	temp_3;
	DONE;
}

void() map_trigger_once = asm
{
local float temp_3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	CONTENT_EMPTY,	temp_3;
	CALL0		map_trigger_multiple;
	DONE;
}

void() map_trigger_relay = asm
{
local float temp_3;
	CALL0		map_initTrigger;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	SUB_UseTargets,	temp_3;
	DONE;
}

void() map_trigger_secret = asm
{
local float temp_3;
	ADD_F		total_secrets,	TRUE,	total_secrets;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	CONTENT_EMPTY,	temp_3;
	INDIRECT_S	self,	message,	temp_3;
	NOT_S		temp_3,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	message,	temp_3;
	STOREP_S	"You found a secret area!",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	sounds,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	6;
	STORE_F	"misc/secret.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/secret.wav",	temp_3;
	GOTO		8;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	5;
	STORE_F	"misc/talk.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/talk.wav",	temp_3;
	CALL0		map_trigger_multiple;
	DONE;
}

void() map_trigger_counter = asm
{
local float temp_3;
	CALL0		map_initTrigger;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	CONTENT_EMPTY,	temp_3;
	INDIRECT_F	self,	count,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	count,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	counter_use,	temp_3;
	DONE;
}

void() map_trigger_teleport = asm
{
local vector o;
local vector temp_0;
local vector temp_1;
local float temp_3;
	CALL0		map_initTrigger;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	teleport_touch,	temp_3;
	INDIRECT_S	self,	target,	temp_3;
	NOT_S		temp_3,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	"no target",	parm0_x;
	CALL1		objerror;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	teleport_use,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	12;
	STORE_F	"ambience/hum1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	ADD_V		temp_0,	temp_1,	temp_0;
	MUL_VF	temp_0,	0.500000,	o;
	STORE_V	o,	parm0;
	STORE_F	"ambience/hum1.wav",	parm1_x;
	STORE_F	0.500000,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void() map_trigger_setskill = asm
{
local float temp_3;
	CALL0		map_initTrigger;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	trigger_skill_touch,	temp_3;
	DONE;
}

void() map_trigger_hurt = asm
{
local float temp_3;
	CALL0		map_initTrigger;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	hurt_touch,	temp_3;
	INDIRECT_F	self,	dmg,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	dmg,	temp_3;
	STOREP_F	MOVETYPE_FLY,	temp_3;
	DONE;
}

void() map_trigger_push = asm
{
local float temp_3;
	CALL0		map_initTrigger;
	STORE_F	"ambience/windfly.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	trigger_push_touch,	temp_3;
	INDIRECT_F	self,	speed,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	speed,	temp_3;
	STOREP_F	DAT_PRJ_ABT_VELOCITY,	temp_3;
	DONE;
}

void () map_changefog_touch;
void() map_changefog_touch = asm
{
local float temp_3;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	4;
	STORE_ENT	other,	activator;
	INDIRECT_FU	self,	use,	temp_3;
	CALL0		temp_3;
	DONE;
}

void () map_changefog_use;
void() map_changefog_use = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
local float temp_6;
	INDIRECT_F	activator,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	23;
	INDIRECT_F	self,	fog_density,	temp_3;
	INDIRECT_V	self,	fog_color_x,	temp_0;
	INDIRECT_F	self,	fog_alpha,	temp_5;
	INDIRECT_V	self,	fog_dist_x,	temp_1;
	INDIRECT_F	self,	fade,	temp_6;
	STORE_F	other,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_V	temp_0,	parm2;
	STORE_F	temp_5,	parm3_x;
	STORE_V	temp_1,	parm4;
	STORE_F	temp_6,	parm5_x;
	CALL6		client_sendFog;
	ADDRESS	other,	fog_alpha,	temp_3;
	INDIRECT_F	self,	fog_alpha,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	5;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	STOREP_F	0.001000,	temp_3;
	DONE;
}

void () map_change_fog;
void() map_change_fog = asm
{
local vector tempMax;
local vector tempMin;
local vector temp_0;
local float temp_3;
	INDIRECT_V	self,	maxs_x,	tempMax;
	INDIRECT_V	self,	mins_x,	tempMin;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	map_changefog_use,	temp_3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	map_changefog_touch,	temp_3;
	ADDRESS	self,	stat_wep_state,	temp_3;
	STOREP_F	TRUE,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	STORE_V	tempMin,	parm1;
	STORE_V	tempMax,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	DONE;
}

void () map_changemusic_touch;
void() map_changemusic_touch = asm
{
local float temp_3;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	4;
	STORE_ENT	other,	activator;
	INDIRECT_FU	self,	use,	temp_3;
	CALL0		temp_3;
	DONE;
}

void () map_changemusic_use;
void() map_changemusic_use = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	activator,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	14;
	INDIRECT_F	self,	comp_id,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_5;
	STORE_F	activator,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	temp_5,	parm2_x;
	CALL3		client_sendMusic;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	5;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	STOREP_F	0.001000,	temp_3;
	DONE;
}

void () map_change_music;
void() map_change_music = asm
{
local vector tempMax;
local vector tempMin;
local vector temp_0;
local float temp_3;
	INDIRECT_V	self,	mins_x,	temp_0;
	NOT_V		temp_0,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	mins_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_0;
	NOT_V		temp_0,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	mins_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	tempMax;
	INDIRECT_V	self,	mins_x,	tempMin;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	map_changemusic_use,	temp_3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	map_changemusic_touch,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	STORE_V	tempMin,	parm1;
	STORE_V	tempMax,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	DONE;
}

void () map_change_wind_new;
void () map_change_wind_revert;
void() map_change_wind_revert = asm
{
local vector temp_0;
local float temp_3;
local float temp_5;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_INWATER,	temp_3;
	IFNOT		temp_3,	3;
	INDIRECT_V	self,	c_alt_ofs_x,	WINDDIR;
	INDIRECT_F	self,	m_fspeed,	WINDSPEED;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	6;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.001000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_change_wind_new,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	wait,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void() map_change_wind_new = asm
{
local vector temp_0;
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_INWATER,	temp_3;
	IFNOT		temp_3,	5;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	WINDDIR_x,	temp_0;
	ADDRESS	self,	m_fspeed,	temp_3;
	STOREP_F	WINDSPEED,	temp_3;
	INDIRECT_V	self,	c_ofs_x,	WINDDIR;
	INDIRECT_F	self,	p_velocity,	WINDSPEED;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_change_wind_revert,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	5;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	p_lifetime,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () map_change_wind_use;
void() map_change_wind_use = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	6;
	INDIRECT_F	self,	isActive,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	5;
	INDIRECT_F	self,	nextthink,	temp_3;
	LT		time,	temp_3,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	isActive,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	8;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_change_wind_new,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	POWERUP_DEBUG,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () map_change_wind;
void() map_change_wind = asm
{
local vector tempMax;
local vector tempMin;
local vector temp_0;
local float temp_3;
local float temp_5;
	STORE_V	VEC_ORIGIN,	tempMin;
	STORE_V	VEC_ORIGIN,	tempMax;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	STORE_V	tempMin,	parm1;
	STORE_V	tempMax,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	m_fspeed,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	c_alt_ofs_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	map_change_wind_use,	temp_3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	4;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	RETURN	offset_0;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_change_wind_new,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	POWERUP_DEBUG,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () map_damagezone_use;
void () map_damagezone_cool;
void () map_damagezone_think;
void() map_damagezone_think = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.001000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	8;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_damagezone_cool,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	wait,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Null,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void() map_damagezone_cool = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_damagezone_think,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	p_lifetime,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void() map_damagezone_use = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	5;
	INDIRECT_F	self,	nextthink,	temp_3;
	LT		time,	temp_3,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_F	self,	isActive,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	12;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_damagezone_think,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	p_lifetime,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () map_damagezone_touch;
void() map_damagezone_touch = asm
{
local vector rpoint;
local vector temp_0;
local float temp_3;
local float temp_5;
local float temp_6;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_MONSTER,	temp_3;
	IFNOT		temp_3,	10;
	INDIRECT_F	self,	isActive,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	7;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_damagezone_use,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	INDIRECT_F	self,	isActive,	temp_3;
	IFNOT		temp_3,	83;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_UNIT,	temp_3;
	IFNOT		temp_3,	80;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	18;
	ADDRESS	other,	sh_cur,	temp_3;
	INDIRECT_F	other,	sh_cur,	temp_5;
	INDIRECT_F	self,	p_damage,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	other,	sh_cur,	temp_3;
	LT		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	other,	sh_cur,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_F	other,	sh_cur,	temp_3;
	INDIRECT_F	other,	sh_max,	temp_5;
	GT		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	4;
	ADDRESS	other,	sh_cur,	temp_3;
	INDIRECT_F	other,	sh_max,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	26;
	CALL0		randomvec;
	STORE_V	return,	rpoint;
	CALL0		random;
	INDIRECT_F	self,	maxs_x,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	MUL_F		rpoint_x,	temp_3,	rpoint_x;
	CALL0		random;
	INDIRECT_F	self,	maxs_y,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	MUL_F		rpoint_y,	temp_3,	rpoint_y;
	CALL0		random;
	INDIRECT_F	self,	maxs_z,	temp_3;
	MUL_F		return_x,	temp_3,	temp_3;
	MUL_F		rpoint_z,	temp_3,	rpoint_z;
	INDIRECT_V	other,	origin_x,	temp_0;
	ADD_V		temp_0,	rpoint,	rpoint;
	INDIRECT_F	self,	p_damage,	temp_3;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	world,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	STORE_F	FALSE,	parm4_x;
	STORE_V	rpoint,	parm5;
	STORE_V	VEC_ORIGIN,	parm6;
	CALL7		t_damage;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	18;
	ADDRESS	other,	en_cur,	temp_3;
	INDIRECT_F	other,	en_cur,	temp_5;
	INDIRECT_F	self,	p_damage,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	other,	en_cur,	temp_3;
	LT		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	other,	en_cur,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_F	other,	en_cur,	temp_3;
	INDIRECT_F	other,	en_max,	temp_5;
	GT		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	4;
	ADDRESS	other,	en_cur,	temp_3;
	INDIRECT_F	other,	en_max,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	1;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_INWATER,	temp_3;
	IFNOT		temp_3,	6;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.001000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () map_damage_zone;
void() map_damage_zone = asm
{
local vector tempMax;
local vector tempMin;
local vector temp_0;
local float temp_3;
local float temp_5;
local float temp_6;
	INDIRECT_V	self,	mins_x,	temp_0;
	NOT_V		temp_0,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	mins_x,	temp_0_x;
	STOREP_V	VEC_HULL_MIN_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_0;
	NOT_V		temp_0,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	mins_x,	temp_0_x;
	STOREP_V	VEC_HULL_MAX_x,	temp_0;
	INDIRECT_V	self,	mins_x,	tempMin;
	INDIRECT_V	self,	maxs_x,	tempMax;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	map_damagezone_touch,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	STORE_V	tempMin,	parm1;
	STORE_V	tempMax,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	10;
	INDIRECT_F	self,	p_lifetime,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	7;
	ADDRESS	self,	spawnflags,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_5;
	INDIRECT_F	self,	spawnflags,	temp_6;
	BITAND	temp_6,	FL_SWIM,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	10;
	INDIRECT_F	self,	wait,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	7;
	ADDRESS	self,	spawnflags,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_5;
	INDIRECT_F	self,	spawnflags,	temp_6;
	BITAND	temp_6,	MOVETYPE_STEP,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	4;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	RETURN	offset_0;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_damagezone_think,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	p_lifetime,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () deploy_point_use;
void() deploy_point_use = asm
{
local float temp_3;
	INDIRECT_F	self,	isActive,	temp_3;
	IFNOT		temp_3,	4;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	RETURN	offset_0;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	DONE;
}

void () deploy_point_th;
void() deploy_point_th = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	deploy_point_th,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.500000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () map_deploy_point;
void() map_deploy_point = asm
{
local vector temp_0;
local float temp_3;
local float temp_5;
	ADDRESS	self,	data_type,	temp_3;
	STOREP_F	MOVETYPE_BOUNCEMISSILE,	temp_3;
	ADDRESS	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_5;
	BITOR		temp_5,	FL_NODE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	deploy_point_use,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	deploy_point_th,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	DONE;
}

void () nav_point_touch;
void() nav_point_touch = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	isActive,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	32;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	i_faction,	temp_3;
	INDIRECT_F	self,	i_faction,	temp_5;
	EQ_F		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	23;
	ADDRESS	self,	enemy,	temp_3;
	STOREP_ENT	other,	temp_3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	STORE_ENT	self,	stemp;
	STORE_ENT	other,	self;
	STORE_F	stemp,	parm0_x;
	CALL1		client_send_navpoint;
	STORE_ENT	stemp,	self;
	STORE_F	other,	parm0_x;
	STORE_F	trigOnTarget,	parm1_x;
	CALL2		trigger_event;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	CONTENT_EMPTY,	temp_3;
	DONE;
}

void () nav_point_use;
void() nav_point_use = asm
{
local float temp_3;
	INDIRECT_F	self,	isActive,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	7;
	STORE_F	activator,	parm0_x;
	STORE_F	trigOnSpawn,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	RETURN	offset_0;
	INDIRECT_F	self,	isActive,	temp_3;
	GT		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	STORE_F	other,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	RETURN	offset_0;
	DONE;
}

void () map_nav_point;
void() map_nav_point = asm
{
local vector temp_0;
local float temp_3;
local float temp_5;
	ADDRESS	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_5;
	BITOR		temp_5,	FL_NODE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	data_type,	temp_3;
	STOREP_F	FL_CLIENT,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	STORE_V	'-150.000000 -150.000000 -100.000000',	parm1;
	STORE_V	'150.000000 150.000000 100.000000',	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_FLY,	temp_3;
	CALL0		droptofloor;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	nav_point_use,	temp_3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	nav_point_touch,	temp_3;
	DONE;
}

void () map_objective_use;
void() map_objective_use = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	enemy,	temp_3;
	STOREP_ENT	activator,	temp_3;
	INDIRECT_F	self,	isActive,	temp_3;
	IFNOT		temp_3,	17;
	INDIRECT_F	self,	count,	temp_3;
	IFNOT		temp_3,	12;
	ADDRESS	self,	count1,	temp_3;
	INDIRECT_F	self,	count1,	temp_5;
	ADD_F		temp_5,	TRUE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	count1,	temp_3;
	INDIRECT_F	self,	count,	temp_5;
	GE		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	RETURN	offset_0;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	RETURN	offset_0;
	INDIRECT_F	self,	isActive,	temp_3;
	GT		temp_3,	CONTENT_EMPTY,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	DONE;
}

void () map_objective_th;
void() map_objective_th = asm
{
local entity player;
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	isActive,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	21;
	CALL0		multi_trigger;
	STORE_F	flags,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	CALL2		findchainflags;
	STORE_ENT	return_x,	player;
	IFNOT		player,	12;
	INDIRECT_F	player,	i_faction,	temp_3;
	INDIRECT_F	self,	i_faction,	temp_5;
	EQ_F		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	6;
	STORE_ENT	self,	stemp;
	STORE_ENT	player,	self;
	STORE_F	stemp,	parm0_x;
	CALL1		client_send_objective;
	STORE_ENT	stemp,	self;
	INDIRECT_E	player,	chain,	player;
	GOTO		-11;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	RETURN	offset_0;
	INDIRECT_F	self,	isActive,	temp_3;
	EQ_F		temp_3,	CONTENT_EMPTY,	temp_3;
	IFNOT		temp_3,	23;
	STORE_F	flags,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	CALL2		findchainflags;
	STORE_ENT	return_x,	player;
	IFNOT		player,	12;
	INDIRECT_F	player,	i_faction,	temp_3;
	INDIRECT_F	self,	i_faction,	temp_5;
	EQ_F		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	6;
	STORE_ENT	self,	stemp;
	STORE_ENT	player,	self;
	STORE_F	stemp,	parm0_x;
	CALL1		client_send_objective;
	STORE_ENT	stemp,	self;
	INDIRECT_E	player,	chain,	player;
	GOTO		-11;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_E	self,	enemy,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	RETURN	offset_0;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_objective_th,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () map_objective;
void() map_objective = asm
{
local vector tempMax;
local vector tempMin;
local vector temp_0;
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	6;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_V	self,	maxs_x,	tempMax;
	INDIRECT_V	self,	mins_x,	tempMin;
	GOTO		3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	flags,	temp_3;
	INDIRECT_F	self,	flags,	temp_5;
	BITOR		temp_5,	FL_NODE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	data_type,	temp_3;
	STOREP_F	MOVETYPE_FLYMISSILE,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	map_objective_use,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_objective_th,	temp_3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	4;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	RETURN	offset_0;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () map_terrain_model_tile;
void() map_terrain_model_tile = asm
{
	DONE;
}

void () map_terrain_model;
void() map_terrain_model = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	MOVETYPE_STEP,	temp_3;
	ADDRESS	self,	velocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	avelocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	alpha,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	4;
	ADDRESS	self,	alpha,	temp_3;
	INDIRECT_F	self,	count1,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_S	self,	model,	parm0_x;
	CALL1		precache_model;
	INDIRECT_S	self,	model,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		setmodel;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_1,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	DONE;
}

void () map_misc_model_static;
void() map_misc_model_static = asm
{
	DONE;
}

void () map_misc_model_solid_die;
void() map_misc_model_solid_die = asm
{
local float temp_3;
local float temp_5;
	STORE_F	activator,	parm0_x;
	STORE_F	trigOnDeath,	parm1_x;
	CALL2		trigger_event;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () map_misc_model_solid;
void() map_misc_model_solid = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	MOVETYPE_STEP,	temp_3;
	ADDRESS	self,	velocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	avelocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	alpha,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	4;
	ADDRESS	self,	alpha,	temp_3;
	INDIRECT_F	self,	count1,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_S	self,	model,	parm0_x;
	CALL1		precache_model;
	INDIRECT_S	self,	model,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		setmodel;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_1,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	DONE;
}

void () map_misc_model_break;
void() map_misc_model_break = asm
{
	DONE;
}

void () animatic_event_execute;
void() animatic_event_execute = asm
{
local entity this;
local entity client;
local vector temp_0;
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	isActive,	temp_3;
	IFNOT		temp_3,	59;
	STORE_ENT	self,	this;
	STORE_F	flags,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	CALL2		findchainflags;
	STORE_ENT	return_x,	client;
	IFNOT		client,	33;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	6;
	INDIRECT_F	self,	i_faction,	temp_3;
	INDIRECT_F	client,	i_faction,	temp_5;
	NE_F		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	2;
	GOTO		-8;
	STORE_ENT	client,	self;
	ADDRESS	self,	count1,	temp_3;
	INDIRECT_F	self,	stat_plr_stt,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	stat_plr_stt,	temp_3;
	STOREP_F	MOVETYPE_TOSS,	temp_3;
	ADDRESS	self,	count2,	temp_3;
	INDIRECT_F	this,	count1,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	count3,	temp_3;
	INDIRECT_F	self,	movetype,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	velocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	avelocity_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	INDIRECT_S	this,	msn_file,	parm0_x;
	CALL1		client_sendAnimaticFileName;
	STORE_ENT	this,	self;
	INDIRECT_E	client,	chain,	client;
	GOTO		-32;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	ARM_LT_MOD,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_GODMODE,	temp_3;
	IFNOT		temp_3,	9;
	ADDRESS	self,	think,	temp_3;
	INDIRECT_FU	self,	use,	temp_5;
	STOREP_FNC	temp_5,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	wait,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	DONE;
}

void () animatic_event_use;
void() animatic_event_use = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	isActive,	temp_3;
	IFNOT		temp_3,	3;
	CALL0		animatic_event_execute;
	GOTO		12;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	animatic_event_execute,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	POWERUP_DEBUG,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () animatic_event_touch;
void() animatic_event_touch = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	10;
	INDIRECT_F	self,	dmgtime,	temp_3;
	GT		time,	temp_3,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	dmgtime,	temp_3;
	ADD_F		time,	120.000000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	isActive,	temp_3;
	IFNOT		temp_3,	2;
	CALL0		animatic_event_execute;
	DONE;
}

void () animatic_event;
void() animatic_event = asm
{
local vector tempMax;
local vector tempMin;
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
local float temp_6;
	INDIRECT_V	self,	mins_x,	tempMin;
	INDIRECT_V	self,	maxs_x,	tempMax;
	ADDRESS	self,	dmgtime,	temp_3;
	STOREP_F	time,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	animatic_event_use,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	8;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_V	tempMin,	parm1;
	STORE_V	tempMax,	parm2;
	CALL3		setsize;
	GOTO		9;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_1,	parm2;
	CALL3		setsize;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_INWATER,	temp_3;
	IFNOT		temp_3,	18;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_FLY,	temp_3;
	INDIRECT_V	self,	angles_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_1;
	INDIRECT_F	self,	mins_z,	temp_3;
	ADD_F		temp_3,	MOVETYPE_STEP,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_1,	parm1;
	STORE_F	temp_3,	parm2_x;
	CALL3		util_dropToGround;
	STORE_F	self,	parm0_x;
	STORE_V	return,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	GOTO		5;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_MONSTER,	temp_3;
	IFNOT		temp_3,	6;
	INDIRECT_F	self,	count,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	count,	temp_3;
	STOREP_F	IMP_SWEAPON3,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_GODMODE,	temp_3;
	IFNOT		temp_3,	10;
	INDIRECT_F	self,	wait,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	7;
	ADDRESS	self,	spawnflags,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_5;
	INDIRECT_F	self,	spawnflags,	temp_6;
	BITAND	temp_6,	FL_GODMODE,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	animatic_event_touch,	temp_3;
	DONE;
}

void () debug_smoke;
void() debug_smoke = asm
{
local vector dir;
local vector temp_0;
local float temp_3;
	INDIRECT_V	self,	v_angle_x,	temp_0;
	ADD_V		WINDDIR,	temp_0,	temp_0;
	MUL_VF	temp_0,	WINDSPEED,	dir;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_F	self,	count,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_V	dir,	parm1;
	STORE_F	temp_3,	parm2_x;
	CALL3		te_smoke_test;
	DONE;
}

void () map_particle_use;
void() map_particle_use = asm
{
	DONE;
}

void () map_particle_debug_th;
void() map_particle_debug_th = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_FU	self,	unit_ini,	temp_3;
	CALL0		temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_particle_debug_th,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void (function) map_particle_ini;
void(void () partiFunc) map_particle_ini = asm
{
local vector temp_0;
local float temp_3;
local float temp_5;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	effects,	temp_3;
	INDIRECT_F	self,	effects,	temp_5;
	BITOR		temp_5,	FL_INWATER,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	map_particle_use,	temp_3;
	ADDRESS	self,	unit_ini,	temp_3;
	STOREP_FNC	partiFunc,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_particle_debug_th,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () debug_particles_smoke;
void() debug_particles_smoke = asm
{
	STORE_F	debug_smoke,	parm0_x;
	CALL1		map_particle_ini;
	DONE;
}

void () map_projectile_shooter_use;
void() map_projectile_shooter_use = asm
{
local float temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	5;
	INDIRECT_F	self,	nextthink,	temp_3;
	LT		time,	temp_3,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_FU	self,	w_attack,	temp_3;
	CALL0		temp_3;
	DONE;
}

void () map_projectile_shooter_think;
void() map_projectile_shooter_think = asm
{
local float temp_3;
local float temp_5;
	CALL0		map_projectile_shooter_use;
	ADDRESS	self,	en_cur,	temp_3;
	STOREP_F	100000.000000,	temp_3;
	ADDRESS	self,	w_state,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	rl_cur,	temp_3;
	INDIRECT_F	self,	rl_max,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	w_currentammo,	temp_3;
	INDIRECT_F	self,	w_clipsize,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_projectile_shooter_think,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	count3,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_MONSTER,	temp_3;
	IFNOT		temp_3,	28;
	ADDRESS	self,	count,	temp_3;
	INDIRECT_F	self,	count,	temp_5;
	SUB_F		temp_5,	TRUE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	count,	temp_3;
	LE		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	21;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	8;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	wait,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	GOTO		11;
	INDIRECT_E	self,	w_slot,	parm0_x;
	CALL1		remove;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	24;
	INDIRECT_F	self,	count2,	temp_3;
	GT		time,	temp_3,	temp_3;
	IFNOT		temp_3,	21;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	9;
	INDIRECT_E	self,	w_slot,	parm0_x;
	CALL1		remove;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	wait,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () map_projectile_shooter;
void() map_projectile_shooter = asm
{
local float locked_2932;
local vector temp_0;
local vector temp_1;
local float temp_5;
local float temp_6;
	ADDRESS	self,	owner,	locked_2932;
	STOREP_ENT	self,	locked_2932;
	INDIRECT_E	self,	owner,	locked_2932;
	ADDRESS	locked_2932,	enemy,	locked_2932;
	STOREP_ENT	self,	locked_2932;
	INDIRECT_E	self,	owner,	locked_2932;
	ADDRESS	locked_2932,	angles_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	INDIRECT_E	self,	owner,	locked_2932;
	ADDRESS	locked_2932,	v_angle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	self,	solid,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	ADDRESS	self,	movetype,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	INDIRECT_F	self,	data_idx,	parm0_x;
	CALL1		data_iniWep;
	ADDRESS	self,	rl_cur,	locked_2932;
	STOREP_F	STAT_PLR_ANG_X,	locked_2932;
	ADDRESS	self,	en_cur,	locked_2932;
	STOREP_F	DAT_BLD_H_SM_RADAR_RADAR_RANGE,	locked_2932;
	INDIRECT_E	self,	owner,	locked_2932;
	ADDRESS	locked_2932,	stat_rdr_mode,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	ADDRESS	self,	isActive,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	ADDRESS	self,	rl_max,	locked_2932;
	INDIRECT_F	self,	count3,	temp_5;
	STOREP_F	temp_5,	locked_2932;
	INDIRECT_E	self,	owner,	locked_2932;
	ADDRESS	locked_2932,	stat_lck_stt,	locked_2932;
	INDIRECT_E	self,	owner,	temp_5;
	INDIRECT_F	temp_5,	stat_lck_stt,	temp_5;
	BITOR		temp_5,	MOVETYPE_STEP,	temp_5;
	STOREP_F	temp_5,	locked_2932;
	INDIRECT_F	self,	flags,	locked_2932;
	BITAND	locked_2932,	FL_MONSTER,	locked_2932;
	IFNOT		locked_2932,	14;
	ADDRESS	self,	p_damage,	locked_2932;
	INDIRECT_F	self,	p_damage,	temp_5;
	STORE_F	skill,	parm0_x;
	STORE_F	temp_5,	parm1_x;
	CALL2		ai_pilot_mod_damage;
	STOREP_F	return_x,	locked_2932;
	INDIRECT_F	self,	w_clipsize,	locked_2932;
	GT		locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	5;
	ADDRESS	self,	w_firerate,	locked_2932;
	INDIRECT_F	self,	w_firerate,	temp_5;
	MUL_F		temp_5,	DAT_PRJ_EMP_VELOCITY,	temp_5;
	STOREP_F	temp_5,	locked_2932;
	INDIRECT_F	self,	p_dmgtype,	locked_2932;
	BITAND	locked_2932,	FL_NOTARGET,	locked_2932;
	IFNOT		locked_2932,	3;
	ADDRESS	self,	w_think,	locked_2932;
	STOREP_FNC	SUB_Null,	locked_2932;
	ADDRESS	self,	th_die,	locked_2932;
	STOREP_FNC	ctrl_die_weapon,	locked_2932;
	ADDRESS	self,	stat_wep_rel,	locked_2932;
	STOREP_F	TRUE,	locked_2932;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_1,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	FL_INWATER,	locked_2932;
	IFNOT		locked_2932,	24;
	CALL0		spawn;
	STORE_ENT	return_x,	newmis;
	INDIRECT_S	self,	c_model,	locked_2932;
	STORE_F	newmis,	parm0_x;
	STORE_F	locked_2932,	parm1_x;
	CALL2		setmodel;
	STORE_F	newmis,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	newmis,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	newmis,	angles_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	newmis,	angles_x,	locked_2932;
	INDIRECT_F	newmis,	angles_x,	temp_5;
	MUL_F		temp_5,	CONTENT_EMPTY,	temp_5;
	STOREP_F	temp_5,	locked_2932;
	ADDRESS	self,	w_slot,	locked_2932;
	STOREP_ENT	newmis,	locked_2932;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	FL_MONSTER,	locked_2932;
	IFNOT		locked_2932,	10;
	INDIRECT_F	self,	count,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	7;
	ADDRESS	self,	spawnflags,	locked_2932;
	INDIRECT_F	self,	spawnflags,	temp_5;
	INDIRECT_F	self,	spawnflags,	temp_6;
	BITAND	temp_6,	FL_MONSTER,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	locked_2932;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	MOVETYPE_STEP,	locked_2932;
	IFNOT		locked_2932,	10;
	INDIRECT_F	self,	wait,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	7;
	ADDRESS	self,	spawnflags,	locked_2932;
	INDIRECT_F	self,	spawnflags,	temp_5;
	INDIRECT_F	self,	spawnflags,	temp_6;
	BITAND	temp_6,	MOVETYPE_STEP,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	locked_2932;
	INDIRECT_F	self,	count3,	locked_2932;
	NE_F		locked_2932,	FALSE,	locked_2932;
	IF		locked_2932,	3;
	ADDRESS	self,	count3,	locked_2932;
	STOREP_F	ARM_LT_MOD,	locked_2932;
	INDIRECT_F	self,	spawnflags,	locked_2932;
	BITAND	locked_2932,	TRUE,	locked_2932;
	IFNOT		locked_2932,	4;
	ADDRESS	self,	isActive,	locked_2932;
	STOREP_F	FALSE,	locked_2932;
	RETURN	offset_0;
	ADDRESS	self,	think,	locked_2932;
	STOREP_FNC	map_projectile_shooter_think,	locked_2932;
	ADDRESS	self,	count2,	locked_2932;
	INDIRECT_F	self,	p_lifetime,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	locked_2932;
	ADDRESS	self,	nextthink,	locked_2932;
	INDIRECT_F	self,	count3,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	locked_2932;
	DONE;
}

void () map_noshoot_th;
void() map_noshoot_th = asm
{
local float temp_3;
local float temp_5;
local float temp_6;
	INDIRECT_F	self,	isActive,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	29;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_INWATER,	temp_3;
	IFNOT		temp_3,	16;
	INDIRECT_FU	self,	use,	temp_3;
	CALL0		temp_3;
	ADDRESS	self,	spawnflags,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_5;
	INDIRECT_F	self,	spawnflags,	temp_6;
	BITAND	temp_6,	MOVETYPE_STEP,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Null,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	STOREP_F	time,	temp_3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	RETURN	offset_0;
	ADDRESS	self,	think,	temp_3;
	INDIRECT_FU	self,	use,	temp_5;
	STOREP_FNC	temp_5,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	GOTO		1;
	DONE;
}

void () map_noshoot_shutoff;
void() map_noshoot_shutoff = asm
{
	DONE;
}

void () map_noshoot_use;
void() map_noshoot_use = asm
{
local float findFlags;
local entity e;
local float temp_3;
local float temp_5;
local float temp_6;
local float temp_8;
	INDIRECT_F	self,	isActive,	temp_3;
	IFNOT		temp_3,	51;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	STORE_F	FL_MONSTER,	findFlags;
	INDIRECT_F	self,	p_dmgtype,	temp_3;
	IFNOT		temp_3,	2;
	BITOR		findFlags,	FL_CLIENT,	findFlags;
	STORE_F	flags,	parm0_x;
	STORE_F	findFlags,	parm1_x;
	CALL2		findchainflags;
	STORE_ENT	return_x,	e;
	IFNOT		e,	20;
	INDIRECT_F	e,	flags,	temp_3;
	INDIRECT_F	self,	comp_id,	temp_5;
	BITAND	temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	9;
	ADDRESS	e,	flags,	temp_3;
	INDIRECT_F	e,	flags,	temp_5;
	INDIRECT_F	e,	flags,	temp_6;
	INDIRECT_F	self,	comp_id,	temp_8;
	BITAND	temp_6,	temp_8,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	GOTO		6;
	ADDRESS	e,	flags,	temp_3;
	INDIRECT_F	e,	flags,	temp_5;
	INDIRECT_F	self,	comp_id,	temp_6;
	BITOR		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_E	e,	chain,	e;
	GOTO		-19;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	POWERUP_DEBUG,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	8;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_noshoot_th,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	wait,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	GOTO		7;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	map_noshoot_th,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	DONE;
}

void () map_noshoot_touch;
void() map_noshoot_touch = asm
{
local float temp_3;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	3;
	INDIRECT_FU	self,	use,	temp_3;
	CALL0		temp_3;
	DONE;
}

void () map_no_shoot;
void() map_no_shoot = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	map_noshoot_touch,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	map_noshoot_use,	temp_3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_1,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	6;
	INDIRECT_F	self,	wait,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	MOVETYPE_BOUNCE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	4;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	RETURN	offset_0;
	DONE;
}

void () map_fail_objective_use;
void() map_fail_objective_use = asm
{
local entity obj;
local float temp_3;
	INDIRECT_S	self,	target,	temp_3;
	STORE_F	world,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	obj;
	IFNOT		obj,	4;
	ADDRESS	obj,	isActive,	temp_3;
	STOREP_F	CONTENT_EMPTY,	temp_3;
	GOTO		8;
	INDIRECT_S	self,	target,	temp_3;
	STORE_F	"Objective ",	parm0_x;
	STORE_F	temp_3,	parm1_x;
	STORE_F	" not found!
",	parm2_x;
	CALL3		strcat;
	STORE_F	return_x,	parm0_x;
	CALL1		dprint;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void () map_fail_objective;
void() map_fail_objective = asm
{
local vector tempMax;
local vector tempMin;
local vector temp_0;
local float temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	10;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_V	self,	mins_x,	tempMin;
	INDIRECT_V	self,	maxs_x,	tempMax;
	STORE_F	self,	parm0_x;
	STORE_V	tempMin,	parm1;
	STORE_V	tempMax,	parm2;
	CALL3		setsize;
	GOTO		7;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	DONE;
}

void() highlight_hud_touch = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	31;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	6;
	INDIRECT_F	other,	i_faction,	temp_3;
	INDIRECT_F	self,	i_faction,	temp_5;
	NE_F		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	STORE_F	other,	parm0_x;
	CALL1		client_push_hud_highlight;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	6;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	POWERUP_DEBUG,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_GODMODE,	temp_3;
	IFNOT		temp_3,	8;
	ADDRESS	self,	think,	temp_3;
	INDIRECT_FU	self,	use,	temp_5;
	STOREP_FNC	temp_5,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	wait,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () map_hud_highlight_use;
void() map_hud_highlight_use = asm
{
local entity this;
local entity client;
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	isActive,	temp_3;
	IFNOT		temp_3,	42;
	STORE_ENT	self,	this;
	STORE_F	flags,	parm0_x;
	STORE_F	FL_CLIENT,	parm1_x;
	CALL2		findchainflags;
	STORE_ENT	return_x,	client;
	IFNOT		client,	13;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	6;
	INDIRECT_F	self,	i_faction,	temp_3;
	INDIRECT_F	client,	i_faction,	temp_5;
	NE_F		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	2;
	GOTO		-8;
	STORE_F	client,	parm0_x;
	CALL1		client_push_hud_highlight;
	INDIRECT_E	client,	chain,	client;
	GOTO		-12;
	IFNOT		client,	22;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	6;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	POWERUP_DEBUG,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_GODMODE,	temp_3;
	IFNOT		temp_3,	9;
	ADDRESS	self,	think,	temp_3;
	INDIRECT_FU	self,	use,	temp_5;
	STOREP_FNC	temp_5,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	wait,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	RETURN	offset_0;
	RETURN	offset_0;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	DONE;
}

void () map_hud_highlight;
void() map_hud_highlight = asm
{
local vector tempMin;
local vector tempMax;
local vector temp_0;
local vector temp_1;
local float temp_3;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/talk.wav",	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	"q3mdl/testball.md3",	parm1_x;
	CALL2		setmodel;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	10;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_V	tempMin,	parm1;
	STORE_V	tempMax,	parm2;
	CALL3		setsize;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	highlight_hud_touch,	temp_3;
	GOTO		9;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_1,	parm2;
	CALL3		setsize;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_INWATER,	temp_3;
	IFNOT		temp_3,	18;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_FLY,	temp_3;
	INDIRECT_V	self,	angles_x,	temp_0;
	INDIRECT_V	self,	origin_x,	temp_1;
	INDIRECT_F	self,	mins_z,	temp_3;
	ADD_F		temp_3,	MOVETYPE_STEP,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_1,	parm1;
	STORE_F	temp_3,	parm2_x;
	CALL3		util_dropToGround;
	STORE_F	self,	parm0_x;
	STORE_V	return,	parm1;
	CALL2		setorigin;
	CALL0		droptofloor;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	GOTO		5;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	INDIRECT_F	self,	wait,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	DAT_LATC_RL_RATE,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	map_hud_highlight_use,	temp_3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_F	self,	nextthink,	temp_3;
	GT		temp_3,	time,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	DONE;
}

void () mission_boundary_touch;
void() mission_boundary_touch = asm
{
local float temp_3;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	5;
	INDIRECT_F	self,	isActive,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	other,	parm0_x;
	CALL1		client_send_boundary_warning;
	INDIRECT_F	other,	flags,	temp_3;
	BITAND	temp_3,	FL_MONSTER,	temp_3;
	IFNOT		temp_3,	1;
	DONE;
}

void () mission_boundary_th;
void() mission_boundary_th = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	isActive,	temp_3;
	INDIRECT_F	self,	isActive,	temp_5;
	NOT_F		temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	mission_boundary_th,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () func_mission_boundary;
void() func_mission_boundary = asm
{
local float temp_3;
local float temp_5;
	CALL0		InitTrigger;
	ADDRESS	self,	isActive,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	touch,	temp_3;
	STOREP_FNC	mission_boundary_touch,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	mission_boundary_th,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	CALL0		random;
	MUL_F		return_x,	0.500000,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () plat_center_touch;
void () plat_outside_touch;
void () plat_trigger_use;
void () plat_go_up;
void () plat_go_down;
void () plat_crush;
float PLAT_LOW_TRIGGER;
void () plat_spawn_inside_trigger;
void() plat_spawn_inside_trigger = asm
{
local vector tmax;
local vector tmin;
local entity trigger;
local vector temp_0;
local float temp_3;
local float temp_5;
	CALL0		spawn;
	STORE_ENT	return_x,	trigger;
	ADDRESS	trigger,	touch,	temp_3;
	STOREP_FNC	plat_center_touch,	temp_3;
	ADDRESS	trigger,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	trigger,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	trigger,	enemy,	temp_3;
	STOREP_ENT	self,	temp_3;
	INDIRECT_V	self,	mins_x,	temp_0;
	ADD_V		temp_0,	'25.000000 25.000000 0.000000',	tmin;
	INDIRECT_V	self,	maxs_x,	temp_0;
	SUB_V		temp_0,	'25.000000 25.000000 -8.000000',	tmax;
	INDIRECT_F	self,	pos1_z,	temp_3;
	INDIRECT_F	self,	pos2_z,	temp_5;
	SUB_F		temp_3,	temp_5,	temp_3;
	ADD_F		temp_3,	FL_CLIENT,	temp_3;
	SUB_F		tmax_z,	temp_3,	tmin_z;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	2;
	ADD_F		tmin_z,	FL_CLIENT,	tmax_z;
	INDIRECT_F	self,	size_x,	temp_3;
	LE		temp_3,	TE_BLOOD,	temp_3;
	IFNOT		temp_3,	6;
	INDIRECT_F	self,	mins_x,	temp_3;
	INDIRECT_F	self,	maxs_x,	temp_5;
	ADD_F		temp_3,	temp_5,	temp_3;
	DIV_F		temp_3,	FL_SWIM,	tmin_x;
	ADD_F		tmin_x,	TRUE,	tmax_x;
	INDIRECT_F	self,	size_y,	temp_3;
	LE		temp_3,	TE_BLOOD,	temp_3;
	IFNOT		temp_3,	6;
	INDIRECT_F	self,	mins_y,	temp_3;
	INDIRECT_F	self,	maxs_y,	temp_5;
	ADD_F		temp_3,	temp_5,	temp_3;
	DIV_F		temp_3,	FL_SWIM,	tmin_y;
	ADD_F		tmin_y,	TRUE,	tmax_y;
	STORE_F	trigger,	parm0_x;
	STORE_V	tmin,	parm1;
	STORE_V	tmax,	parm2;
	CALL3		setsize;
	DONE;
}

void () plat_hit_top;
void() plat_hit_top = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_S	self,	noise1,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	plat_go_down,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	ADD_F		temp_5,	MOVETYPE_WALK,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () plat_hit_bottom;
void() plat_hit_bottom = asm
{
local float temp_3;
	INDIRECT_S	self,	noise1,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	TRUE,	temp_3;
	DONE;
}

void() plat_go_down = asm
{
local vector temp_0;
local float temp_3;
	INDIRECT_S	self,	noise,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	MOVETYPE_WALK,	temp_3;
	INDIRECT_V	self,	pos2_x,	temp_0;
	INDIRECT_F	self,	speed,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_3,	parm1_x;
	STORE_F	plat_hit_bottom,	parm2_x;
	CALL3		SUB_CalcMove;
	DONE;
}

void() plat_go_up = asm
{
local vector temp_0;
local float temp_3;
	INDIRECT_S	self,	noise,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	INDIRECT_V	self,	pos1_x,	temp_0;
	INDIRECT_F	self,	speed,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_3,	parm1_x;
	STORE_F	plat_hit_top,	parm2_x;
	CALL3		SUB_CalcMove;
	DONE;
}

void() plat_center_touch = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_S	other,	classname,	temp_3;
	NE_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	health,	temp_3;
	LE		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_E	self,	enemy,	self;
	INDIRECT_F	self,	state,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	3;
	CALL0		plat_go_up;
	GOTO		8;
	INDIRECT_F	self,	state,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	5;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	ADD_F		temp_5,	TRUE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void() plat_outside_touch = asm
{
local float temp_3;
	INDIRECT_S	other,	classname,	temp_3;
	NE_S		temp_3,	"player",	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_F	other,	health,	temp_3;
	LE		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	INDIRECT_E	self,	enemy,	self;
	INDIRECT_F	self,	state,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	2;
	CALL0		plat_go_down;
	DONE;
}

void() plat_trigger_use = asm
{
local float temp_3;
	INDIRECT_FU	self,	think,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	CALL0		plat_go_down;
	DONE;
}

void() plat_crush = asm
{
local float temp_3;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	CALL4		T_Damage;
	INDIRECT_F	self,	state,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	3;
	CALL0		plat_go_down;
	GOTO		8;
	INDIRECT_F	self,	state,	temp_3;
	EQ_F		temp_3,	MOVETYPE_WALK,	temp_3;
	IFNOT		temp_3,	3;
	CALL0		plat_go_up;
	GOTO		3;
	STORE_F	"plat_crush: bad self.state
",	parm0_x;
	CALL1		objerror;
	DONE;
}

void () plat_use;
void() plat_use = asm
{
local float temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	SUB_Null,	temp_3;
	INDIRECT_F	self,	state,	temp_3;
	NE_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	"plat_use: not in up state",	parm0_x;
	CALL1		objerror;
	CALL0		plat_go_down;
	DONE;
}

void () func_plat;
void() func_plat = asm
{
local entity t;
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
local float temp_6;
	INDIRECT_F	self,	t_length,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	t_length,	temp_3;
	STOREP_F	STAT_WEP_REL,	temp_3;
	INDIRECT_F	self,	t_width,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	t_width,	temp_3;
	STOREP_F	MOVETYPE_BOUNCE,	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	sounds,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	9;
	STORE_F	"plats/plat1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"plats/plat2.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"plats/plat1.wav",	temp_3;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"plats/plat2.wav",	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	9;
	STORE_F	"plats/medplat1.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"plats/medplat2.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"plats/medplat1.wav",	temp_3;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"plats/medplat2.wav",	temp_3;
	ADDRESS	self,	mangle_x,	temp_0_x;
	INDIRECT_V	self,	angles_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	classname,	temp_3;
	STOREP_S	"plat",	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	MOVETYPE_STEP,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_PUSH,	temp_3;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	INDIRECT_S	self,	model,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		setmodel;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_1,	parm2;
	CALL3		setsize;
	ADDRESS	self,	blocked,	temp_3;
	STOREP_FNC	plat_crush,	temp_3;
	INDIRECT_F	self,	speed,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	speed,	temp_3;
	STOREP_F	DAT_PRJ_SFGA_RAD,	temp_3;
	ADDRESS	self,	pos1_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	self,	pos2_x,	temp_0_x;
	INDIRECT_V	self,	origin_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	INDIRECT_F	self,	height,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	pos2_z,	temp_3;
	INDIRECT_F	self,	origin_z,	temp_5;
	INDIRECT_F	self,	height,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	GOTO		7;
	ADDRESS	self,	pos2_z,	temp_3;
	INDIRECT_F	self,	origin_z,	temp_5;
	INDIRECT_F	self,	size_z,	temp_6;
	SUB_F		temp_5,	temp_6,	temp_5;
	ADD_F		temp_5,	FL_CLIENT,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	plat_trigger_use,	temp_3;
	CALL0		plat_spawn_inside_trigger;
	INDIRECT_S	self,	targetname,	temp_3;
	IFNOT		temp_3,	6;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	plat_use,	temp_3;
	GOTO		7;
	INDIRECT_V	self,	pos2_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	state,	temp_3;
	STOREP_F	TRUE,	temp_3;
	DONE;
}

void () train_next;
void () func_train_find;
void () train_blocked;
void() train_blocked = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	attack_finished,	temp_3;
	LT		time,	temp_3,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	ADDRESS	self,	attack_finished,	temp_3;
	ADD_F		time,	0.500000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	dmg,	temp_3;
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	temp_3,	parm3_x;
	CALL4		T_Damage;
	DONE;
}

void () train_use;
void() train_use = asm
{
local float temp_3;
	INDIRECT_FU	self,	think,	temp_3;
	NE_FNC	temp_3,	func_train_find,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	CALL0		train_next;
	DONE;
}

void () train_wait;
void() train_wait = asm
{
local float temp_3;
local float temp_5;
local float temp_6;
	INDIRECT_F	self,	wait,	temp_3;
	IFNOT		temp_3,	14;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	INDIRECT_F	self,	wait,	temp_6;
	ADD_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_S	self,	noise,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	GOTO		5;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	ADD_F		temp_5,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	train_next,	temp_3;
	DONE;
}

void() train_next = asm
{
local entity targ;
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	INDIRECT_S	self,	target,	temp_3;
	STORE_F	world,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	targ;
	ADDRESS	self,	target,	temp_3;
	INDIRECT_S	targ,	target,	temp_5;
	STOREP_S	temp_5,	temp_3;
	INDIRECT_S	self,	target,	temp_3;
	NOT_S		temp_3,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	"train_next: no next target",	parm0_x;
	CALL1		objerror;
	INDIRECT_F	targ,	wait,	temp_3;
	IFNOT		temp_3,	5;
	ADDRESS	self,	wait,	temp_3;
	INDIRECT_F	targ,	wait,	temp_5;
	STOREP_F	temp_5,	temp_3;
	GOTO		3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_S	self,	noise1,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_V	targ,	origin_x,	temp_0;
	INDIRECT_V	self,	mins_x,	temp_1;
	SUB_V		temp_0,	temp_1,	temp_0;
	INDIRECT_F	self,	speed,	temp_3;
	STORE_V	temp_0,	parm0;
	STORE_F	temp_3,	parm1_x;
	STORE_F	train_wait,	parm2_x;
	CALL3		SUB_CalcMove;
	DONE;
}

void() func_train_find = asm
{
local entity targ;
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	INDIRECT_S	self,	target,	temp_3;
	STORE_F	world,	parm0_x;
	STORE_F	targetname,	parm1_x;
	STORE_F	temp_3,	parm2_x;
	CALL3		find;
	STORE_ENT	return_x,	targ;
	ADDRESS	self,	target,	temp_3;
	INDIRECT_S	targ,	target,	temp_5;
	STOREP_S	temp_5,	temp_3;
	INDIRECT_V	targ,	origin_x,	temp_0;
	INDIRECT_V	self,	mins_x,	temp_1;
	SUB_V		temp_0,	temp_1,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	INDIRECT_S	self,	targetname,	temp_3;
	NOT_S		temp_3,	temp_3;
	IFNOT		temp_3,	7;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	ADD_F		temp_5,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	train_next,	temp_3;
	DONE;
}

void () func_train;
void() func_train = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	speed,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	speed,	temp_3;
	STOREP_F	STAT_PLR_ANG_X,	temp_3;
	INDIRECT_S	self,	target,	temp_3;
	NOT_S		temp_3,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	"func_train without a target",	parm0_x;
	CALL1		objerror;
	INDIRECT_F	self,	dmg,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	dmg,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	9;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/null.wav",	temp_3;
	STORE_F	"misc/null.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"misc/null.wav",	temp_3;
	STORE_F	"misc/null.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_F	self,	sounds,	temp_3;
	EQ_F		temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	9;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"plats/train2.wav",	temp_3;
	STORE_F	"plats/train2.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"plats/train1.wav",	temp_3;
	STORE_F	"plats/train1.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	cnt,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	MOVETYPE_STEP,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_PUSH,	temp_3;
	ADDRESS	self,	blocked,	temp_3;
	STOREP_FNC	train_blocked,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	train_use,	temp_3;
	ADDRESS	self,	classname,	temp_3;
	STOREP_S	"train",	temp_3;
	INDIRECT_S	self,	model,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		setmodel;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_1,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	ADD_F		temp_5,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	func_train_find,	temp_3;
	DONE;
}

void () misc_teleporttrain;
void() misc_teleporttrain = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	speed,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	speed,	temp_3;
	STOREP_F	STAT_PLR_ANG_X,	temp_3;
	INDIRECT_S	self,	target,	temp_3;
	NOT_S		temp_3,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	"func_train without a target",	parm0_x;
	CALL1		objerror;
	ADDRESS	self,	cnt,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_PUSH,	temp_3;
	ADDRESS	self,	blocked,	temp_3;
	STOREP_FNC	train_blocked,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	train_use,	temp_3;
	ADDRESS	self,	avelocity_x,	temp_0_x;
	STOREP_V	'100.000000 200.000000 300.000000',	temp_0;
	ADDRESS	self,	noise,	temp_3;
	STOREP_S	"misc/null.wav",	temp_3;
	STORE_F	"misc/null.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	noise1,	temp_3;
	STOREP_S	"misc/null.wav",	temp_3;
	STORE_F	"misc/null.wav",	parm0_x;
	CALL1		precache_sound;
	STORE_F	"progs/teleport.mdl",	parm0_x;
	CALL1		precache_model2;
	STORE_F	self,	parm0_x;
	STORE_F	"progs/teleport.mdl",	parm1_x;
	CALL2		setmodel;
	INDIRECT_V	self,	mins_x,	temp_0;
	INDIRECT_V	self,	maxs_x,	temp_1;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	STORE_V	temp_1,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	self,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	ltime,	temp_5;
	ADD_F		temp_5,	0.100000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	func_train_find,	temp_3;
	DONE;
}

void () info_null;
void() info_null = asm
{
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void () info_notnull;
void() info_notnull = asm
{
	DONE;
}

float START_OFF;
void () light_use;
void() light_use = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	9;
	INDIRECT_F	self,	style,	parm0_x;
	STORE_F	"m",	parm1_x;
	CALL2		lightstyle;
	ADDRESS	self,	spawnflags,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_5;
	SUB_F		temp_5,	TRUE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	GOTO		8;
	INDIRECT_F	self,	style,	parm0_x;
	STORE_F	"a",	parm1_x;
	CALL2		lightstyle;
	ADDRESS	self,	spawnflags,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_5;
	ADD_F		temp_5,	TRUE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () light;
void() light = asm
{
local float temp_3;
	INDIRECT_S	self,	targetname,	temp_3;
	NOT_S		temp_3,	temp_3;
	IFNOT		temp_3,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	INDIRECT_F	self,	style,	temp_3;
	GE		temp_3,	FL_MONSTER,	temp_3;
	IFNOT		temp_3,	13;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	light_use,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	5;
	INDIRECT_F	self,	style,	parm0_x;
	STORE_F	"a",	parm1_x;
	CALL2		lightstyle;
	GOTO		4;
	INDIRECT_F	self,	style,	parm0_x;
	STORE_F	"m",	parm1_x;
	CALL2		lightstyle;
	DONE;
}

void () light_fluoro;
void() light_fluoro = asm
{
local vector temp_0;
local float temp_3;
	INDIRECT_F	self,	style,	temp_3;
	GE		temp_3,	FL_MONSTER,	temp_3;
	IFNOT		temp_3,	13;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	light_use,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	5;
	INDIRECT_F	self,	style,	parm0_x;
	STORE_F	"a",	parm1_x;
	CALL2		lightstyle;
	GOTO		4;
	INDIRECT_F	self,	style,	parm0_x;
	STORE_F	"m",	parm1_x;
	CALL2		lightstyle;
	STORE_F	"ambience/fl_hum1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/fl_hum1.wav",	parm1_x;
	STORE_F	0.500000,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () light_fluorospark;
void() light_fluorospark = asm
{
local vector temp_0;
local float temp_3;
	INDIRECT_F	self,	style,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	style,	temp_3;
	STOREP_F	MOVETYPE_BOUNCE,	temp_3;
	STORE_F	"ambience/buzz1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/buzz1.wav",	parm1_x;
	STORE_F	0.500000,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () light_globe;
void() light_globe = asm
{
	STORE_F	"progs/s_light.spr",	parm0_x;
	CALL1		precache_model;
	STORE_F	self,	parm0_x;
	STORE_F	"progs/s_light.spr",	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	CALL1		makestatic;
	DONE;
}

void () FireAmbient;
void() FireAmbient = asm
{
local vector temp_0;
	STORE_F	"ambience/fire1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/fire1.wav",	parm1_x;
	STORE_F	0.500000,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () light_torch_small_walltorch;
void() light_torch_small_walltorch = asm
{
	STORE_F	"progs/flame.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	self,	parm0_x;
	STORE_F	"progs/flame.mdl",	parm1_x;
	CALL2		setmodel;
	CALL0		FireAmbient;
	STORE_F	self,	parm0_x;
	CALL1		makestatic;
	DONE;
}

void () light_flame_large_yellow;
void() light_flame_large_yellow = asm
{
local float temp_3;
	STORE_F	"progs/flame2.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	self,	parm0_x;
	STORE_F	"progs/flame2.mdl",	parm1_x;
	CALL2		setmodel;
	ADDRESS	self,	frame,	temp_3;
	STOREP_F	TRUE,	temp_3;
	CALL0		FireAmbient;
	STORE_F	self,	parm0_x;
	CALL1		makestatic;
	DONE;
}

void () light_flame_small_yellow;
void() light_flame_small_yellow = asm
{
	STORE_F	"progs/flame2.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	self,	parm0_x;
	STORE_F	"progs/flame2.mdl",	parm1_x;
	CALL2		setmodel;
	CALL0		FireAmbient;
	STORE_F	self,	parm0_x;
	CALL1		makestatic;
	DONE;
}

void () light_flame_small_white;
void() light_flame_small_white = asm
{
	STORE_F	"progs/flame2.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	self,	parm0_x;
	STORE_F	"progs/flame2.mdl",	parm1_x;
	CALL2		setmodel;
	CALL0		FireAmbient;
	STORE_F	self,	parm0_x;
	CALL1		makestatic;
	DONE;
}

void () fire_fly;
void () fire_touch;
void () misc_fireball;
void() misc_fireball = asm
{
local float temp_3;
local float temp_5;
	STORE_F	"progs/lavaball.mdl",	parm0_x;
	CALL1		precache_model;
	ADDRESS	self,	classname,	temp_3;
	STOREP_S	"fireball",	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	CALL0		random;
	MUL_F		return_x,	MOVETYPE_FLY,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	fire_fly,	temp_3;
	INDIRECT_F	self,	speed,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	3;
	ADDRESS	self,	speed,	temp_3;
	STOREP_F	DAT_PRJ_ABT_VELOCITY,	temp_3;
	DONE;
}

void() fire_fly = asm
{
local entity fireball;
local vector temp_0;
local float temp_3;
local float temp_5;
local float temp_6;
	CALL0		spawn;
	STORE_ENT	return_x,	fireball;
	ADDRESS	fireball,	solid,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	fireball,	movetype,	temp_3;
	STOREP_F	MOVETYPE_TOSS,	temp_3;
	ADDRESS	fireball,	velocity_x,	temp_0_x;
	STOREP_V	'0.000000 0.000000 1000.000000',	temp_0;
	ADDRESS	fireball,	velocity_x,	temp_3;
	CALL0		random;
	MUL_F		return_x,	STAT_PLR_ANG_X,	temp_5;
	SUB_F		temp_5,	TE_BLOOD,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	fireball,	velocity_y,	temp_3;
	CALL0		random;
	MUL_F		return_x,	STAT_PLR_ANG_X,	temp_5;
	SUB_F		temp_5,	TE_BLOOD,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	fireball,	velocity_z,	temp_3;
	INDIRECT_F	self,	speed,	temp_5;
	CALL0		random;
	MUL_F		return_x,	DAT_PRJ_QRFL_VELOCITY,	temp_6;
	ADD_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	fireball,	classname,	temp_3;
	STOREP_S	"fireball",	temp_3;
	STORE_F	fireball,	parm0_x;
	STORE_F	"progs/lavaball.mdl",	parm1_x;
	CALL2		setmodel;
	STORE_F	fireball,	parm0_x;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_V	VEC_ORIGIN,	parm2;
	CALL3		setsize;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	fireball,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	fireball,	nextthink,	temp_3;
	ADD_F		time,	MOVETYPE_FLY,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	fireball,	think,	temp_3;
	STOREP_FNC	SUB_Remove,	temp_3;
	ADDRESS	fireball,	touch,	temp_3;
	STOREP_FNC	fire_touch,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	CALL0		random;
	MUL_F		return_x,	MOVETYPE_FLY,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	ADD_F		temp_5,	MOVETYPE_WALK,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	fire_fly,	temp_3;
	DONE;
}

void() fire_touch = asm
{
	STORE_F	other,	parm0_x;
	STORE_F	self,	parm1_x;
	STORE_F	self,	parm2_x;
	STORE_F	20.000000,	parm3_x;
	CALL4		T_Damage;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void () barrel_explode;
void() barrel_explode = asm
{
local vector temp_0;
local float temp_3;
local float temp_5;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	classname,	temp_3;
	STOREP_S	"explo_box",	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	"weapons/r_exp3.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_V	VEC_ORIGIN,	parm1;
	STORE_F	TE_PLASMABURN,	parm2_x;
	STORE_F	DAT_PRJ_EMP_GLOWCOLOR,	parm3_x;
	CALL4		particle;
	ADDRESS	self,	origin_z,	temp_3;
	INDIRECT_F	self,	origin_z,	temp_5;
	ADD_F		temp_5,	FL_MONSTER,	temp_5;
	STOREP_F	temp_5,	temp_3;
	CALL0		BecomeExplosion;
	DONE;
}

void () misc_explobox;
void() misc_explobox = asm
{
local float oldz;
local vector temp_0;
local float temp_3;
local float temp_5;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	STORE_F	"maps/b_explob.bsp",	parm0_x;
	CALL1		precache_model;
	STORE_F	self,	parm0_x;
	STORE_F	"maps/b_explob.bsp",	parm1_x;
	CALL2		setmodel;
	STORE_F	"weapons/r_exp3.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	health,	temp_3;
	STOREP_F	20.000000,	temp_3;
	ADDRESS	self,	th_die,	temp_3;
	STOREP_FNC	barrel_explode,	temp_3;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	ADDRESS	self,	origin_z,	temp_3;
	INDIRECT_F	self,	origin_z,	temp_5;
	ADD_F		temp_5,	FL_SWIM,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	origin_z,	oldz;
	CALL0		droptofloor;
	INDIRECT_F	self,	origin_z,	temp_3;
	SUB_F		oldz,	temp_3,	temp_3;
	GT		temp_3,	DAT_PAC_DMG,	temp_3;
	IFNOT		temp_3,	11;
	STORE_F	"item fell out of level at ",	parm0_x;
	CALL1		dprint;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		vtos;
	STORE_F	return_x,	parm0_x;
	CALL1		dprint;
	STORE_F	"
",	parm0_x;
	CALL1		dprint;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void () misc_explobox2;
void() misc_explobox2 = asm
{
local float oldz;
local vector temp_0;
local float temp_3;
local float temp_5;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	STORE_F	"maps/b_exbox2.bsp",	parm0_x;
	CALL1		precache_model2;
	STORE_F	self,	parm0_x;
	STORE_F	"maps/b_exbox2.bsp",	parm1_x;
	CALL2		setmodel;
	STORE_F	"weapons/r_exp3.wav",	parm0_x;
	CALL1		precache_sound;
	ADDRESS	self,	health,	temp_3;
	STOREP_F	20.000000,	temp_3;
	ADDRESS	self,	th_die,	temp_3;
	STOREP_FNC	barrel_explode,	temp_3;
	ADDRESS	self,	takedamage,	temp_3;
	STOREP_F	FL_SWIM,	temp_3;
	ADDRESS	self,	origin_z,	temp_3;
	INDIRECT_F	self,	origin_z,	temp_5;
	ADD_F		temp_5,	FL_SWIM,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	origin_z,	oldz;
	CALL0		droptofloor;
	INDIRECT_F	self,	origin_z,	temp_3;
	SUB_F		oldz,	temp_3,	temp_3;
	GT		temp_3,	DAT_PAC_DMG,	temp_3;
	IFNOT		temp_3,	11;
	STORE_F	"item fell out of level at ",	parm0_x;
	CALL1		dprint;
	INDIRECT_V	self,	origin_x,	parm0;
	CALL1		vtos;
	STORE_F	return_x,	parm0_x;
	CALL1		dprint;
	STORE_F	"
",	parm0_x;
	CALL1		dprint;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

float SPAWNFLAG_SUPERSPIKE;
float SPAWNFLAG_LASER;
void (vector, vector) LaunchLaser;
void () spikeshooter_use;
void() spikeshooter_use = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	13;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	"enforcer/enfire.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	self,	movedir_x,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_1,	parm1;
	CALL2		LaunchLaser;
	GOTO		21;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	"weapons/spike2.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	INDIRECT_V	self,	origin_x,	temp_0;
	INDIRECT_V	self,	movedir_x,	temp_1;
	STORE_V	temp_0,	parm0;
	STORE_V	temp_1,	parm1;
	CALL2		launch_spike;
	ADDRESS	newmis,	velocity_x,	temp_0_x;
	INDIRECT_V	self,	movedir_x,	temp_1;
	MUL_VF	temp_1,	DAT_OTL_CTOR_HP,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	TRUE,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	newmis,	touch,	temp_3;
	STOREP_FNC	superspike_touch,	temp_3;
	DONE;
}

void () shooter_think;
void() shooter_think = asm
{
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	CALL0		spikeshooter_use;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	wait,	temp_5;
	ADD_F		time,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	newmis,	velocity_x,	temp_0_x;
	INDIRECT_V	self,	movedir_x,	temp_1;
	MUL_VF	temp_1,	DAT_OTL_CTOR_HP,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	DONE;
}

void () trap_spikeshooter;
void() trap_spikeshooter = asm
{
local float temp_3;
	CALL0		SetMovedir;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	spikeshooter_use,	temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	temp_3,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	8;
	STORE_F	"progs/laser.mdl",	parm0_x;
	CALL1		precache_model2;
	STORE_F	"enforcer/enfire.wav",	parm0_x;
	CALL1		precache_sound2;
	STORE_F	"enforcer/enfstop.wav",	parm0_x;
	CALL1		precache_sound2;
	GOTO		3;
	STORE_F	"weapons/spike2.wav",	parm0_x;
	CALL1		precache_sound;
	DONE;
}

void () trap_shooter;
void() trap_shooter = asm
{
local float temp_3;
local float temp_5;
local float temp_6;
	CALL0		trap_spikeshooter;
	INDIRECT_F	self,	wait,	temp_3;
	EQ_F		temp_3,	FALSE,	temp_3;
	IFNOT		temp_3,	3;
	ADDRESS	self,	wait,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	INDIRECT_F	self,	nextthink,	temp_5;
	INDIRECT_F	self,	wait,	temp_6;
	ADD_F		temp_5,	temp_6,	temp_5;
	INDIRECT_F	self,	ltime,	temp_6;
	ADD_F		temp_5,	temp_6,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	shooter_think,	temp_3;
	DONE;
}

void () make_bubbles;
void () bubble_remove;
void () bubble_bob;
void () air_bubbles;
void() air_bubbles = asm
{
local float temp_3;
local float temp_5;
	IFNOT		deathmatch,	4;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	RETURN	offset_0;
	STORE_F	"progs/s_bubble.spr",	parm0_x;
	CALL1		precache_model;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	TRUE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	make_bubbles,	temp_3;
	DONE;
}

void() make_bubbles = asm
{
local entity bubble;
local vector temp_0;
local float temp_3;
local float temp_5;
	CALL0		spawn;
	STORE_ENT	return_x,	bubble;
	STORE_F	bubble,	parm0_x;
	STORE_F	"progs/s_bubble.spr",	parm1_x;
	CALL2		setmodel;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	bubble,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	bubble,	movetype,	temp_3;
	STOREP_F	FL_CLIENT,	temp_3;
	ADDRESS	bubble,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	bubble,	velocity_x,	temp_0_x;
	STOREP_V	'0.000000 0.000000 15.000000',	temp_0;
	ADDRESS	bubble,	nextthink,	temp_3;
	ADD_F		time,	0.500000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	bubble,	think,	temp_3;
	STOREP_FNC	bubble_bob,	temp_3;
	ADDRESS	bubble,	touch,	temp_3;
	STOREP_FNC	bubble_remove,	temp_3;
	ADDRESS	bubble,	classname,	temp_3;
	STOREP_S	"bubble",	temp_3;
	ADDRESS	bubble,	frame,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	bubble,	cnt,	temp_3;
	STOREP_F	FALSE,	temp_3;
	STORE_F	bubble,	parm0_x;
	STORE_V	'-8.000000 -8.000000 -8.000000',	parm1;
	STORE_V	'8.000000 8.000000 8.000000',	parm2;
	CALL3		setsize;
	ADDRESS	self,	nextthink,	temp_3;
	CALL0		random;
	ADD_F		time,	return_x,	temp_5;
	ADD_F		temp_5,	0.500000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	make_bubbles,	temp_3;
	DONE;
}

void () bubble_split;
void() bubble_split = asm
{
local entity bubble;
local vector temp_0;
local vector temp_1;
local float temp_3;
local float temp_5;
	CALL0		spawn;
	STORE_ENT	return_x,	bubble;
	STORE_F	bubble,	parm0_x;
	STORE_F	"progs/s_bubble.spr",	parm1_x;
	CALL2		setmodel;
	INDIRECT_V	self,	origin_x,	temp_0;
	STORE_F	bubble,	parm0_x;
	STORE_V	temp_0,	parm1;
	CALL2		setorigin;
	ADDRESS	bubble,	movetype,	temp_3;
	STOREP_F	FL_CLIENT,	temp_3;
	ADDRESS	bubble,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	bubble,	velocity_x,	temp_0_x;
	INDIRECT_V	self,	velocity_x,	temp_1;
	STOREP_V	temp_1_x,	temp_0;
	ADDRESS	bubble,	nextthink,	temp_3;
	ADD_F		time,	0.500000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	bubble,	think,	temp_3;
	STOREP_FNC	bubble_bob,	temp_3;
	ADDRESS	bubble,	touch,	temp_3;
	STOREP_FNC	bubble_remove,	temp_3;
	ADDRESS	bubble,	classname,	temp_3;
	STOREP_S	"bubble",	temp_3;
	ADDRESS	bubble,	frame,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	bubble,	cnt,	temp_3;
	STOREP_F	MOVETYPE_BOUNCE,	temp_3;
	STORE_F	bubble,	parm0_x;
	STORE_V	'-8.000000 -8.000000 -8.000000',	parm1;
	STORE_V	'8.000000 8.000000 8.000000',	parm2;
	CALL3		setsize;
	ADDRESS	self,	frame,	temp_3;
	STOREP_F	TRUE,	temp_3;
	ADDRESS	self,	cnt,	temp_3;
	STOREP_F	MOVETYPE_BOUNCE,	temp_3;
	INDIRECT_F	self,	waterlevel,	temp_3;
	NE_F		temp_3,	MOVETYPE_WALK,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void() bubble_remove = asm
{
local float temp_3;
local float temp_5;
	INDIRECT_S	other,	classname,	temp_3;
	INDIRECT_S	self,	classname,	temp_5;
	EQ_S		temp_3,	temp_5,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	DONE;
}

void() bubble_bob = asm
{
local vector modi;
local vector vtmp1;
local float rnd3;
local float rnd2;
local float rnd1;
local float temp_3;
local float temp_5;
	ADDRESS	self,	cnt,	temp_3;
	INDIRECT_F	self,	cnt,	temp_5;
	ADD_F		temp_5,	TRUE,	temp_5;
	STOREP_F	temp_5,	temp_3;
	INDIRECT_F	self,	cnt,	temp_3;
	EQ_F		temp_3,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	2;
	CALL0		bubble_split;
	INDIRECT_F	self,	cnt,	temp_3;
	EQ_F		temp_3,	20.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	self,	parm0_x;
	CALL1		remove;
	INDIRECT_F	self,	velocity_x,	temp_3;
	CALL0		random;
	MUL_F		return_x,	20.000000,	temp_5;
	ADD_F		-10.000000,	temp_5,	temp_5;
	ADD_F		temp_3,	temp_5,	rnd1;
	INDIRECT_F	self,	velocity_y,	temp_3;
	CALL0		random;
	MUL_F		return_x,	20.000000,	temp_5;
	ADD_F		-10.000000,	temp_5,	temp_5;
	ADD_F		temp_3,	temp_5,	rnd2;
	INDIRECT_F	self,	velocity_z,	temp_3;
	ADD_F		temp_3,	MOVETYPE_BOUNCE,	temp_3;
	CALL0		random;
	MUL_F		return_x,	MOVETYPE_BOUNCE,	temp_5;
	ADD_F		temp_3,	temp_5,	rnd3;
	GT		rnd1,	MOVETYPE_BOUNCE,	temp_3;
	IFNOT		temp_3,	2;
	STORE_F	MOVETYPE_FLY,	rnd1;
	LT		rnd1,	-10.000000,	temp_3;
	IFNOT		temp_3,	2;
	STORE_F	CONTENT_LAVA,	rnd1;
	GT		rnd2,	MOVETYPE_BOUNCE,	temp_3;
	IFNOT		temp_3,	2;
	STORE_F	MOVETYPE_FLY,	rnd2;
	LT		rnd2,	-10.000000,	temp_3;
	IFNOT		temp_3,	2;
	STORE_F	CONTENT_LAVA,	rnd2;
	LT		rnd3,	MOVETYPE_BOUNCE,	temp_3;
	IFNOT		temp_3,	2;
	STORE_F	IMP_SWEAPON3,	rnd3;
	GT		rnd3,	SVC_INTERMISSION,	temp_3;
	IFNOT		temp_3,	2;
	STORE_F	IMP_SHOWOBJ,	rnd3;
	ADDRESS	self,	velocity_x,	temp_3;
	STOREP_F	rnd1,	temp_3;
	ADDRESS	self,	velocity_y,	temp_3;
	STOREP_F	rnd2,	temp_3;
	ADDRESS	self,	velocity_z,	temp_3;
	STOREP_F	rnd3,	temp_3;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.500000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	bubble_bob,	temp_3;
	DONE;
}

void () viewthing;
void() viewthing = asm
{
local float temp_3;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	STORE_F	"progs/player.mdl",	parm0_x;
	CALL1		precache_model;
	STORE_F	self,	parm0_x;
	STORE_F	"progs/player.mdl",	parm1_x;
	CALL2		setmodel;
	DONE;
}

void () func_wall_use;
void() func_wall_use = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	frame,	temp_3;
	INDIRECT_F	self,	frame,	temp_5;
	SUB_F		TRUE,	temp_5,	temp_5;
	STOREP_F	temp_5,	temp_3;
	DONE;
}

void () func_wall;
void() func_wall = asm
{
local vector temp_0;
local float temp_3;
	ADDRESS	self,	angles_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_PUSH,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	MOVETYPE_STEP,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	func_wall_use,	temp_3;
	INDIRECT_S	self,	model,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		setmodel;
	DONE;
}

void () func_illusionary;
void() func_illusionary = asm
{
local vector temp_0;
local float temp_3;
	ADDRESS	self,	angles_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	FALSE,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	FALSE,	temp_3;
	INDIRECT_S	self,	model,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		setmodel;
	STORE_F	self,	parm0_x;
	CALL1		makestatic;
	DONE;
}

void () func_episodegate;
void() func_episodegate = asm
{
local vector temp_0;
local float temp_3;
	INDIRECT_F	self,	spawnflags,	temp_3;
	BITAND	serverflags,	temp_3,	temp_3;
	NE_F		temp_3,	FALSE,	temp_3;
	IF		temp_3,	2;
	RETURN	offset_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_PUSH,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	MOVETYPE_STEP,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	func_wall_use,	temp_3;
	INDIRECT_S	self,	model,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		setmodel;
	DONE;
}

void () func_bossgate;
void() func_bossgate = asm
{
local vector temp_0;
local float temp_3;
	BITAND	serverflags,	IMP_SWEAPON3,	temp_3;
	EQ_F		temp_3,	IMP_SWEAPON3,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	offset_0;
	ADDRESS	self,	angles_x,	temp_0_x;
	STOREP_V	VEC_ORIGIN_x,	temp_0;
	ADDRESS	self,	movetype,	temp_3;
	STOREP_F	MOVETYPE_PUSH,	temp_3;
	ADDRESS	self,	solid,	temp_3;
	STOREP_F	MOVETYPE_STEP,	temp_3;
	ADDRESS	self,	use,	temp_3;
	STOREP_FNC	func_wall_use,	temp_3;
	INDIRECT_S	self,	model,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	temp_3,	parm1_x;
	CALL2		setmodel;
	DONE;
}

void () ambient_suck_wind;
void() ambient_suck_wind = asm
{
local vector temp_0;
	STORE_F	"ambience/suck1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/suck1.wav",	parm1_x;
	STORE_F	TRUE,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () ambient_drone;
void() ambient_drone = asm
{
local vector temp_0;
	STORE_F	"ambience/drone6.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/drone6.wav",	parm1_x;
	STORE_F	0.500000,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () ambient_flouro_buzz;
void() ambient_flouro_buzz = asm
{
local vector temp_0;
	STORE_F	"ambience/buzz1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/buzz1.wav",	parm1_x;
	STORE_F	TRUE,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () ambient_drip;
void() ambient_drip = asm
{
local vector temp_0;
	STORE_F	"ambience/drip1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/drip1.wav",	parm1_x;
	STORE_F	0.500000,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () ambient_comp_hum;
void() ambient_comp_hum = asm
{
local vector temp_0;
	STORE_F	"ambience/comp1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/comp1.wav",	parm1_x;
	STORE_F	TRUE,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () ambient_thunder;
void() ambient_thunder = asm
{
local vector temp_0;
	STORE_F	"ambience/thunder1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/thunder1.wav",	parm1_x;
	STORE_F	0.500000,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () ambient_light_buzz;
void() ambient_light_buzz = asm
{
local vector temp_0;
	STORE_F	"ambience/fl_hum1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/fl_hum1.wav",	parm1_x;
	STORE_F	0.500000,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () ambient_swamp1;
void() ambient_swamp1 = asm
{
local vector temp_0;
	STORE_F	"ambience/swamp1.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/swamp1.wav",	parm1_x;
	STORE_F	0.500000,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () ambient_swamp2;
void() ambient_swamp2 = asm
{
local vector temp_0;
	STORE_F	"ambience/swamp2.wav",	parm0_x;
	CALL1		precache_sound;
	INDIRECT_V	self,	origin_x,	parm0;
	STORE_F	"ambience/swamp2.wav",	parm1_x;
	STORE_F	0.500000,	parm2_x;
	STORE_F	MOVETYPE_WALK,	parm3_x;
	CALL4		ambientsound;
	DONE;
}

void () noise_think;
void() noise_think = asm
{
local float temp_3;
local float temp_5;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.500000,	temp_5;
	STOREP_F	temp_5,	temp_3;
	STORE_F	self,	parm0_x;
	STORE_F	TRUE,	parm1_x;
	STORE_F	"enforcer/enfire.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	STORE_F	self,	parm0_x;
	STORE_F	FL_SWIM,	parm1_x;
	STORE_F	"enforcer/enfstop.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_WALK,	parm1_x;
	STORE_F	"enforcer/sight1.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_STEP,	parm1_x;
	STORE_F	"enforcer/sight2.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_FLY,	parm1_x;
	STORE_F	"enforcer/sight3.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_TOSS,	parm1_x;
	STORE_F	"enforcer/sight4.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	STORE_F	self,	parm0_x;
	STORE_F	MOVETYPE_PUSH,	parm1_x;
	STORE_F	"enforcer/pain1.wav",	parm2_x;
	STORE_F	TRUE,	parm3_x;
	STORE_F	TRUE,	parm4_x;
	CALL5		sound;
	DONE;
}

void () misc_noisemaker;
void() misc_noisemaker = asm
{
local float temp_3;
local float temp_5;
	STORE_F	"enforcer/enfire.wav",	parm0_x;
	CALL1		precache_sound2;
	STORE_F	"enforcer/enfstop.wav",	parm0_x;
	CALL1		precache_sound2;
	STORE_F	"enforcer/sight1.wav",	parm0_x;
	CALL1		precache_sound2;
	STORE_F	"enforcer/sight2.wav",	parm0_x;
	CALL1		precache_sound2;
	STORE_F	"enforcer/sight3.wav",	parm0_x;
	CALL1		precache_sound2;
	STORE_F	"enforcer/sight4.wav",	parm0_x;
	CALL1		precache_sound2;
	STORE_F	"enforcer/pain1.wav",	parm0_x;
	CALL1		precache_sound2;
	STORE_F	"enforcer/pain2.wav",	parm0_x;
	CALL1		precache_sound2;
	STORE_F	"enforcer/death1.wav",	parm0_x;
	CALL1		precache_sound2;
	STORE_F	"enforcer/idle1.wav",	parm0_x;
	CALL1		precache_sound2;
	ADDRESS	self,	nextthink,	temp_3;
	ADD_F		time,	0.100000,	temp_5;
	CALL0		random;
	ADD_F		temp_5,	return_x,	temp_5;
	STOREP_F	temp_5,	temp_3;
	ADDRESS	self,	think,	temp_3;
	STOREP_FNC	noise_think,	temp_3;
	DONE;
}

float __ext__fasttrackarrays;
void() ArraySet*AI_NODES = asm
{
local entity value___;
local float indexs___;
local float temp_3;
	IFNOT		__ext__fasttrackarrays,	6;
	C_FTOI	offset_6048,	offset_6048;
	BOUNDCHECK	offset_6048,	mins_z,	offset_0;
	GET_POINTER	AI_NODES,	offset_6048,	offset_6048;
	STOREP_F	offset_6049,	offset_6048;
	RETURN	offset_6049;
	BITAND	offset_6048,	offset_6048,	offset_6048;
	LT		offset_6048,	FL_GODMODE,	temp_3;
	IFNOT		temp_3,	287;
	LT		offset_6048,	FL_MONSTER,	temp_3;
	IFNOT		temp_3,	143;
	LT		offset_6048,	FL_INWATER,	temp_3;
	IFNOT		temp_3,	71;
	LT		offset_6048,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	35;
	LT		offset_6048,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	FALSE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES;
	RETURN	offset_0;
	EQ_F		offset_6048,	TRUE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[1];
	RETURN	offset_0;
	EQ_F		offset_6048,	FL_SWIM,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[2];
	RETURN	offset_0;
	EQ_F		offset_6048,	MOVETYPE_WALK,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[3];
	RETURN	offset_0;
	EQ_F		offset_6048,	MOVETYPE_STEP,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[4];
	RETURN	offset_0;
	EQ_F		offset_6048,	MOVETYPE_FLY,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[5];
	RETURN	offset_0;
	EQ_F		offset_6048,	MOVETYPE_TOSS,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[6];
	RETURN	offset_0;
	EQ_F		offset_6048,	MOVETYPE_PUSH,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[7];
	RETURN	offset_0;
	LT		offset_6048,	MOVETYPE_FOLLOW,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	FL_CLIENT,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[8];
	RETURN	offset_0;
	EQ_F		offset_6048,	MOVETYPE_FLYMISSILE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[9];
	RETURN	offset_0;
	EQ_F		offset_6048,	MOVETYPE_BOUNCE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[10];
	RETURN	offset_0;
	EQ_F		offset_6048,	MOVETYPE_BOUNCEMISSILE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[11];
	RETURN	offset_0;
	EQ_F		offset_6048,	MOVETYPE_FOLLOW,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[12];
	RETURN	offset_0;
	EQ_F		offset_6048,	IMP_SWEAPON1,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[13];
	RETURN	offset_0;
	EQ_F		offset_6048,	DPCONTENTS_LIQUIDSMASK,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[14];
	RETURN	offset_0;
	EQ_F		offset_6048,	IMP_SWEAPON3,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[15];
	RETURN	offset_0;
	LT		offset_6048,	ARM_RAD,	temp_3;
	IFNOT		temp_3,	35;
	LT		offset_6048,	20.000000,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	FL_INWATER,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[16];
	RETURN	offset_0;
	EQ_F		offset_6048,	IMP_SWEAPON5,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[17];
	RETURN	offset_0;
	EQ_F		offset_6048,	IMP_SWEAPON6,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[18];
	RETURN	offset_0;
	EQ_F		offset_6048,	IMP_SWEAPON7,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[19];
	RETURN	offset_0;
	EQ_F		offset_6048,	20.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[20];
	RETURN	offset_0;
	EQ_F		offset_6048,	IMP_SWEAPON9,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[21];
	RETURN	offset_0;
	EQ_F		offset_6048,	IMP_FSINGLE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[22];
	RETURN	offset_0;
	EQ_F		offset_6048,	SVC_TEMPENTITY,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[23];
	RETURN	offset_0;
	LT		offset_6048,	SVC_FOUNDSECRET,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	ARM_RAD,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[24];
	RETURN	offset_0;
	EQ_F		offset_6048,	IMP_SHOWOBJ,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[25];
	RETURN	offset_0;
	EQ_F		offset_6048,	IMP_REPAIR,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[26];
	RETURN	offset_0;
	EQ_F		offset_6048,	SVC_KILLEDMONSTER,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[27];
	RETURN	offset_0;
	EQ_F		offset_6048,	SVC_FOUNDSECRET,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[28];
	RETURN	offset_0;
	EQ_F		offset_6048,	29.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[29];
	RETURN	offset_0;
	EQ_F		offset_6048,	SVC_INTERMISSION,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[30];
	RETURN	offset_0;
	EQ_F		offset_6048,	SVC_FINALE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[31];
	RETURN	offset_0;
	LT		offset_6048,	STAT_PLR_HITDIR,	temp_3;
	IFNOT		temp_3,	71;
	LT		offset_6048,	STAT_PLR_ORG_X,	temp_3;
	IFNOT		temp_3,	35;
	LT		offset_6048,	STAT_VID,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	FL_MONSTER,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[32];
	RETURN	offset_0;
	EQ_F		offset_6048,	SVC_SELLSCREEN,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[33];
	RETURN	offset_0;
	EQ_F		offset_6048,	SOLID_PHYSICS_CAPSULE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[34];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_TARG_EID,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[35];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_VID,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[36];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_CAM_ORG_X,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[37];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_CAM_ORG_Y,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[38];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_CAM_ORG_Z,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[39];
	RETURN	offset_0;
	LT		offset_6048,	STAT_PLR_DTYPE,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	STAT_PLR_ORG_X,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[40];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_ORG_Y,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[41];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_ORG_Z,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[42];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_STT,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[43];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_DTYPE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[44];
	RETURN	offset_0;
	EQ_F		offset_6048,	DAT_PRJ_FLAK_PROXYRAD,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[45];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_DIDX,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[46];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_RADMOD,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[47];
	RETURN	offset_0;
	LT		offset_6048,	TE_PARTICLESNOW,	temp_3;
	IFNOT		temp_3,	35;
	LT		offset_6048,	TE_BLOODSHOWER,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	STAT_PLR_HITDIR,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[48];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_RETDIST,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[49];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_BLOOD,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[50];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_SPARK,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[51];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_BLOODSHOWER,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[52];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_EXPLOSIONRGB,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[53];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_PARTICLECUBE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[54];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_PARTICLERAIN,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[55];
	RETURN	offset_0;
	LT		offset_6048,	60.000000,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	TE_PARTICLESNOW,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[56];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_TRG_FACTION,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[57];
	RETURN	offset_0;
	EQ_F		offset_6048,	58.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[58];
	RETURN	offset_0;
	EQ_F		offset_6048,	59.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[59];
	RETURN	offset_0;
	EQ_F		offset_6048,	60.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[60];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_TRG_LG_HP,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[61];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_TRG_CT_HP,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[62];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_TRG_LT_HP,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[63];
	RETURN	offset_0;
	LT		offset_6048,	TE_MISSION_WIN,	temp_3;
	IFNOT		temp_3,	143;
	LT		offset_6048,	STAT_WEP_REL,	temp_3;
	IFNOT		temp_3,	71;
	LT		offset_6048,	TE_SMALLFLASH,	temp_3;
	IFNOT		temp_3,	35;
	LT		offset_6048,	TRG_P_CLASS,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	FL_GODMODE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[64];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_TRG_LA_HP,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[65];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_TRG_RA_HP,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[66];
	RETURN	offset_0;
	EQ_F		offset_6048,	TRG_VEC_SIZ,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[67];
	RETURN	offset_0;
	EQ_F		offset_6048,	TRG_P_CLASS,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[68];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_WEP1_ID,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[69];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_WEP2_ID,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[70];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_WEP3_ID,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[71];
	RETURN	offset_0;
	LT		offset_6048,	STAT_WEP8_ID,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	TE_SMALLFLASH,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[72];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_CUSTOMFLASH,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[73];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_FLAMEJET,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[74];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_PLASMABURN,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[75];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_WEP8_ID,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[76];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_WEP9_ID,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[77];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_WEP_STT,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[78];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_WEP_GRP,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[79];
	RETURN	offset_0;
	LT		offset_6048,	STAT_TRG_ORGX,	temp_3;
	IFNOT		temp_3,	35;
	LT		offset_6048,	STAT_LCK_STT,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	STAT_WEP_REL,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[80];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_NAV_DIR,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[81];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_CLIENT_HIT,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[82];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_FIR,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[83];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_LCK_STT,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[84];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_PTC,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[85];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_ANG,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[86];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_TRG_DDFLG,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[87];
	RETURN	offset_0;
	LT		offset_6048,	TE_EVT_NAV,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	STAT_TRG_ORGX,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[88];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_TRG_ORGY,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[89];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_TRG_ORGZ,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[90];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_RAD_SWEEP,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[91];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_EVT_NAV,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[92];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_EVT_DEP,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[93];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_OBJECTIVE_COMPLETE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[94];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_OBJECTIVE_FAILED,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[95];
	RETURN	offset_0;
	LT		offset_6048,	112.000000,	temp_3;
	IFNOT		temp_3,	71;
	LT		offset_6048,	STAT_PLR_NAME,	temp_3;
	IFNOT		temp_3,	35;
	LT		offset_6048,	STAT_PLR_ANG_X,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	TE_MISSION_WIN,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[96];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_MISSION_LOSE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[97];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_NAV_REACH,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[98];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_MSN_BOUND,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[99];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_ANG_X,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[100];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_ANG_Y,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[101];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_ANG_Z,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[102];
	RETURN	offset_0;
	EQ_F		offset_6048,	STAT_PLR_REP,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[103];
	RETURN	offset_0;
	LT		offset_6048,	TE_RPC_TRAIL,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	STAT_PLR_NAME,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[104];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_MIS_EXPL,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[105];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_LAS_HIT,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[106];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_RPC_MUZZLE,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[107];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_RPC_TRAIL,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[108];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_RPC_HIT,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[109];
	RETURN	offset_0;
	EQ_F		offset_6048,	TE_RPC_BURN,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[110];
	RETURN	offset_0;
	EQ_F		offset_6048,	111.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[111];
	RETURN	offset_0;
	LT		offset_6048,	120.000000,	temp_3;
	IFNOT		temp_3,	35;
	LT		offset_6048,	116.000000,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	112.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[112];
	RETURN	offset_0;
	EQ_F		offset_6048,	113.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[113];
	RETURN	offset_0;
	EQ_F		offset_6048,	114.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[114];
	RETURN	offset_0;
	EQ_F		offset_6048,	115.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[115];
	RETURN	offset_0;
	EQ_F		offset_6048,	116.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[116];
	RETURN	offset_0;
	EQ_F		offset_6048,	117.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[117];
	RETURN	offset_0;
	EQ_F		offset_6048,	118.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[118];
	RETURN	offset_0;
	EQ_F		offset_6048,	119.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[119];
	RETURN	offset_0;
	LT		offset_6048,	124.000000,	temp_3;
	IFNOT		temp_3,	17;
	EQ_F		offset_6048,	120.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[120];
	RETURN	offset_0;
	EQ_F		offset_6048,	121.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[121];
	RETURN	offset_0;
	EQ_F		offset_6048,	122.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[122];
	RETURN	offset_0;
	EQ_F		offset_6048,	123.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[123];
	RETURN	offset_0;
	EQ_F		offset_6048,	124.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[124];
	RETURN	offset_0;
	EQ_F		offset_6048,	DAT_MLGD_HPX,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[125];
	RETURN	offset_0;
	EQ_F		offset_6048,	126.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[126];
	RETURN	offset_0;
	EQ_F		offset_6048,	127.000000,	temp_3;
	IFNOT		temp_3,	3;
	STORE_F	offset_6049,	AI_NODES[127];
	RETURN	offset_0;
	DONE;
}

void () ArrayGetVec*AI_NODES;
void() ArrayGet*AI_NODES = asm
{
local vector vec__;
local float intdiv3___;
local float div3___;
local float indexg___;
local float div3___;
local float index___;
local entity value___;
local float indexs___;
local float temp_3;
	IFNOT		__ext__fasttrackarrays,	3;
	FETCH_GBL_F	AI_NODES,	offset_6109,	return_x;
	RETURN	return_x;
	GE		offset_6109,	FL_NOTARGET,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	FALSE;
	BITAND	offset_6109,	offset_6109,	offset_6109;
	DIV_F		offset_6109,	MOVETYPE_WALK,	offset_6110;
	BITAND	offset_6110,	offset_6110,	offset_6111;
	STORE_F	offset_6109,	parm0_x;
	CALL1		ArrayGetVec*AI_NODES;
	STORE_V	return,	vec__;
	MUL_F		offset_6111,	MOVETYPE_WALK,	temp_3;
	SUB_F		offset_6109,	temp_3,	offset_6109;
	LT		offset_6109,	0.500000,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	vec___x;
	LT		offset_6109,	SHVBAL_EFFRAM_PERCENTAGE,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	vec___y;
	LT		offset_6109,	RADAR_SWEEP,	temp_3;
	IFNOT		temp_3,	2;
	RETURN	vec___z;
	RETURN	FALSE;
	DONE;
}

