/*
battleMETAL 
Author: Peter Roohr
Date: 7/9/2018
Overview: 
  AI API Header, covers multiple impl files
*/

//MACROs for AI
// think->nextthink function, use for transitions to next AI frame func, updates all AI subcomponents
#define macro_ai_frame(next_func) if((self.flags&FL_TURRET)){ai_turret_control();}if(self.legs){ai_leg_control();}self.think=next_func;self.nextthink=time+0.05;

//given the ctrl_ update_func, check DEBUG state, and deadflag state, then run global ai_update() function.
#define macro_ai_update(update_func) update_func();if(!(self.spawnflags&DEBUG_MODE)){if(!self.deadflag){ai_update();}}

//parsing out the important bit to macro_ai_frame, ignoring the func calling
#define macro_ai_sub_frames if((self.flags&FL_TURRET)){ai_turret_control();}if(self.legs){ai_leg_control();}

//set ai_action_time, this will loop back to the ai_frame you want to until ai_action_time = 0
#define macro_ai_frame_count(repeat_frame) if(self.ai_action_time>0){self.ai_action_time = self.ai_action_time-1;macro_ai_frame(repeat_frame) return;}

#define macro_ai_frame_hunt(hunt_func) if(!self.ai_node_recall){ai_sfx_huntStart();node_recall_setup();self.goalentity=self.enemy;macro_ai_frame(hunt_func) return;} self.goalentity=self.ai_node_recall;macro_ai_frame(hunt_func) return;

#define macro_ai_movegoal(speed) if( self.movetarget ){movetogoal(speed);}

#define macro_ai_patrol(speed,pauseFunc,nextFunc) local entity nextNode;if((self.goalentity.flags&FL_NODE)){ai_face_goal();if(walkmove(self.angles_y,max(speed,65*AI_WALK_SPD))==FALSE){movetogoal(max(self.data_speed_forward,65*AI_WALK_SPD));//ai_patrol_turn();}if(vlen(self.goalentity.origin-self.origin)<=(random()*AI_NODE_DISTANCE)){if(self.goalentity.pausetime){self.pausetime=self.goalentity.pausetime;self.pausetime=self.pausetime+(self.pausetime*(self.ai_action_mod/10));self.pausetime = self.pausetime+time;}if(self.goalentity.target){nextNode=find(world,targetname,self.goalentity.target);self.movetarget=nextNode;}else{if(self.goalentity.ai_rank>0){self.movetarget=world;self.goalentity.think=SUB_Remove;self.goalentity.nextthink=time+0.1;}else{self.movetarget=ai_goal_offset_node();}} self.goalentity=self.movetarget;if(time<self.pausetime){macro_ai_frame(pauseFunc) return;}} macro_ai_frame(nextFunc) return;} macro_ai_frame(pauseFunc)

#define macro_ai_setup(iniFunc) if(!(self.nextVecChoice)||self.nextVecChoice<=0){self.think=SUB_Remove;self.nextthink=time+0.05;return;}if((self.spawnflags&TRIGGER_ME)&&(self.targetname)){self.wait=1;if(self.delay>0){self.wait=self.delay;self.delay=0;}self.use=ai_unit_make_trigger;self.unit_ini=iniFunc;}else{self.think=iniFunc;self.nextthink=time+0.05;}

//CONSTANTS
float NO_CAMPAIGN = 1;    //remove from campaign mode
float NO_COOP = 2;    //remove from co-op mode
float NO_DM = 4;    //remove from DeathMatch
float NO_TDM = 8;    //remove from Team DeathMatch
float COLD_START = 16;   //on-spawn, bot will ignore friendly help calls
float RANDOM_START = 32;   //start on random node if AI has patrol path
float HAS_RADAR = 64;   //radar is expensive to use, use sparingly
                                        //generally this is for mech units
float DEBUG_MODE = 128; //dont do anything
float NO_NOVICE = 4096;  //remove from Novice Difficulty
float NO_REGULAR = 8192; //remove from Regular Difficulty
float NO_VETERAN = 16384; //remove from Veteran Difficulty
float NO_ELITE = 32768;  //remove from Elit Difficulty
float PROMOTE = 65536;  //AI rank is set by skill, this spawnflag bumps it up by 1
float DEMOTE = 131072;  //AI rank is set by skill, this spawnflag debuffs it up by 1
float NO_DROP = 262144; //don't drop bot to the floor onspawn
float TRIGGER_ME = 524288;  //ai only spawns when triggered
float MUTE_ME = 1048576;  //ai ignores sending voice effects / radio sounds.
float UNARMED = 2097152; //ai spawns with no weapons, skip build_weapons() factory step;

//AI STATE (LEGACY) CONSTANTS
float ST_STAND              = 1;  //th_stand
float ST_WALK               = 2;  //th_walk
float ST_RUN                = 4;  //th_run
float ST_MISSILE            = 7;  //th_missile
float ST_MELEE              = 8;  //th_melee

//AI TURRET CONSTANTS
float TR_NORM               = 0;  //Turret follows the angles of its parent
float TR_TARG               = 1;  //Turret ideal yaw is the parent's .enemy
float TR_GOAL               = 3;  //Turret ideal yaw = parent's .goalentity
float TR_YAW                = 4;  //Turret ideal yaw set by outside source
float TR_LEFT               = 5;  //Turret ideal yaw is left-side away from ai_dir
float TR_RIGHT              = 6;  //Turret ideal yaw is right-side awa from ai_dir;

//VIS CONSTANTS
float VIS_FAIL = 0;
float VIS_FRAC = 1;
float VIS_TRG = 2;
float VIS_FRN = 3;

//GLOBALS
//--> these are populated in AI _combat.qc -> ST_COMBAT state
float enemy_infront;  //boolean, on-this-frame check if target is in AI's forward arc.
float enemy_range;    //distance to AI relative to patrolNode.ai_view (radius)
float enemy_dist;     //target's distance to patrolNode
float combat_dist;    //AI's distance to its patrolNode
float enemy_vis;      //enum, Line of Sight to target
float enemy_hunt;     //potentially deprecated.
float combat_roll;    //per-state-frame dice roll for random movement selection.
vector ai_angle;      //used for temporary angle calcs that preclude overriding the AI's current yaw
//////////////////this are set every frame by every AI, do not rely on these OUTSIDE the function they're called (like all the trace_* globals)

float side_crit;
entity friend_blocker;
float friend_blocker_dist;
entity AI_NODES[128];
vector enemySensorOrg;  //we only care about origin_x and origin_y, radar ignores _z
vector selfSensorOrg;
entity lastNode;        //minor optimization

//ENTITY VARS
.void( entity attacker ) th_react;  //supplants ai_damage_react() call in t_damage();
.float ai_react_buffer;             //prevents too many runs of th_react;
.float ai_react_time;               //stat for react buffer

.float ai_rank;
.float ai_action_time;  //for executing action states
.float ai_action_mod;   //how many times to repeat a frameset before adjusting
.float ai_leading;      //how bad does the ai suck? 0.0 is ACE, 0.2 is pretty bad
.float ai_minrange;     //minimum range of guns;
.float ai_fov;          //the angle of the AI's view for visual target finding
.float ai_view;         //range in game units of AI's vision
.vector ai_angleLimits;       //x = min, y= max, z = pitch speed
.float ai_viewtime;
.float ai_viewcheck;    //interval for checking for enemies
.float ai_hunt_total;   //current number of hunt nodes
.float ai_dir;          //chassis facing vs .angles
.entity ai_node_recall;
.float ai_patrol_speed; //a fraction of forward speed for any unit speed > 100
.float voiceTime; //when next to say something
.float ai_voice_group;

.float helpTime;  //prevents flooding of help calls
.float helpTimeDelay;

//Stat Equations
//AI STATISTICS - ai_stats.qc
void() ai_promote;
float( float rank, float damg) ai_pilot_mod_damage;
vector( float rank, vector spread ) ai_pilot_accuracy;
void() ai_unit_ini_var;
float() ai_pilot_minrange;
void(float rank) ai_pilot_ini_stats;
float( float rank ) ai_pilot_action_mod;
void() ai_pilot_ini_rok;
void() ai_pilot_ini_reg;
void() ai_pilot_ini_vet;
void() ai_pilot_ini_ace;

//AI NODES
void() node_setup;
entity() node_recall_setup;

//AI TETHER FUNCTIONALITY
float TETHER_NONE   = 0;  //-> .tetherStatus
float TETHER_NODE   = 1;  //-> .tetherStatus
float TETHER_PATROL = 2;  //-> .tetherStatus
float TETHER_ENT    = 3;  //-> .tetherStatus
float TETHER_SELF   = 4;  //-> .tetherStatus
.entity tetherNode;
.float tetherStatus; //TETHER_NONE = 0, TETHER_NODE = 1, TETHER_PATROL = 2, TETHER_ENT = 3, TETHER_SELF = 4;
.vector tetherOrg;  //either closest tether-node, patrol node, or starting origin.

////////////////////////////////
//AI interaction functionality - ai_api.qc
float() ai_can_spawn;
void( entity t) ai_call_for_help;
float(entity t) ai_valid_target;
entity( float radiius ) ai_find_friend;
void( entity t) ai_alert_close;
entity( float startSmallRadius ) ai_find_friend_farthest;
float() ai_find_target_visual;
float() ai_find_target_radar;
void( entity ally, entity targ, float override ) ai_give_target;
entity() ai_node_pick_rand;
entity() ai_goal_offset_node;
void() ai_unit_make_trigger;
float(vector destOrg, float wishSpeed) ai_calc_move;
entity(entity node) ai_node_to_target;
entity(float checkDir) ai_get_next_node;
float(entity toCheck) ai_check_node_radius;
float() ai_check_node_radius_targdist;
void() ai_node_tether_find;
float() ai_node_tether_check;
float() ai_patrol_traffic_adjust;

////////////////////////////////
//AI COMBAT FUNCTIONS - ai_combat.qc
float( float scan_mode) ai_check_scan;
void() ai_ranged_attack;
float(entity wep) ai_attack_blockcheck;
void(float dst, float grp, float bracket) ai_wep_group_track;
float(entity wep) ai_attack_checkEne;
float( float bestAccuracy ) ai_wait_for_shot;
void() ai_lock_on;


//AI MAP FUNCS
void( float wep1, float wep2, float wep3, float wep4, float wep5, float wep6, float wep7, float wep8, float wep9) ai_ini_weapons;


//DEPRECATED-----------
//float( float moveSpeed, void() pauseFrameFunc, void() nextFrameFunc ) ai_patrol_logic;
void() ai_move_physics;

float( float moveSpeed, void() nextFrameFunc ) ai_recall_logic
float( void() frameFuncOnSpot, void() frameFuncRangeOut ) ai_hunt_logic_enemy_vis;
//---------------



////////////////////////////////
//AI VOICE STUFF - ai_voice.qc
void( float randomBool ) ai_voice_ini;
void() ai_sfx_spotted;
void() ai_sfx_warning;
void() ai_sfx_huntStart;
void() ai_sfx_huntEnd;
void() ai_sfx_dying;
void() ai_sfx_dead;
void() ai_sfx_kill;
void() ai_sfx_roger;
void() ai_sfx_help;

////////////////////////////////
//AI-CONTROL FUNCTIONS - ai_ctrl.qc

float() ai_blocked_teleport;
float(float angleOfTarget, float facingAngle, float limitMin, float limitMax) ai_check_turret_yaw;
float( float moveAngle, float moveSpeed, void() nextFrameFunc ) ai_move_frame;
void() ai_touch;
void() ai_patrol_state_frame;
void() ai_face_goal;
void(vector v) ai_face_origin;
void() ai_face_targ;
void( float alt_low, float alt_max ) ai_fly_update;
float(entity targ, float ang_limit, float useTurret) ai_check_face;
float(vector v, float ang_limit, float useTurret) ai_check_face_origin;
float(entity t, float ang, float useTurret) ai_check_targ_infront;
float(entity targ) ai_check_range;
float(entity targ) ai_check_vis;
float() ai_attack;
void() ai_setup_patrol;

//movement
.entity patrolNode;
.float ai_wishSpeed;    //calculated on entering a new move


float PATROL_PAUSE        = 1;  //Paused at node because node had .float paustime
float PATROL_WALKING      = 2;  //walking to a node where dist > AI_RANGE_S
float PATROL_ARRIVE       = 3;  //dist <= AI_NODE_DISTANCE
float PATROL_ADJUST       = 4;  //arriving at a node where dist < AI_RANGE_S && dist > AI_NODE_DISTANCE
float PATROL_BLOCK        = 5;  // the walkmove() calls returned FALSE, indicating a blockage
.float patrolState;

float MOVE_STAND          = 0;  //every AI has this
float MOVE_PATROLNODE     = 3;  //AI moves at patrol_frame style movement to get back to node distance.
float MOVE_NODE_CLEAR     = 5;  // enemy_vis == VIS_FRN, so find a node to shoot from
float MOVE_NODE_HIDE      = 6;  // enemy_range > AI_RANGE_M, so try and take cover
float MOVE_NODE_REVERSE   = 7;  // unit is out of node range, do a fighting reverse 
float MOVE_BACK           = 9;
float MOVE_NODE_RADIUS     = 10; // AI is 'ring-out' on their current node

//special mapped moves
float MOVE_CHARGE         = 1;
float MOVE_CHARGE_LEFT    = 2;
float MOVE_CHARGE_RIGHT   = 4;
float MOVE_STRAFE_LEFT    = 8;
float MOVE_STRAFE_RIGHT   = 16;
float MOVE_CIRCLE_LEFT    = 32;
float MOVE_CIRCLE_RIGHT   = 64;
float MOVE_BACK_LEFT      = 128;
float MOVE_BACK_RIGHT     = 256;
float MOVE_SNAPSHOT       = 512;
float MOVE_SNIPESHOT      = 1024;
float MOVE_STAND_FACE     = 2048;

.float ai_state;      //  the current state, usually not accessed directly.
.float ai_state_last; //  used for per-frame comparisons
.float ai_state_next; //  AI-CODE-SET this one to decide the next STATE.

.float ai_dampen;     //  psuedo-velocity, prevents AI from pivoting on a dime, which is hard to players to fight.
.float ai_movewait;   //  set by ai_calc_move when entering a new move, this will be checked for completed move.
.float ai_movedist;   //  AI-CODE-SET to desired number of frames for desired movement
.float ai_dance_card; //  set on spawn, the total number of allowable MOVE
.float ai_move;       //  the current move, usually not accessed directly.
.float ai_move_last;  //  used for per-frame comparisons
.float ai_move_next;  //  AI-CODE-SET this one to decide the next move.

.float ai_moveflag;   //  remaining allowable moves before attempting to refresh the move set
.float ai_blockflag;  //  anytime a move is blocked, subtract from ai_moveflag, and place it here, when ai_blockflag == ai_dance_card, then bot must chill for a sec.
.float ai_clearblock; //  AI-CODE-SET to clear the AI's ai_blockflag on the next frame.

//float ST_STAND                = 1
float ST_PTR                  = 2;  //ENTER -> PATROL
float ST_PTR_PAUSE            = 3;  //arrived at ai_node
float ST_PTR_TRAVEL_NODE      = 4;  //traveling to an ai_node
float ST_PTR_TRAVEL_NODEBLOCK = 5;  //travel to node was blocked for some reason

float ST_COMBAT               = 8;  //ENTER -> COMBAT
float ST_COM_MOVE_START       = 9;  //begin combat maneuver
float ST_COM_MOVE_EXEC        = 10; //execute a prescribed combat maneuver
float ST_COM_MOVE_END         = 11; //completed a combat maneuver
float ST_COM_MOVE_BLOCK       = 12; //combat move was blocked for some reason
float ST_COM_REACT            = 13; //no target but hit by fire

//deprecate asap
//float ST_PTR_TETHER           = 6;  //travel to tetherOrg when tetherStatus != TETHER_PATROL
//float ST_PTR_TETHER_BLOCK     = 7;  //travel to tetherOrg has been blocked

float ST_TRAIL_MOVE           = 14; //
float ST_TRAIL_BLOCK          = 15; //
float ST_TRAIL_ROLLBACK       = 16; //
float ST_TRAIL_ROLLBLOCK      = 17; //

float ST_TRACK_MOVE           = 18;
float ST_TRACK_BLOCK          = 19;
float ST_TRACK_ROLLBACK       = 20;
float ST_TRACK_ROLLBLOCK      = 21;

////////////////////////////////
//AI STATE FUNCTIONS - ai_state.qc
void() ai_update;
void() ai_turret_control;
void() ai_leg_control;
void( float estate ) ai_turret_set_state;
void( float move ) ai_update_accuracy;

void() ai_state_frame;

.void() ai_unit_update;
.void() ai_state_stand;

.void() ai_state_patrol;
.void() ai_state_patrol_pause;
.void() ai_state_patrol_travel_node;
.void() ai_state_patrol_travel_blocked;
.void() ai_state_patrol_tether;
.void() ai_state_patrol_tether_blocked;

.void() ai_state_combat;
.void() ai_state_combat_moveStart;
.void() ai_state_combat_moveExec;
.void() ai_state_combat_moveEnd;
.void() ai_state_combat_blocked;
.void() ai_state_combat_react;

//deprecate----------
.void() ai_state_trail_move;
.void() ai_state_trail_move_block;
.void() ai_state_trail_rollback;
.void() ai_state_trail_rollback_block;
//--------------

.void() ai_state_track_move;
.void() ai_state_track_move_block;
.void() ai_state_track_rollback;
.void() ai_state_track_rollback_block;

void() ai_combat_move_frame;  //sub-state for combat maneuverin'
void() ai_move_stand;
float() ai_move_charge;
float() ai_move_charge_left;
float() ai_move_charge_right;
float() ai_move_strafe_left;
float() ai_move_strafe_right;
float() ai_move_circle_left;
float() ai_move_circle_right;
float() ai_move_back;
float() ai_move_back_left;
float() ai_move_back_right;
void() ai_move_snapshot;
void() ai_move_standface;
void() ai_move_node_hide;
void() ai_move_node_clear;
void() ai_move_node_reverse;
void() ai_move_node_radius;
float(float outRadius, float innerRadius, float proxRadius) ai_move_patrol_node;


//DEBUG functions
//when you need the var-name for a global var value.
string(float stateId) dbg_state={
  switch(stateId){
    case ST_STAND:
      return "ST_STAND";
    case ST_PTR:
      return "ST_PTR";
    case ST_PTR_PAUSE:
      return "ST_PTR_PAUSE";
    case ST_PTR_TRAVEL_NODE:
      return "ST_PTR_TRAVEL_NODE";
    case ST_PTR_TRAVEL_NODEBLOCK:
      return "ST_PTR_TRAVEL_NODEBLOCK";
    case ST_COMBAT:
      return "ST_COMBAT";
    case ST_COM_MOVE_START:
      return "ST_COM_MOVE_START";
    case ST_COM_MOVE_EXEC:
      return "ST_COM_MOVE_EXEC";
    case ST_COM_MOVE_END:
      return "ST_COM_MOVE_END";
    case ST_COM_MOVE_BLOCK:
      return "ST_COM_MOVE_BLOCK";
  }
  return "null";
}
string(float moveId) dbg_move={
  switch(moveId){
    case MOVE_STAND:
      return "MOVE_STAND";
    case MOVE_CHARGE:
      return "MOVE_CHARGE";
    case MOVE_CHARGE_LEFT:
      return "MOVE_CHARGE_LEFT";
    case MOVE_CHARGE_RIGHT:
      return "MOVE_CHARGE_RIGHT";
    case MOVE_STRAFE_LEFT:
      return "MOVE_STRAFE_LEFT";
    case MOVE_STRAFE_RIGHT:
      return "MOVE_STRAFE_RIGHT";
    case MOVE_CIRCLE_LEFT:
      return "MOVE_CIRCLE_LEFT";
    case MOVE_CIRCLE_RIGHT:
      return "MOVE_CIRCLE_RIGHT";
    case MOVE_BACK:
      return "MOVE_BACK";
    case MOVE_BACK_LEFT:
      return "MOVE_BACK_LEFT";
    case MOVE_BACK_RIGHT:
      return "MOVE_BACK_RIGHT";
    case MOVE_PATROLNODE:
      return "MOVE_PATROLNODE";
    case MOVE_SNAPSHOT:
      return "MOVE_SNAPSHOT";
    case MOVE_SNIPESHOT:
      return "MOVE_SNIPESHOT";
    case MOVE_STAND_FACE:
      return "MOVE_STAND_FACE";
    case MOVE_NODE_HIDE:
      return "MOVE_NODE_HIDE";
    case MOVE_NODE_CLEAR:
      return "MOVE_NODE_CLEAR";
    case MOVE_NODE_REVERSE:
      return "MOVE_NODE_REVERSE";
    case MOVE_NODE_RADIUS:
      return "MOVE_NODE_RADIUS";
  }
  return "null";
}