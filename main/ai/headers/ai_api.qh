/*
battleMETAL 
Author: Peter Roohr
Date: 7/9/2018
Overview: 
  AI API Header, covers multiple impl files
*/

//MACROs for AI
#define macro_ai_setup(iniFunc) if(!(self.nextVecChoice)||self.nextVecChoice<=0){self.think=SUB_Remove;self.nextthink=time+0.05;return;}if((self.spawnflags&TRIGGER_ME)&&(self.targetname)){self.wait=1;if(self.delay>0){self.wait=self.delay;self.delay=0;}self.use=ai_unit_make_trigger;self.unit_ini=iniFunc;}else{self.think=iniFunc;self.nextthink=time+0.05;}

//AI STATE (LEGACY) CONSTANTS
float ST_WALK               = 2;  //th_walk
float ST_RUN                = 4;  //th_run
float ST_MISSILE            = 7;  //th_missile
float ST_MELEE              = 8;  //th_melee

//AI TURRET CONSTANTS
float TR_NORM               = 0;  //Turret follows the angles of its parent
float TR_TARG               = 1;  //Turret ideal yaw is the parent's .enemy
float TR_GOAL               = 3;  //Turret ideal yaw = parent's .goalentity
float TR_YAW                = 4;  //Turret ideal yaw set by outside source
float TR_LEFT               = 5;  //Turret ideal yaw is left-side away from ai_dir
float TR_RIGHT              = 6;  //Turret ideal yaw is right-side awa from ai_dir;

//VIS CONSTANTS
float VIS_FAIL  = 0;  //complete LOS block via map, building, doodad
float VIS_FRAC  = 1;  //LOS is solid, clear shot
float VIS_FRN   = 2;  //A friendly is blocking the way
float VIS_ENEMY = 3;  //a moving enemy is blocking the way.

//GLOBALS
//--> these are populated in AI _combat.qc -> ST_COMBAT state
float enemy_infront;  //boolean, on-this-frame check if target is in AI's forward arc.
float enemy_range;    //distance to AI relative to patrolNode.ai_view (radius)
float enemy_dist;     //target's distance to patrolNode
float combat_dist;    //AI's distance to its patrolNode
float enemy_vis;      //enum, Line of Sight to target
float combat_roll;    //per-state-frame dice roll for random movement selection.

float yawCache;       //used to quickly cache yaw to do some per-frame mods

vector enemySensorOrg;  //we only care about origin_x and origin_y, radar ignores _z
vector selfSensorOrg;

entity lastNode;        //minor optimization for assigning ai_nodes for patrols by reducing lookup times.

void(entity newAttacker) ai_react_generic;
entity alarm_ent; //per-frame global used to prevent near-endless alarm loops

//////////////////this are set every frame by every AI, do not rely on these OUTSIDE the function they're called (like all the trace_* globals)
//ENTITY VARS
.float ai_react_buffer;             //prevents too many runs of th_react;
.float ai_react_time;               //stat for react buffer

.float entnum;
.float ai_rank;
.float ai_action_time;  //for executing action states
.float ai_action_mod;   //how many times to repeat a frameset before adjusting
.float ai_leading;      //how bad does the ai suck? 0.0 is ACE, 0.2 is pretty bad
.float ai_minrange;     //minimum range of guns;
.float ai_fov;          //the angle of the AI's view for visual target finding
.float ai_view;         //range in game units of AI's vision
.vector ai_angleLimits;       //x = min, y= max, z = pitch speed
.float ai_viewtime;
.float ai_viewcheck;    //interval for checking for enemies
.float ai_patrol_speed; //a fraction of forward speed for any unit speed > 100
.float voiceTime; //when next to say something
.float ai_voice_group;
.float helpTime;  //prevents flooding of help calls
.float helpTimeDelay;

//Stat Equations
//AI STATISTICS - ai_stats.qc
void() ai_promote;
float( float rank, float damg) ai_pilot_mod_damage;
vector( float rank, vector spread ) ai_pilot_accuracy;
void() ai_unit_ini_var;
float() ai_pilot_minrange;
void(float rank) ai_pilot_ini_stats;
float( float rank ) ai_pilot_action_mod;
void() ai_pilot_ini_rok;
void() ai_pilot_ini_reg;
void() ai_pilot_ini_vet;
void() ai_pilot_ini_ace;

//AI NODEGRAPH
.float reverseFlag;
void() node_setup;
.float nq1; //to keep per-AI pathfinding costs low, we cache the next 4 nodes that the bot must go to
.float nq2; //here, so that they're not asking the nodegraph to pathfind every frame for every bot.
.float nq3;
.float nq4;
.float nq5;
.float nq6;
.float nq7;
.float nq8;
.float nq9;
.float nq10;
.float nq11;
.float nq12;
.float nq13;
.float nq14;
.float nq15;
.float nq16;
.float nq17;
.float nq18;
.float nq19;
.float nq20;
.float nq21;
.float nq22;
.float nq23;
.float nq24;
.float pathEndId; //actual end node to the path, used for early exit / check of nq1-16 path cache.

void() ai_nodegraph_clear_locks;
void() ai_nodegraph_clear_path; //mostly just for ini.
float( float nodeId ) ai_nodegraph_distance_check;  //get distance to desired node
float() ai_nodegraph_next; //updates .nodeQueue slots, returns FALSE if there are more nodes to go.
float( float startId, float endId ) ai_nodegraph_trace_route;
float( vector startPos, vector endPos ) ai_nodegraph_trace_vec;     // wraps nodegraph_trace() by allowing start / end pos
float( vector startPos, float endId ) ai_nodegraph_trace_vecToNode; //given a map org, and a known endId
float( float startId, vector endPos ) ai_nodegraph_trace_nodeToVec; //given a known endId, and a map org
float(vector testOrg) ai_nodegraph_to_org; //find closest node to AI's desired patrol point.
float(vector entOrg) ai_nodegraph_find_node; //find closest node to self;
float(vector testOrg, float radius) ai_nodegraph_find_hide_node;

float( vector src, float radius, float atkAngle, float furtherFlag) ai_nodegraph_attack_node_close;  //given an attack angle, and a target origin, find the closest node
float( vector src, float radius, float offSet, float atkAngle, float furtherFlag) ai_nodegraph_find_node_to_angle
float( vector src, float radius ) ai_nodegraph_attack_strafe_left;
float( vector src, float radius ) ai_nodegraph_attack_strafe_right;
float( vector src, float radius ) ai_nodegraph_attack_flank_rear;
float( vector src, float radius ) ai_nodegraph_attack_flank_left;
float( vector src, float radius ) ai_nodegraph_attack_flank_right;
float( vector src, float radius ) ai_nodegraph_retreat;
float( vector src, float radius ) ai_nodegraph_attack_charge;
float( float angl, float range, float radius ) ai_nodegraph_free_move;

//AI TETHER FUNCTIONALITY
 //no valid targets, AI will chill in a spot if it loses target, it  looks for new ones near it. no real fixed position.
float TETHER_NONE   = 0; 

//must have valid {ai_node_tether} to target, and will maintain that area. (ai_tether.qc).
float TETHER_NODE   = 1;  //no target, default -> TETHER_NONE || skill > REG on mechs, TETHER_NOMAD;

//must have valid {ai_node} to target, this will give it a patrol path (ai_patrol.qc).
float TETHER_PATROL = 2;  

//will wander the map randomly, finding random nodes to move to.  TODO
float TETHER_NOMAD   = 3; 

//marks its own starting origin as the original point to move back to.
float TETHER_SELF   = 4;  
.float tether;      //can be set by mapper too
.vector tetherOrg;        //either closest tether-node, patrol node, or starting origin.

////////////////////////////////
//AI interaction functionality - ai_api.qc
float() ai_can_spawn;
void( entity t) ai_call_for_help;
float(entity t) ai_valid_target;
entity( float radiius ) ai_find_friend;
void( entity t) ai_alert_close;
float() ai_find_target_visual;
float() ai_find_target_radar;
void( entity ally, entity targ, float override ) ai_give_target;
void() ai_unit_make_trigger;
float(vector destOrg, float wishSpeed) ai_calc_move;
entity(entity node) ai_node_to_target;
entity(float checkDir) ai_get_next_node;
float(entity toCheck) ai_check_node_radius;
float() ai_check_node_radius_targdist;
entity() ai_node_tether_find;
float( vector source, vector trgdst ) ai_check_terrain_move;
void(entity none) ai_NULL_pain={ };
float() ai_NULL_missile={ return FALSE;};

////////////////////////////////
//AI COMBAT FUNCTIONS - ai_combat.qc
float COMBAT_RANGE_CLOSE     = 1;
float COMBAT_RANGE_MID       = 2;
float COMBAT_RANGE_LONG      = 4;
float COMBAT_FRONT           = 8;
float COMBAT_VIS             = 16;
float COMBAT_FRIEND          = 32;
float COMBAT_LEFT            = 64;

.float prevVis;
.float prevFacing;
.float combatFlags; //populated by ai_combat_state_frame()

float( float scan_mode) ai_check_scan;
void() ai_ranged_attack;
float(entity wep) ai_attack_blockcheck;
void(float dst, float grp, float bracket) ai_wep_group_track;
float(entity wep) ai_attack_checkEne;
float( float bestAccuracy ) ai_wait_for_shot;
void() ai_lock_on;

//AI MAP FUNCS
void( float wep1, float wep2, float wep3, float wep4, float wep5, float wep6, float wep7, float wep8, float wep9) ai_ini_weapons;

////////////////////////////////
//AI VOICE STUFF - ai_voice.qc
void( float randomBool ) ai_voice_ini;
void() ai_sfx_spotted;
void() ai_sfx_warning;
void() ai_sfx_huntStart;
void() ai_sfx_huntEnd;
void() ai_sfx_dying;
void() ai_sfx_dead;
void() ai_sfx_kill;
void() ai_sfx_roger;
void() ai_sfx_help;

////////////////////////////////
//AI-CONTROL FUNCTIONS - ai_ctrl.qc
float() ai_blocked_teleport;
float(float angleOfTarget, float facingAngle, float limitMin, float limitMax) ai_check_turret_yaw;
void() ai_touch;
void() ai_patrol_state_frame;
void() ai_face_goal;
void(vector v) ai_face_origin;
void() ai_face_targ;
void() ai_face_targ_fade; //uses last-known position
void( float alt_low, float alt_max ) ai_fly_update;
float(entity targ, float ang_limit, float useTurret) ai_check_face;
float(vector v, float ang_limit, float useTurret) ai_check_face_origin;
float(entity t, float ang, float useTurret) ai_check_targ_infront;
float(entity targ) ai_check_range;
float(entity targ) ai_check_vis;
float() ai_attack;
void() ai_setup_patrol;

//movement
.vector moveDest;       //combat moves, target destination
.entity patrolNode;
.float ai_wishSpeed;    //calculated on entering a new move

float PATROL_PAUSE        = 1;  //Paused at node because node had .float paustime
float PATROL_WALKING      = 2;  //walking to a node where dist > AI_RANGE_S
float PATROL_ARRIVE       = 3;  //dist <= AI_NODE_DISTANCE
float PATROL_ADJUST       = 4;  //arriving at a node where dist < AI_RANGE_S && dist > AI_NODE_DISTANCE
float PATROL_BLOCK        = 5;  // the walkmove() calls returned FALSE, indicating a blockage
.float patrolState;
.float patrolStateLast;


.float ai_state;      //  the current state, usually not accessed directly.
.float ai_state_next;
.float ai_state_last;

.float ai_movewait;   //  set by ai_calc_move when entering a new move, this will be checked for completed move.
.float ai_movedist;   //  AI-CODE-SET to desired number of frames for desired movement
.float ai_blockflag;

float ST_STAND                = 1;  //th_stand
float ST_PTR                  = 2;
////////////////////////////////
//AI STATE FUNCTIONS - ai_state.qc
void() ai_update;
void() ai_turret_control;
void() ai_leg_control;
void( float estate ) ai_turret_set_state;
void( float move ) ai_update_accuracy;

.void() ai_unit_update;

//atomic impl
.void() ai_set_state;
void() ai_frame_update;

void() ai_state_lurker_frame;    //todo - rename, move to 'lurker'
void() ai_state_brawler_frame;
void() ai_state_hunter_frame;

void() ai_patrol_frame_2;

void() ai_state_turret_frame;

void() ai_nodegraph_combat_frame;

.float ai_timer_checkTurn; // if yawspeed too low for ideal_yaw over X time, this makes the bot turn harder.
.float ai_hardTurn; // 

//hold off on these for a sec
//void() ai_turn_node;
//void() ai_turn_patrol;
//void() ai_turn_combat;


//DEBUG functions
//when you need the var-name for a global var value.


string(float tether) dbg_tether={
  switch(tether){
    case TETHER_NODE:
      return "TETHER_NODE";
    case TETHER_PATROL:
      return "TETHER_PATROL";
    case TETHER_NOMAD:
      return "TETHER_NOMAD";
    case TETHER_NONE:
      return "TETHER_NONE";
  }
  return "null";
};

string(float patrol) dbg_patrol={
  switch(patrol){
    case PATROL_ADJUST:
      return "PATROL_ADJUST";
    case PATROL_ARRIVE:
      return "PATROL_ARRIVE";
    case PATROL_BLOCK:
      return "PATROL_BLOCK";
    case PATROL_PAUSE:
      return "PATROL_PAUSE";
    case PATROL_WALKING:
      return "PATROL_WALKING";
  }
  return "null";
};